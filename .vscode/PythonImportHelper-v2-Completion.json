[
    {
        "label": "parse",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "NodeVisitor",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "Name",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "NodeVisitor",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "Name",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "NodeVisitor",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "Name",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "NodeVisitor",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "Name",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "NodeVisitor",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "Name",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "NodeVisitor",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "Name",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "NodeVisitor",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "Name",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "NodeVisitor",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "Name",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "NodeVisitor",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "Name",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "operator",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "operator",
        "description": "operator",
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "add",
        "importPath": "operator",
        "description": "operator",
        "isExtraImport": true,
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "sub",
        "importPath": "operator",
        "description": "operator",
        "isExtraImport": true,
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "add",
        "importPath": "operator",
        "description": "operator",
        "isExtraImport": true,
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "mul",
        "importPath": "operator",
        "description": "operator",
        "isExtraImport": true,
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "sub",
        "importPath": "operator",
        "description": "operator",
        "isExtraImport": true,
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "mul",
        "importPath": "operator",
        "description": "operator",
        "isExtraImport": true,
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "num_factors",
        "importPath": "projects.hog.hog",
        "description": "projects.hog.hog",
        "isExtraImport": true,
        "detail": "projects.hog.hog",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "sqrt",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "sqrt",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "sqrt",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "classes",
        "description": "classes",
        "isExtraImport": true,
        "detail": "classes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "classes",
        "description": "classes",
        "isExtraImport": true,
        "detail": "classes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "cards",
        "description": "cards",
        "isExtraImport": true,
        "detail": "cards",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "randrange",
        "importPath": "random",
        "description": "random",
        "isExtraImport": true,
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "randrange",
        "importPath": "random",
        "description": "random",
        "isExtraImport": true,
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "randrange",
        "importPath": "random",
        "description": "random",
        "isExtraImport": true,
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "randint",
        "importPath": "random",
        "description": "random",
        "isExtraImport": true,
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "inspect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "inspect",
        "description": "inspect",
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Number",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "bools",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "SingletonFalse",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "ValueHolder",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Pair",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "SingletonTrue",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Undefined",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Symbol",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Number",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Symbol",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Number",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Pair",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Nil",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Undefined",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Boolean",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Promise",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Undefined",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Pair",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Symbol",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Number",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Nil",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "SingletonTrue",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "SingletonFalse",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Number",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Undefined",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Symbol",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Pair",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Nil",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Number",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "NilType",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Pair",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Nil",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Number",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Undefined",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "NilType",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Promise",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "ValueHolder",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Pair",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Nil",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Symbol",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Undefined",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Promise",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "NilType",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "UndefinedType",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Symbol",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Pair",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "SingletonTrue",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "SingletonFalse",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Nil",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Undefined",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Promise",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "NilType",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Boolean",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Number",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Symbol",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Nil",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "SingletonTrue",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "SingletonFalse",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Pair",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "bools",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Undefined",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Pair",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Number",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "bools",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "SingletonFalse",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "ValueHolder",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Pair",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "SingletonTrue",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Undefined",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Symbol",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Number",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Symbol",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Number",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Pair",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Nil",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Undefined",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Boolean",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Promise",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Undefined",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Pair",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Symbol",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Number",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Nil",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "SingletonTrue",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "SingletonFalse",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Number",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Undefined",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Symbol",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Pair",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Nil",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Number",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "NilType",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Pair",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Nil",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Number",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Undefined",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "NilType",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Promise",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "ValueHolder",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Pair",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Nil",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Symbol",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Undefined",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Promise",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "NilType",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "UndefinedType",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Symbol",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Pair",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "SingletonTrue",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "SingletonFalse",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Nil",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Undefined",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Promise",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "NilType",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Boolean",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Number",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Symbol",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Nil",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "SingletonTrue",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "SingletonFalse",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Pair",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "bools",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Undefined",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "Pair",
        "importPath": "datamodel",
        "description": "datamodel",
        "isExtraImport": true,
        "detail": "datamodel",
        "documentation": {}
    },
    {
        "label": "global_attr",
        "importPath": "environment",
        "description": "environment",
        "isExtraImport": true,
        "detail": "environment",
        "documentation": {}
    },
    {
        "label": "global_attr",
        "importPath": "environment",
        "description": "environment",
        "isExtraImport": true,
        "detail": "environment",
        "documentation": {}
    },
    {
        "label": "global_attr",
        "importPath": "environment",
        "description": "environment",
        "isExtraImport": true,
        "detail": "environment",
        "documentation": {}
    },
    {
        "label": "global_attr",
        "importPath": "environment",
        "description": "environment",
        "isExtraImport": true,
        "detail": "environment",
        "documentation": {}
    },
    {
        "label": "global_attr",
        "importPath": "environment",
        "description": "environment",
        "isExtraImport": true,
        "detail": "environment",
        "documentation": {}
    },
    {
        "label": "special_form",
        "importPath": "environment",
        "description": "environment",
        "isExtraImport": true,
        "detail": "environment",
        "documentation": {}
    },
    {
        "label": "global_attr",
        "importPath": "environment",
        "description": "environment",
        "isExtraImport": true,
        "detail": "environment",
        "documentation": {}
    },
    {
        "label": "global_attr",
        "importPath": "environment",
        "description": "environment",
        "isExtraImport": true,
        "detail": "environment",
        "documentation": {}
    },
    {
        "label": "global_attr",
        "importPath": "environment",
        "description": "environment",
        "isExtraImport": true,
        "detail": "environment",
        "documentation": {}
    },
    {
        "label": "global_attr",
        "importPath": "environment",
        "description": "environment",
        "isExtraImport": true,
        "detail": "environment",
        "documentation": {}
    },
    {
        "label": "global_attr",
        "importPath": "environment",
        "description": "environment",
        "isExtraImport": true,
        "detail": "environment",
        "documentation": {}
    },
    {
        "label": "global_attr",
        "importPath": "environment",
        "description": "environment",
        "isExtraImport": true,
        "detail": "environment",
        "documentation": {}
    },
    {
        "label": "global_attr",
        "importPath": "environment",
        "description": "environment",
        "isExtraImport": true,
        "detail": "environment",
        "documentation": {}
    },
    {
        "label": "special_form",
        "importPath": "environment",
        "description": "environment",
        "isExtraImport": true,
        "detail": "environment",
        "documentation": {}
    },
    {
        "label": "global_attr",
        "importPath": "environment",
        "description": "environment",
        "isExtraImport": true,
        "detail": "environment",
        "documentation": {}
    },
    {
        "label": "global_attr",
        "importPath": "environment",
        "description": "environment",
        "isExtraImport": true,
        "detail": "environment",
        "documentation": {}
    },
    {
        "label": "evaluate_apply",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "evaluate_apply",
        "description": "evaluate_apply",
        "detail": "evaluate_apply",
        "documentation": {}
    },
    {
        "label": "Frame",
        "importPath": "evaluate_apply",
        "description": "evaluate_apply",
        "isExtraImport": true,
        "detail": "evaluate_apply",
        "documentation": {}
    },
    {
        "label": "Frame",
        "importPath": "evaluate_apply",
        "description": "evaluate_apply",
        "isExtraImport": true,
        "detail": "evaluate_apply",
        "documentation": {}
    },
    {
        "label": "Frame",
        "importPath": "evaluate_apply",
        "description": "evaluate_apply",
        "isExtraImport": true,
        "detail": "evaluate_apply",
        "documentation": {}
    },
    {
        "label": "evaluate",
        "importPath": "evaluate_apply",
        "description": "evaluate_apply",
        "isExtraImport": true,
        "detail": "evaluate_apply",
        "documentation": {}
    },
    {
        "label": "Frame",
        "importPath": "evaluate_apply",
        "description": "evaluate_apply",
        "isExtraImport": true,
        "detail": "evaluate_apply",
        "documentation": {}
    },
    {
        "label": "Frame",
        "importPath": "evaluate_apply",
        "description": "evaluate_apply",
        "isExtraImport": true,
        "detail": "evaluate_apply",
        "documentation": {}
    },
    {
        "label": "Frame",
        "importPath": "evaluate_apply",
        "description": "evaluate_apply",
        "isExtraImport": true,
        "detail": "evaluate_apply",
        "documentation": {}
    },
    {
        "label": "evaluate_all",
        "importPath": "evaluate_apply",
        "description": "evaluate_apply",
        "isExtraImport": true,
        "detail": "evaluate_apply",
        "documentation": {}
    },
    {
        "label": "Applicable",
        "importPath": "evaluate_apply",
        "description": "evaluate_apply",
        "isExtraImport": true,
        "detail": "evaluate_apply",
        "documentation": {}
    },
    {
        "label": "Frame",
        "importPath": "evaluate_apply",
        "description": "evaluate_apply",
        "isExtraImport": true,
        "detail": "evaluate_apply",
        "documentation": {}
    },
    {
        "label": "evaluate",
        "importPath": "evaluate_apply",
        "description": "evaluate_apply",
        "isExtraImport": true,
        "detail": "evaluate_apply",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "evaluate_apply",
        "description": "evaluate_apply",
        "isExtraImport": true,
        "detail": "evaluate_apply",
        "documentation": {}
    },
    {
        "label": "evaluate_all",
        "importPath": "evaluate_apply",
        "description": "evaluate_apply",
        "isExtraImport": true,
        "detail": "evaluate_apply",
        "documentation": {}
    },
    {
        "label": "Applicable",
        "importPath": "evaluate_apply",
        "description": "evaluate_apply",
        "isExtraImport": true,
        "detail": "evaluate_apply",
        "documentation": {}
    },
    {
        "label": "Frame",
        "importPath": "evaluate_apply",
        "description": "evaluate_apply",
        "isExtraImport": true,
        "detail": "evaluate_apply",
        "documentation": {}
    },
    {
        "label": "Frame",
        "importPath": "evaluate_apply",
        "description": "evaluate_apply",
        "isExtraImport": true,
        "detail": "evaluate_apply",
        "documentation": {}
    },
    {
        "label": "Frame",
        "importPath": "evaluate_apply",
        "description": "evaluate_apply",
        "isExtraImport": true,
        "detail": "evaluate_apply",
        "documentation": {}
    },
    {
        "label": "Frame",
        "importPath": "evaluate_apply",
        "description": "evaluate_apply",
        "isExtraImport": true,
        "detail": "evaluate_apply",
        "documentation": {}
    },
    {
        "label": "evaluate",
        "importPath": "evaluate_apply",
        "description": "evaluate_apply",
        "isExtraImport": true,
        "detail": "evaluate_apply",
        "documentation": {}
    },
    {
        "label": "Frame",
        "importPath": "evaluate_apply",
        "description": "evaluate_apply",
        "isExtraImport": true,
        "detail": "evaluate_apply",
        "documentation": {}
    },
    {
        "label": "Frame",
        "importPath": "evaluate_apply",
        "description": "evaluate_apply",
        "isExtraImport": true,
        "detail": "evaluate_apply",
        "documentation": {}
    },
    {
        "label": "Frame",
        "importPath": "evaluate_apply",
        "description": "evaluate_apply",
        "isExtraImport": true,
        "detail": "evaluate_apply",
        "documentation": {}
    },
    {
        "label": "evaluate_all",
        "importPath": "evaluate_apply",
        "description": "evaluate_apply",
        "isExtraImport": true,
        "detail": "evaluate_apply",
        "documentation": {}
    },
    {
        "label": "Applicable",
        "importPath": "evaluate_apply",
        "description": "evaluate_apply",
        "isExtraImport": true,
        "detail": "evaluate_apply",
        "documentation": {}
    },
    {
        "label": "Frame",
        "importPath": "evaluate_apply",
        "description": "evaluate_apply",
        "isExtraImport": true,
        "detail": "evaluate_apply",
        "documentation": {}
    },
    {
        "label": "evaluate",
        "importPath": "evaluate_apply",
        "description": "evaluate_apply",
        "isExtraImport": true,
        "detail": "evaluate_apply",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "evaluate_apply",
        "description": "evaluate_apply",
        "isExtraImport": true,
        "detail": "evaluate_apply",
        "documentation": {}
    },
    {
        "label": "evaluate_all",
        "importPath": "evaluate_apply",
        "description": "evaluate_apply",
        "isExtraImport": true,
        "detail": "evaluate_apply",
        "documentation": {}
    },
    {
        "label": "Applicable",
        "importPath": "evaluate_apply",
        "description": "evaluate_apply",
        "isExtraImport": true,
        "detail": "evaluate_apply",
        "documentation": {}
    },
    {
        "label": "Frame",
        "importPath": "evaluate_apply",
        "description": "evaluate_apply",
        "isExtraImport": true,
        "detail": "evaluate_apply",
        "documentation": {}
    },
    {
        "label": "assert_all_numbers",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "verify_exact_callable_length",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "verify_min_callable_length",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "verify_exact_callable_length",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "pair_to_list",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "pair_to_list",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "make_list",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "verify_exact_callable_length",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "verify_min_callable_length",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "pair_to_list",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "make_list",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "verify_exact_callable_length",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "pair_to_list",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "verify_exact_callable_length",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "pair_to_list",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "verify_exact_callable_length",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "verify_min_callable_length",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "pair_to_list",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "verify_exact_callable_length",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "assert_all_numbers",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "verify_exact_callable_length",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "verify_min_callable_length",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "verify_exact_callable_length",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "pair_to_list",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "pair_to_list",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "make_list",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "verify_exact_callable_length",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "verify_min_callable_length",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "pair_to_list",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "make_list",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "verify_exact_callable_length",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "pair_to_list",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "verify_exact_callable_length",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "pair_to_list",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "verify_exact_callable_length",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "verify_min_callable_length",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "pair_to_list",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "verify_exact_callable_length",
        "importPath": "helper",
        "description": "helper",
        "isExtraImport": true,
        "detail": "helper",
        "documentation": {}
    },
    {
        "label": "BuiltIn",
        "importPath": "primitives",
        "description": "primitives",
        "isExtraImport": true,
        "detail": "primitives",
        "documentation": {}
    },
    {
        "label": "SingleOperandPrimitive",
        "importPath": "primitives",
        "description": "primitives",
        "isExtraImport": true,
        "detail": "primitives",
        "documentation": {}
    },
    {
        "label": "SingleOperandPrimitive",
        "importPath": "primitives",
        "description": "primitives",
        "isExtraImport": true,
        "detail": "primitives",
        "documentation": {}
    },
    {
        "label": "BuiltIn",
        "importPath": "primitives",
        "description": "primitives",
        "isExtraImport": true,
        "detail": "primitives",
        "documentation": {}
    },
    {
        "label": "SingleOperandPrimitive",
        "importPath": "primitives",
        "description": "primitives",
        "isExtraImport": true,
        "detail": "primitives",
        "documentation": {}
    },
    {
        "label": "BuiltIn",
        "importPath": "primitives",
        "description": "primitives",
        "isExtraImport": true,
        "detail": "primitives",
        "documentation": {}
    },
    {
        "label": "SingleOperandPrimitive",
        "importPath": "primitives",
        "description": "primitives",
        "isExtraImport": true,
        "detail": "primitives",
        "documentation": {}
    },
    {
        "label": "BuiltIn",
        "importPath": "primitives",
        "description": "primitives",
        "isExtraImport": true,
        "detail": "primitives",
        "documentation": {}
    },
    {
        "label": "SingleOperandPrimitive",
        "importPath": "primitives",
        "description": "primitives",
        "isExtraImport": true,
        "detail": "primitives",
        "documentation": {}
    },
    {
        "label": "BuiltIn",
        "importPath": "primitives",
        "description": "primitives",
        "isExtraImport": true,
        "detail": "primitives",
        "documentation": {}
    },
    {
        "label": "SingleOperandPrimitive",
        "importPath": "primitives",
        "description": "primitives",
        "isExtraImport": true,
        "detail": "primitives",
        "documentation": {}
    },
    {
        "label": "BuiltIn",
        "importPath": "primitives",
        "description": "primitives",
        "isExtraImport": true,
        "detail": "primitives",
        "documentation": {}
    },
    {
        "label": "SingleOperandPrimitive",
        "importPath": "primitives",
        "description": "primitives",
        "isExtraImport": true,
        "detail": "primitives",
        "documentation": {}
    },
    {
        "label": "BuiltIn",
        "importPath": "primitives",
        "description": "primitives",
        "isExtraImport": true,
        "detail": "primitives",
        "documentation": {}
    },
    {
        "label": "SingleOperandPrimitive",
        "importPath": "primitives",
        "description": "primitives",
        "isExtraImport": true,
        "detail": "primitives",
        "documentation": {}
    },
    {
        "label": "SingleOperandPrimitive",
        "importPath": "primitives",
        "description": "primitives",
        "isExtraImport": true,
        "detail": "primitives",
        "documentation": {}
    },
    {
        "label": "BuiltIn",
        "importPath": "primitives",
        "description": "primitives",
        "isExtraImport": true,
        "detail": "primitives",
        "documentation": {}
    },
    {
        "label": "SingleOperandPrimitive",
        "importPath": "primitives",
        "description": "primitives",
        "isExtraImport": true,
        "detail": "primitives",
        "documentation": {}
    },
    {
        "label": "BuiltIn",
        "importPath": "primitives",
        "description": "primitives",
        "isExtraImport": true,
        "detail": "primitives",
        "documentation": {}
    },
    {
        "label": "SingleOperandPrimitive",
        "importPath": "primitives",
        "description": "primitives",
        "isExtraImport": true,
        "detail": "primitives",
        "documentation": {}
    },
    {
        "label": "BuiltIn",
        "importPath": "primitives",
        "description": "primitives",
        "isExtraImport": true,
        "detail": "primitives",
        "documentation": {}
    },
    {
        "label": "SingleOperandPrimitive",
        "importPath": "primitives",
        "description": "primitives",
        "isExtraImport": true,
        "detail": "primitives",
        "documentation": {}
    },
    {
        "label": "BuiltIn",
        "importPath": "primitives",
        "description": "primitives",
        "isExtraImport": true,
        "detail": "primitives",
        "documentation": {}
    },
    {
        "label": "SingleOperandPrimitive",
        "importPath": "primitives",
        "description": "primitives",
        "isExtraImport": true,
        "detail": "primitives",
        "documentation": {}
    },
    {
        "label": "BuiltIn",
        "importPath": "primitives",
        "description": "primitives",
        "isExtraImport": true,
        "detail": "primitives",
        "documentation": {}
    },
    {
        "label": "SingleOperandPrimitive",
        "importPath": "primitives",
        "description": "primitives",
        "isExtraImport": true,
        "detail": "primitives",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "log",
        "description": "log",
        "detail": "log",
        "documentation": {}
    },
    {
        "label": "Holder",
        "importPath": "log",
        "description": "log",
        "isExtraImport": true,
        "detail": "log",
        "documentation": {}
    },
    {
        "label": "Root",
        "importPath": "log",
        "description": "log",
        "isExtraImport": true,
        "detail": "log",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "log",
        "description": "log",
        "isExtraImport": true,
        "detail": "log",
        "documentation": {}
    },
    {
        "label": "Holder",
        "importPath": "log",
        "description": "log",
        "isExtraImport": true,
        "detail": "log",
        "documentation": {}
    },
    {
        "label": "Holder",
        "importPath": "log",
        "description": "log",
        "isExtraImport": true,
        "detail": "log",
        "documentation": {}
    },
    {
        "label": "VisualExpression",
        "importPath": "log",
        "description": "log",
        "isExtraImport": true,
        "detail": "log",
        "documentation": {}
    },
    {
        "label": "return_symbol",
        "importPath": "log",
        "description": "log",
        "isExtraImport": true,
        "detail": "log",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "log",
        "description": "log",
        "isExtraImport": true,
        "detail": "log",
        "documentation": {}
    },
    {
        "label": "Holder",
        "importPath": "log",
        "description": "log",
        "isExtraImport": true,
        "detail": "log",
        "documentation": {}
    },
    {
        "label": "Root",
        "importPath": "log",
        "description": "log",
        "isExtraImport": true,
        "detail": "log",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "log",
        "description": "log",
        "isExtraImport": true,
        "detail": "log",
        "documentation": {}
    },
    {
        "label": "Holder",
        "importPath": "log",
        "description": "log",
        "isExtraImport": true,
        "detail": "log",
        "documentation": {}
    },
    {
        "label": "Holder",
        "importPath": "log",
        "description": "log",
        "isExtraImport": true,
        "detail": "log",
        "documentation": {}
    },
    {
        "label": "VisualExpression",
        "importPath": "log",
        "description": "log",
        "isExtraImport": true,
        "detail": "log",
        "documentation": {}
    },
    {
        "label": "return_symbol",
        "importPath": "log",
        "description": "log",
        "isExtraImport": true,
        "detail": "log",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "log",
        "description": "log",
        "isExtraImport": true,
        "detail": "log",
        "documentation": {}
    },
    {
        "label": "sqlite3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlite3",
        "description": "sqlite3",
        "detail": "sqlite3",
        "documentation": {}
    },
    {
        "label": "get_id",
        "importPath": "log_utils",
        "description": "log_utils",
        "isExtraImport": true,
        "detail": "log_utils",
        "documentation": {}
    },
    {
        "label": "get_id",
        "importPath": "log_utils",
        "description": "log_utils",
        "isExtraImport": true,
        "detail": "log_utils",
        "documentation": {}
    },
    {
        "label": "get_id",
        "importPath": "log_utils",
        "description": "log_utils",
        "isExtraImport": true,
        "detail": "log_utils",
        "documentation": {}
    },
    {
        "label": "get_id",
        "importPath": "log_utils",
        "description": "log_utils",
        "isExtraImport": true,
        "detail": "log_utils",
        "documentation": {}
    },
    {
        "label": "TypeMismatchError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "MathError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "OperandDeduceError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "SymbolLookupError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "CallableResolutionError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "IrreversibleOperationError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "OutOfMemoryError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "SchemeError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "ParseError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "ParseError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "ParseError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "OperandDeduceError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "IrreversibleOperationError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "TurtleDrawingError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "OperandDeduceError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "MathError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "CallableResolutionError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "ParseError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "OperandDeduceError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "IrreversibleOperationError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "SchemeError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "ParseError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "TerminatedError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "OperandDeduceError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "TerminatedError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "TerminatedError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "OperandDeduceError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "IrreversibleOperationError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "LoadError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "SchemeError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "TypeMismatchError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "OperandDeduceError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "IrreversibleOperationError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "OperandDeduceError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "SchemeError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "TypeMismatchError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "MathError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "OperandDeduceError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "SymbolLookupError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "CallableResolutionError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "IrreversibleOperationError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "OutOfMemoryError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "SchemeError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "ParseError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "ParseError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "ParseError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "OperandDeduceError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "IrreversibleOperationError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "TurtleDrawingError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "OperandDeduceError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "MathError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "CallableResolutionError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "ParseError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "OperandDeduceError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "IrreversibleOperationError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "SchemeError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "ParseError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "TerminatedError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "OperandDeduceError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "TerminatedError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "TerminatedError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "OperandDeduceError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "IrreversibleOperationError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "LoadError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "SchemeError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "TypeMismatchError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "OperandDeduceError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "IrreversibleOperationError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "OperandDeduceError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "SchemeError",
        "importPath": "scheme_exceptions",
        "description": "scheme_exceptions",
        "isExtraImport": true,
        "detail": "scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "mistune",
        "importPath": "libraries",
        "description": "libraries",
        "isExtraImport": true,
        "detail": "libraries",
        "documentation": {}
    },
    {
        "label": "mistune",
        "importPath": "libraries",
        "description": "libraries",
        "isExtraImport": true,
        "detail": "libraries",
        "documentation": {}
    },
    {
        "label": "execution",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "execution",
        "description": "execution",
        "detail": "execution",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "Canvas",
        "importPath": "graphics",
        "description": "graphics",
        "isExtraImport": true,
        "detail": "graphics",
        "documentation": {}
    },
    {
        "label": "Canvas",
        "importPath": "graphics",
        "description": "graphics",
        "isExtraImport": true,
        "detail": "graphics",
        "documentation": {}
    },
    {
        "label": "get_expression",
        "importPath": "execution_parser",
        "description": "execution_parser",
        "isExtraImport": true,
        "detail": "execution_parser",
        "documentation": {}
    },
    {
        "label": "strip_comments",
        "importPath": "execution_parser",
        "description": "execution_parser",
        "isExtraImport": true,
        "detail": "execution_parser",
        "documentation": {}
    },
    {
        "label": "get_expression",
        "importPath": "execution_parser",
        "description": "execution_parser",
        "isExtraImport": true,
        "detail": "execution_parser",
        "documentation": {}
    },
    {
        "label": "get_expression",
        "importPath": "execution_parser",
        "description": "execution_parser",
        "isExtraImport": true,
        "detail": "execution_parser",
        "documentation": {}
    },
    {
        "label": "strip_comments",
        "importPath": "execution_parser",
        "description": "execution_parser",
        "isExtraImport": true,
        "detail": "execution_parser",
        "documentation": {}
    },
    {
        "label": "get_expression",
        "importPath": "execution_parser",
        "description": "execution_parser",
        "isExtraImport": true,
        "detail": "execution_parser",
        "documentation": {}
    },
    {
        "label": "lexer",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "lexer",
        "description": "lexer",
        "detail": "lexer",
        "documentation": {}
    },
    {
        "label": "TokenBuffer",
        "importPath": "lexer",
        "description": "lexer",
        "isExtraImport": true,
        "detail": "lexer",
        "documentation": {}
    },
    {
        "label": "TokenBuffer",
        "importPath": "lexer",
        "description": "lexer",
        "isExtraImport": true,
        "detail": "lexer",
        "documentation": {}
    },
    {
        "label": "SPECIALS",
        "importPath": "lexer",
        "description": "lexer",
        "isExtraImport": true,
        "detail": "lexer",
        "documentation": {}
    },
    {
        "label": "TokenBuffer",
        "importPath": "lexer",
        "description": "lexer",
        "isExtraImport": true,
        "detail": "lexer",
        "documentation": {}
    },
    {
        "label": "SPECIALS",
        "importPath": "lexer",
        "description": "lexer",
        "isExtraImport": true,
        "detail": "lexer",
        "documentation": {}
    },
    {
        "label": "Comment",
        "importPath": "lexer",
        "description": "lexer",
        "isExtraImport": true,
        "detail": "lexer",
        "documentation": {}
    },
    {
        "label": "TokenBuffer",
        "importPath": "lexer",
        "description": "lexer",
        "isExtraImport": true,
        "detail": "lexer",
        "documentation": {}
    },
    {
        "label": "TokenBuffer",
        "importPath": "lexer",
        "description": "lexer",
        "isExtraImport": true,
        "detail": "lexer",
        "documentation": {}
    },
    {
        "label": "TokenBuffer",
        "importPath": "lexer",
        "description": "lexer",
        "isExtraImport": true,
        "detail": "lexer",
        "documentation": {}
    },
    {
        "label": "SPECIALS",
        "importPath": "lexer",
        "description": "lexer",
        "isExtraImport": true,
        "detail": "lexer",
        "documentation": {}
    },
    {
        "label": "TokenBuffer",
        "importPath": "lexer",
        "description": "lexer",
        "isExtraImport": true,
        "detail": "lexer",
        "documentation": {}
    },
    {
        "label": "SPECIALS",
        "importPath": "lexer",
        "description": "lexer",
        "isExtraImport": true,
        "detail": "lexer",
        "documentation": {}
    },
    {
        "label": "Comment",
        "importPath": "lexer",
        "description": "lexer",
        "isExtraImport": true,
        "detail": "lexer",
        "documentation": {}
    },
    {
        "label": "TokenBuffer",
        "importPath": "lexer",
        "description": "lexer",
        "isExtraImport": true,
        "detail": "lexer",
        "documentation": {}
    },
    {
        "label": "TimeLimitException",
        "importPath": "runtime_limiter",
        "description": "runtime_limiter",
        "isExtraImport": true,
        "detail": "runtime_limiter",
        "documentation": {}
    },
    {
        "label": "TimeLimitException",
        "importPath": "runtime_limiter",
        "description": "runtime_limiter",
        "isExtraImport": true,
        "detail": "runtime_limiter",
        "documentation": {}
    },
    {
        "label": "OperationCanceledException",
        "importPath": "runtime_limiter",
        "description": "runtime_limiter",
        "isExtraImport": true,
        "detail": "runtime_limiter",
        "documentation": {}
    },
    {
        "label": "scheme_limiter",
        "importPath": "runtime_limiter",
        "description": "runtime_limiter",
        "isExtraImport": true,
        "detail": "runtime_limiter",
        "documentation": {}
    },
    {
        "label": "scheme_limiter",
        "importPath": "runtime_limiter",
        "description": "runtime_limiter",
        "isExtraImport": true,
        "detail": "runtime_limiter",
        "documentation": {}
    },
    {
        "label": "TimeLimitException",
        "importPath": "runtime_limiter",
        "description": "runtime_limiter",
        "isExtraImport": true,
        "detail": "runtime_limiter",
        "documentation": {}
    },
    {
        "label": "TimeLimitException",
        "importPath": "runtime_limiter",
        "description": "runtime_limiter",
        "isExtraImport": true,
        "detail": "runtime_limiter",
        "documentation": {}
    },
    {
        "label": "TimeLimitException",
        "importPath": "runtime_limiter",
        "description": "runtime_limiter",
        "isExtraImport": true,
        "detail": "runtime_limiter",
        "documentation": {}
    },
    {
        "label": "OperationCanceledException",
        "importPath": "runtime_limiter",
        "description": "runtime_limiter",
        "isExtraImport": true,
        "detail": "runtime_limiter",
        "documentation": {}
    },
    {
        "label": "scheme_limiter",
        "importPath": "runtime_limiter",
        "description": "runtime_limiter",
        "isExtraImport": true,
        "detail": "runtime_limiter",
        "documentation": {}
    },
    {
        "label": "scheme_limiter",
        "importPath": "runtime_limiter",
        "description": "runtime_limiter",
        "isExtraImport": true,
        "detail": "runtime_limiter",
        "documentation": {}
    },
    {
        "label": "TimeLimitException",
        "importPath": "runtime_limiter",
        "description": "runtime_limiter",
        "isExtraImport": true,
        "detail": "runtime_limiter",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABCMeta",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABCMeta",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "functools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "functools",
        "description": "functools",
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "FormatAtom",
        "importPath": "format_parser",
        "description": "format_parser",
        "isExtraImport": true,
        "detail": "format_parser",
        "documentation": {}
    },
    {
        "label": "FormatComment",
        "importPath": "format_parser",
        "description": "format_parser",
        "isExtraImport": true,
        "detail": "format_parser",
        "documentation": {}
    },
    {
        "label": "FormatList",
        "importPath": "format_parser",
        "description": "format_parser",
        "isExtraImport": true,
        "detail": "format_parser",
        "documentation": {}
    },
    {
        "label": "Formatted",
        "importPath": "format_parser",
        "description": "format_parser",
        "isExtraImport": true,
        "detail": "format_parser",
        "documentation": {}
    },
    {
        "label": "get_expression",
        "importPath": "format_parser",
        "description": "format_parser",
        "isExtraImport": true,
        "detail": "format_parser",
        "documentation": {}
    },
    {
        "label": "FormatAtom",
        "importPath": "format_parser",
        "description": "format_parser",
        "isExtraImport": true,
        "detail": "format_parser",
        "documentation": {}
    },
    {
        "label": "FormatComment",
        "importPath": "format_parser",
        "description": "format_parser",
        "isExtraImport": true,
        "detail": "format_parser",
        "documentation": {}
    },
    {
        "label": "FormatList",
        "importPath": "format_parser",
        "description": "format_parser",
        "isExtraImport": true,
        "detail": "format_parser",
        "documentation": {}
    },
    {
        "label": "Formatted",
        "importPath": "format_parser",
        "description": "format_parser",
        "isExtraImport": true,
        "detail": "format_parser",
        "documentation": {}
    },
    {
        "label": "get_expression",
        "importPath": "format_parser",
        "description": "format_parser",
        "isExtraImport": true,
        "detail": "format_parser",
        "documentation": {}
    },
    {
        "label": "COLORS",
        "importPath": "css_colors",
        "description": "css_colors",
        "isExtraImport": true,
        "detail": "css_colors",
        "documentation": {}
    },
    {
        "label": "COLORS",
        "importPath": "css_colors",
        "description": "css_colors",
        "isExtraImport": true,
        "detail": "css_colors",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "timeout",
        "importPath": "_socket",
        "description": "_socket",
        "isExtraImport": true,
        "detail": "_socket",
        "documentation": {}
    },
    {
        "label": "timeout",
        "importPath": "_socket",
        "description": "_socket",
        "isExtraImport": true,
        "detail": "_socket",
        "documentation": {}
    },
    {
        "label": "server",
        "importPath": "http",
        "description": "http",
        "isExtraImport": true,
        "detail": "http",
        "documentation": {}
    },
    {
        "label": "HTTPStatus",
        "importPath": "http",
        "description": "http",
        "isExtraImport": true,
        "detail": "http",
        "documentation": {}
    },
    {
        "label": "server",
        "importPath": "http",
        "description": "http",
        "isExtraImport": true,
        "detail": "http",
        "documentation": {}
    },
    {
        "label": "HTTPStatus",
        "importPath": "http",
        "description": "http",
        "isExtraImport": true,
        "detail": "http",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "socketserver",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "socketserver",
        "description": "socketserver",
        "detail": "socketserver",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "urllib.parse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "webbrowser",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "webbrowser",
        "description": "webbrowser",
        "detail": "webbrowser",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Thread",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "URLError",
        "importPath": "urllib.error",
        "description": "urllib.error",
        "isExtraImport": true,
        "detail": "urllib.error",
        "documentation": {}
    },
    {
        "label": "URLError",
        "importPath": "urllib.error",
        "description": "urllib.error",
        "isExtraImport": true,
        "detail": "urllib.error",
        "documentation": {}
    },
    {
        "label": "Request",
        "importPath": "urllib.request",
        "description": "urllib.request",
        "isExtraImport": true,
        "detail": "urllib.request",
        "documentation": {}
    },
    {
        "label": "urlopen",
        "importPath": "urllib.request",
        "description": "urllib.request",
        "isExtraImport": true,
        "detail": "urllib.request",
        "documentation": {}
    },
    {
        "label": "Request",
        "importPath": "urllib.request",
        "description": "urllib.request",
        "isExtraImport": true,
        "detail": "urllib.request",
        "documentation": {}
    },
    {
        "label": "urlopen",
        "importPath": "urllib.request",
        "description": "urllib.request",
        "isExtraImport": true,
        "detail": "urllib.request",
        "documentation": {}
    },
    {
        "label": "ok_interface",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ok_interface",
        "description": "ok_interface",
        "detail": "ok_interface",
        "documentation": {}
    },
    {
        "label": "search",
        "importPath": "documentation",
        "description": "documentation",
        "isExtraImport": true,
        "detail": "documentation",
        "documentation": {}
    },
    {
        "label": "search",
        "importPath": "documentation",
        "description": "documentation",
        "isExtraImport": true,
        "detail": "documentation",
        "documentation": {}
    },
    {
        "label": "get_scm_files",
        "importPath": "file_manager",
        "description": "file_manager",
        "isExtraImport": true,
        "detail": "file_manager",
        "documentation": {}
    },
    {
        "label": "save",
        "importPath": "file_manager",
        "description": "file_manager",
        "isExtraImport": true,
        "detail": "file_manager",
        "documentation": {}
    },
    {
        "label": "read_file",
        "importPath": "file_manager",
        "description": "file_manager",
        "isExtraImport": true,
        "detail": "file_manager",
        "documentation": {}
    },
    {
        "label": "new_file",
        "importPath": "file_manager",
        "description": "file_manager",
        "isExtraImport": true,
        "detail": "file_manager",
        "documentation": {}
    },
    {
        "label": "get_scm_files",
        "importPath": "file_manager",
        "description": "file_manager",
        "isExtraImport": true,
        "detail": "file_manager",
        "documentation": {}
    },
    {
        "label": "save",
        "importPath": "file_manager",
        "description": "file_manager",
        "isExtraImport": true,
        "detail": "file_manager",
        "documentation": {}
    },
    {
        "label": "read_file",
        "importPath": "file_manager",
        "description": "file_manager",
        "isExtraImport": true,
        "detail": "file_manager",
        "documentation": {}
    },
    {
        "label": "new_file",
        "importPath": "file_manager",
        "description": "file_manager",
        "isExtraImport": true,
        "detail": "file_manager",
        "documentation": {}
    },
    {
        "label": "formatter",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "formatter",
        "description": "formatter",
        "detail": "formatter",
        "documentation": {}
    },
    {
        "label": "prettify",
        "importPath": "formatter",
        "description": "formatter",
        "isExtraImport": true,
        "detail": "formatter",
        "documentation": {}
    },
    {
        "label": "prettify",
        "importPath": "formatter",
        "description": "formatter",
        "isExtraImport": true,
        "detail": "formatter",
        "documentation": {}
    },
    {
        "label": "save_config",
        "importPath": "persistence",
        "description": "persistence",
        "isExtraImport": true,
        "detail": "persistence",
        "documentation": {}
    },
    {
        "label": "load_config",
        "importPath": "persistence",
        "description": "persistence",
        "isExtraImport": true,
        "detail": "persistence",
        "documentation": {}
    },
    {
        "label": "save_config",
        "importPath": "persistence",
        "description": "persistence",
        "isExtraImport": true,
        "detail": "persistence",
        "documentation": {}
    },
    {
        "label": "load_config",
        "importPath": "persistence",
        "description": "persistence",
        "isExtraImport": true,
        "detail": "persistence",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "redirect_stdout",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "IsEqual",
        "importPath": "arithmetic",
        "description": "arithmetic",
        "isExtraImport": true,
        "detail": "arithmetic",
        "documentation": {}
    },
    {
        "label": "IsEqual",
        "importPath": "arithmetic",
        "description": "arithmetic",
        "isExtraImport": true,
        "detail": "arithmetic",
        "documentation": {}
    },
    {
        "label": "LambdaObject",
        "importPath": "special_forms",
        "description": "special_forms",
        "isExtraImport": true,
        "detail": "special_forms",
        "documentation": {}
    },
    {
        "label": "MuObject",
        "importPath": "special_forms",
        "description": "special_forms",
        "isExtraImport": true,
        "detail": "special_forms",
        "documentation": {}
    },
    {
        "label": "MacroObject",
        "importPath": "special_forms",
        "description": "special_forms",
        "isExtraImport": true,
        "detail": "special_forms",
        "documentation": {}
    },
    {
        "label": "LambdaObject",
        "importPath": "special_forms",
        "description": "special_forms",
        "isExtraImport": true,
        "detail": "special_forms",
        "documentation": {}
    },
    {
        "label": "MuObject",
        "importPath": "special_forms",
        "description": "special_forms",
        "isExtraImport": true,
        "detail": "special_forms",
        "documentation": {}
    },
    {
        "label": "MacroObject",
        "importPath": "special_forms",
        "description": "special_forms",
        "isExtraImport": true,
        "detail": "special_forms",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "database",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "database",
        "description": "database",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "base64",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "base64",
        "description": "base64",
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "codecs",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "codecs",
        "description": "codecs",
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "Queue",
        "importPath": "queue",
        "description": "queue",
        "isExtraImport": true,
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "cats",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cats",
        "description": "cats",
        "detail": "cats",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "route",
        "importPath": "gui_files.common_server",
        "description": "gui_files.common_server",
        "isExtraImport": true,
        "detail": "gui_files.common_server",
        "documentation": {}
    },
    {
        "label": "forward_to_server",
        "importPath": "gui_files.common_server",
        "description": "gui_files.common_server",
        "isExtraImport": true,
        "detail": "gui_files.common_server",
        "documentation": {}
    },
    {
        "label": "server_only",
        "importPath": "gui_files.common_server",
        "description": "gui_files.common_server",
        "isExtraImport": true,
        "detail": "gui_files.common_server",
        "documentation": {}
    },
    {
        "label": "Server",
        "importPath": "gui_files.common_server",
        "description": "gui_files.common_server",
        "isExtraImport": true,
        "detail": "gui_files.common_server",
        "documentation": {}
    },
    {
        "label": "route",
        "importPath": "gui_files.common_server",
        "description": "gui_files.common_server",
        "isExtraImport": true,
        "detail": "gui_files.common_server",
        "documentation": {}
    },
    {
        "label": "sendto",
        "importPath": "gui_files.common_server",
        "description": "gui_files.common_server",
        "isExtraImport": true,
        "detail": "gui_files.common_server",
        "documentation": {}
    },
    {
        "label": "start",
        "importPath": "gui_files.common_server",
        "description": "gui_files.common_server",
        "isExtraImport": true,
        "detail": "gui_files.common_server",
        "documentation": {}
    },
    {
        "label": "route",
        "importPath": "gui_files.common_server",
        "description": "gui_files.common_server",
        "isExtraImport": true,
        "detail": "gui_files.common_server",
        "documentation": {}
    },
    {
        "label": "start",
        "importPath": "gui_files.common_server",
        "description": "gui_files.common_server",
        "isExtraImport": true,
        "detail": "gui_files.common_server",
        "documentation": {}
    },
    {
        "label": "lower",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "split",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "remove_punctuation",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "lines_from_file",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "main",
        "importPath": "ucb",
        "description": "ucb",
        "isExtraImport": true,
        "detail": "ucb",
        "documentation": {}
    },
    {
        "label": "interact",
        "importPath": "ucb",
        "description": "ucb",
        "isExtraImport": true,
        "detail": "ucb",
        "documentation": {}
    },
    {
        "label": "trace",
        "importPath": "ucb",
        "description": "ucb",
        "isExtraImport": true,
        "detail": "ucb",
        "documentation": {}
    },
    {
        "label": "main",
        "importPath": "ucb",
        "description": "ucb",
        "isExtraImport": true,
        "detail": "ucb",
        "documentation": {}
    },
    {
        "label": "trace",
        "importPath": "ucb",
        "description": "ucb",
        "isExtraImport": true,
        "detail": "ucb",
        "documentation": {}
    },
    {
        "label": "interact",
        "importPath": "ucb",
        "description": "ucb",
        "isExtraImport": true,
        "detail": "ucb",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "string",
        "description": "string",
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "multiplayer",
        "importPath": "multiplayer",
        "description": "multiplayer",
        "isExtraImport": true,
        "detail": "multiplayer",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pickle",
        "description": "pickle",
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "code",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "code",
        "description": "code",
        "detail": "code",
        "documentation": {}
    },
    {
        "label": "signal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "signal",
        "description": "signal",
        "detail": "signal",
        "documentation": {}
    },
    {
        "label": "hog",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hog",
        "description": "hog",
        "detail": "hog",
        "documentation": {}
    },
    {
        "label": "GOAL_SCORE",
        "importPath": "hog",
        "description": "hog",
        "isExtraImport": true,
        "detail": "hog",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hog",
        "description": "hog",
        "isExtraImport": true,
        "detail": "hog",
        "documentation": {}
    },
    {
        "label": "dice",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "dice",
        "description": "dice",
        "detail": "dice",
        "documentation": {}
    },
    {
        "label": "six_sided",
        "importPath": "dice",
        "description": "dice",
        "isExtraImport": true,
        "detail": "dice",
        "documentation": {}
    },
    {
        "label": "make_test_dice",
        "importPath": "dice",
        "description": "dice",
        "isExtraImport": true,
        "detail": "dice",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "default_graphics",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "default_graphics",
        "description": "default_graphics",
        "detail": "default_graphics",
        "documentation": {}
    },
    {
        "label": "Dog",
        "importPath": "classinheritance",
        "description": "classinheritance",
        "isExtraImport": true,
        "detail": "classinheritance",
        "documentation": {}
    },
    {
        "label": "ExclusionChecker",
        "kind": 6,
        "importPath": "homework.hw01.construct_check",
        "description": "homework.hw01.construct_check",
        "peekOfCode": "class ExclusionChecker(NodeVisitor):\n    \"\"\"An AST visitor that checks that certain constructs are excluded from\n    parts of a program.  ExclusionChecker(EXC) checks that AST node types\n    whose names are in the sequence or set EXC are not present.  Its check\n    method visits nodes in a given function of a source file checking that the\n    indicated node types are not used.\"\"\"\n    def __init__(self, disallow=()):\n        \"\"\"DISALLOW is the initial default list of disallowed\n        node-type names.\"\"\"\n        self._disallow = set(disallow)",
        "detail": "homework.hw01.construct_check",
        "documentation": {}
    },
    {
        "label": "check",
        "kind": 2,
        "importPath": "homework.hw01.construct_check",
        "description": "homework.hw01.construct_check",
        "peekOfCode": "def check(source_file, checked_funcs, disallow, source=None):\n    \"\"\"Checks that AST nodes whose type names are present in DISALLOW\n    (an object supporting 'in') are not present in the function(s) named\n    CHECKED_FUNCS in SOURCE.  By default, SOURCE is the contents of the\n    file SOURCE_FILE.  CHECKED_FUNCS is either a string (indicating a single\n    name) or an object of some other type that supports 'in'. CHECKED_FUNCS\n    may contain __main__ to indicate an entire  module. Prints reports of\n    each prohibited node and returns True iff none are found.\n    See ast.__dir__() for AST type names.  The special node name 'Recursion'\n    checks for overtly recursive calls (i.e., calls of the form NAME(...) where",
        "detail": "homework.hw01.construct_check",
        "documentation": {}
    },
    {
        "label": "_NAMES",
        "kind": 5,
        "importPath": "homework.hw01.construct_check",
        "description": "homework.hw01.construct_check",
        "peekOfCode": "_NAMES = {\n    'Add': '+',\n    'And': 'and',\n    'Assert': 'assert',\n    'Assign': '=',\n    'AnnAssign': '=',\n    'AugAssign': 'op=',\n    'BitAnd': '&',\n    'BitOr': '|',\n    'BitXor': '^',",
        "detail": "homework.hw01.construct_check",
        "documentation": {}
    },
    {
        "label": "a_plus_abs_b",
        "kind": 2,
        "importPath": "homework.hw01.hw01",
        "description": "homework.hw01.hw01",
        "peekOfCode": "def a_plus_abs_b(a, b):\n    \"\"\"Return a+abs(b), but without calling abs.\n    >>> a_plus_abs_b(2, 3)\n    5\n    >>> a_plus_abs_b(2, -3)\n    5\n    >>> a_plus_abs_b(-1, 4)\n    3\n    >>> a_plus_abs_b(-1, -4)\n    3",
        "detail": "homework.hw01.hw01",
        "documentation": {}
    },
    {
        "label": "a_plus_abs_b_syntax_check",
        "kind": 2,
        "importPath": "homework.hw01.hw01",
        "description": "homework.hw01.hw01",
        "peekOfCode": "def a_plus_abs_b_syntax_check():\n    \"\"\"Check that you didn't change the return statement of a_plus_abs_b.\n    >>> # You aren't expected to understand the code of this test.\n    >>> import inspect, re\n    >>> re.findall(r'^\\s*(return .*)', inspect.getsource(a_plus_abs_b), re.M)\n    ['return f(a, b)']\n    \"\"\"\n    # You don't need to edit this function. It's just here to check your work.\ndef two_of_three(i, j, k):\n    \"\"\"Return m*m + n*n, where m and n are the two smallest members of the",
        "detail": "homework.hw01.hw01",
        "documentation": {}
    },
    {
        "label": "two_of_three",
        "kind": 2,
        "importPath": "homework.hw01.hw01",
        "description": "homework.hw01.hw01",
        "peekOfCode": "def two_of_three(i, j, k):\n    \"\"\"Return m*m + n*n, where m and n are the two smallest members of the\n    positive numbers i, j, and k.\n    >>> two_of_three(1, 2, 3)\n    5\n    >>> two_of_three(5, 3, 1)\n    10\n    >>> two_of_three(10, 2, 8)\n    68\n    >>> two_of_three(5, 5, 5)",
        "detail": "homework.hw01.hw01",
        "documentation": {}
    },
    {
        "label": "two_of_three_syntax_check",
        "kind": 2,
        "importPath": "homework.hw01.hw01",
        "description": "homework.hw01.hw01",
        "peekOfCode": "def two_of_three_syntax_check():\n    \"\"\"Check that your two_of_three code consists of nothing but a return statement.\n    >>> # You aren't expected to understand the code of this test.\n    >>> import inspect, ast\n    >>> [type(x).__name__ for x in ast.parse(inspect.getsource(two_of_three)).body[0].body]\n    ['Expr', 'Return']\n    \"\"\"\n    # You don't need to edit this function. It's just here to check your work.\ndef largest_factor(n):\n    \"\"\"Return the largest factor of n that is smaller than n.",
        "detail": "homework.hw01.hw01",
        "documentation": {}
    },
    {
        "label": "largest_factor",
        "kind": 2,
        "importPath": "homework.hw01.hw01",
        "description": "homework.hw01.hw01",
        "peekOfCode": "def largest_factor(n):\n    \"\"\"Return the largest factor of n that is smaller than n.\n    >>> largest_factor(15) # factors are 1, 3, 5\n    5\n    >>> largest_factor(80) # factors are 1, 2, 4, 5, 8, 10, 16, 20, 40\n    40\n    >>> largest_factor(13) # factor is 1 since 13 is prime\n    1\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"",
        "detail": "homework.hw01.hw01",
        "documentation": {}
    },
    {
        "label": "hailstone",
        "kind": 2,
        "importPath": "homework.hw01.hw01",
        "description": "homework.hw01.hw01",
        "peekOfCode": "def hailstone(n):\n    \"\"\"Print the hailstone sequence starting at n and return its\n    length.\n    >>> a = hailstone(10)\n    10\n    5\n    16\n    8\n    4\n    2",
        "detail": "homework.hw01.hw01",
        "documentation": {}
    },
    {
        "label": "ExclusionChecker",
        "kind": 6,
        "importPath": "homework.hw02.construct_check",
        "description": "homework.hw02.construct_check",
        "peekOfCode": "class ExclusionChecker(NodeVisitor):\n    \"\"\"An AST visitor that checks that certain constructs are excluded from\n    parts of a program.  ExclusionChecker(EXC) checks that AST node types\n    whose names are in the sequence or set EXC are not present.  Its check\n    method visits nodes in a given function of a source file checking that the\n    indicated node types are not used.\"\"\"\n    def __init__(self, disallow=()):\n        \"\"\"DISALLOW is the initial default list of disallowed\n        node-type names.\"\"\"\n        self._disallow = set(disallow)",
        "detail": "homework.hw02.construct_check",
        "documentation": {}
    },
    {
        "label": "check",
        "kind": 2,
        "importPath": "homework.hw02.construct_check",
        "description": "homework.hw02.construct_check",
        "peekOfCode": "def check(source_file, checked_funcs, disallow, source=None):\n    \"\"\"Checks that AST nodes whose type names are present in DISALLOW\n    (an object supporting 'in') are not present in the function(s) named\n    CHECKED_FUNCS in SOURCE.  By default, SOURCE is the contents of the\n    file SOURCE_FILE.  CHECKED_FUNCS is either a string (indicating a single\n    name) or an object of some other type that supports 'in'. CHECKED_FUNCS\n    may contain __main__ to indicate an entire  module. Prints reports of\n    each prohibited node and returns True iff none are found.\n    See ast.__dir__() for AST type names.  The special node name 'Recursion'\n    checks for overtly recursive calls (i.e., calls of the form NAME(...) where",
        "detail": "homework.hw02.construct_check",
        "documentation": {}
    },
    {
        "label": "_NAMES",
        "kind": 5,
        "importPath": "homework.hw02.construct_check",
        "description": "homework.hw02.construct_check",
        "peekOfCode": "_NAMES = {\n    'Add': '+',\n    'And': 'and',\n    'Assert': 'assert',\n    'Assign': '=',\n    'AnnAssign': '=',\n    'AugAssign': 'op=',\n    'BitAnd': '&',\n    'BitOr': '|',\n    'BitXor': '^',",
        "detail": "homework.hw02.construct_check",
        "documentation": {}
    },
    {
        "label": "product",
        "kind": 2,
        "importPath": "homework.hw02.hw02",
        "description": "homework.hw02.hw02",
        "peekOfCode": "def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n    n: a positive integer\n    term:  a function that takes one argument to produce the term\n    >>> product(3, identity)  # 1 * 2 * 3\n    6\n    >>> product(5, identity)  # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)    # 1^2 * 2^2 * 3^2\n    36",
        "detail": "homework.hw02.hw02",
        "documentation": {}
    },
    {
        "label": "accumulate",
        "kind": 2,
        "importPath": "homework.hw02.hw02",
        "description": "homework.hw02.hw02",
        "peekOfCode": "def accumulate(fuse, start, n, term):\n    \"\"\"Return the result of fusing together the first n terms in a sequence \n    and start.  The terms to be fused are term(1), term(2), ..., term(n). \n    The function fuse is a two-argument commutative & associative function.\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11 (fuse is never used)\n    11",
        "detail": "homework.hw02.hw02",
        "documentation": {}
    },
    {
        "label": "summation_using_accumulate",
        "kind": 2,
        "importPath": "homework.hw02.hw02",
        "description": "homework.hw02.hw02",
        "peekOfCode": "def summation_using_accumulate(n, term):\n    \"\"\"Returns the sum: term(1) + ... + term(n), using accumulate.\n    >>> summation_using_accumulate(5, square)\n    55\n    >>> summation_using_accumulate(5, triple)\n    45\n    >>> # This test checks that the body of the function is just a return statement.\n    >>> import inspect, ast\n    >>> [type(x).__name__ for x in ast.parse(inspect.getsource(summation_using_accumulate)).body[0].body]\n    ['Expr', 'Return']",
        "detail": "homework.hw02.hw02",
        "documentation": {}
    },
    {
        "label": "product_using_accumulate",
        "kind": 2,
        "importPath": "homework.hw02.hw02",
        "description": "homework.hw02.hw02",
        "peekOfCode": "def product_using_accumulate(n, term):\n    \"\"\"Returns the product: term(1) * ... * term(n), using accumulate.\n    >>> product_using_accumulate(4, square)\n    576\n    >>> product_using_accumulate(6, triple)\n    524880\n    >>> # This test checks that the body of the function is just a return statement.\n    >>> import inspect, ast\n    >>> [type(x).__name__ for x in ast.parse(inspect.getsource(product_using_accumulate)).body[0].body]\n    ['Expr', 'Return']",
        "detail": "homework.hw02.hw02",
        "documentation": {}
    },
    {
        "label": "make_repeater",
        "kind": 2,
        "importPath": "homework.hw02.hw02",
        "description": "homework.hw02.hw02",
        "peekOfCode": "def make_repeater(f, n):\n    \"\"\"Returns the function that computes the nth application of f.\n    >>> add_three = make_repeater(increment, 3)\n    >>> add_three(5)\n    8\n    >>> make_repeater(triple, 5)(1) # 3 * 3 * 3 * 3 * 3 * 1\n    243\n    >>> make_repeater(square, 2)(5) # square(square(5))\n    625\n    >>> make_repeater(square, 3)(5) # square(square(square(5)))",
        "detail": "homework.hw02.hw02",
        "documentation": {}
    },
    {
        "label": "square",
        "kind": 5,
        "importPath": "homework.hw02.hw02",
        "description": "homework.hw02.hw02",
        "peekOfCode": "square = lambda x: x * x\nidentity = lambda x: x\ntriple = lambda x: 3 * x\nincrement = lambda x: x + 1\nHW_SOURCE_FILE=__file__\ndef product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n    n: a positive integer\n    term:  a function that takes one argument to produce the term\n    >>> product(3, identity)  # 1 * 2 * 3",
        "detail": "homework.hw02.hw02",
        "documentation": {}
    },
    {
        "label": "identity",
        "kind": 5,
        "importPath": "homework.hw02.hw02",
        "description": "homework.hw02.hw02",
        "peekOfCode": "identity = lambda x: x\ntriple = lambda x: 3 * x\nincrement = lambda x: x + 1\nHW_SOURCE_FILE=__file__\ndef product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n    n: a positive integer\n    term:  a function that takes one argument to produce the term\n    >>> product(3, identity)  # 1 * 2 * 3\n    6",
        "detail": "homework.hw02.hw02",
        "documentation": {}
    },
    {
        "label": "triple",
        "kind": 5,
        "importPath": "homework.hw02.hw02",
        "description": "homework.hw02.hw02",
        "peekOfCode": "triple = lambda x: 3 * x\nincrement = lambda x: x + 1\nHW_SOURCE_FILE=__file__\ndef product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n    n: a positive integer\n    term:  a function that takes one argument to produce the term\n    >>> product(3, identity)  # 1 * 2 * 3\n    6\n    >>> product(5, identity)  # 1 * 2 * 3 * 4 * 5",
        "detail": "homework.hw02.hw02",
        "documentation": {}
    },
    {
        "label": "increment",
        "kind": 5,
        "importPath": "homework.hw02.hw02",
        "description": "homework.hw02.hw02",
        "peekOfCode": "increment = lambda x: x + 1\nHW_SOURCE_FILE=__file__\ndef product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n    n: a positive integer\n    term:  a function that takes one argument to produce the term\n    >>> product(3, identity)  # 1 * 2 * 3\n    6\n    >>> product(5, identity)  # 1 * 2 * 3 * 4 * 5\n    120",
        "detail": "homework.hw02.hw02",
        "documentation": {}
    },
    {
        "label": "ExclusionChecker",
        "kind": 6,
        "importPath": "homework.hw03.construct_check",
        "description": "homework.hw03.construct_check",
        "peekOfCode": "class ExclusionChecker(NodeVisitor):\n    \"\"\"An AST visitor that checks that certain constructs are excluded from\n    parts of a program.  ExclusionChecker(EXC) checks that AST node types\n    whose names are in the sequence or set EXC are not present.  Its check\n    method visits nodes in a given function of a source file checking that the\n    indicated node types are not used.\"\"\"\n    def __init__(self, disallow=()):\n        \"\"\"DISALLOW is the initial default list of disallowed\n        node-type names.\"\"\"\n        self._disallow = set(disallow)",
        "detail": "homework.hw03.construct_check",
        "documentation": {}
    },
    {
        "label": "check",
        "kind": 2,
        "importPath": "homework.hw03.construct_check",
        "description": "homework.hw03.construct_check",
        "peekOfCode": "def check(source_file, checked_funcs, disallow, source=None):\n    \"\"\"Checks that AST nodes whose type names are present in DISALLOW\n    (an object supporting 'in') are not present in the function(s) named\n    CHECKED_FUNCS in SOURCE.  By default, SOURCE is the contents of the\n    file SOURCE_FILE.  CHECKED_FUNCS is either a string (indicating a single\n    name) or an object of some other type that supports 'in'. CHECKED_FUNCS\n    may contain __main__ to indicate an entire  module. Prints reports of\n    each prohibited node and returns True iff none are found.\n    See ast.__dir__() for AST type names.  The special node name 'Recursion'\n    checks for overtly recursive calls (i.e., calls of the form NAME(...) where",
        "detail": "homework.hw03.construct_check",
        "documentation": {}
    },
    {
        "label": "_NAMES",
        "kind": 5,
        "importPath": "homework.hw03.construct_check",
        "description": "homework.hw03.construct_check",
        "peekOfCode": "_NAMES = {\n    'Add': '+',\n    'And': 'and',\n    'Assert': 'assert',\n    'Assign': '=',\n    'AnnAssign': '=',\n    'AugAssign': 'op=',\n    'BitAnd': '&',\n    'BitOr': '|',\n    'BitXor': '^',",
        "detail": "homework.hw03.construct_check",
        "documentation": {}
    },
    {
        "label": "num_eights",
        "kind": 2,
        "importPath": "homework.hw03.hw03",
        "description": "homework.hw03.hw03",
        "peekOfCode": "def num_eights(n):\n    \"\"\"Returns the number of times 8 appears as a digit of n.\n    >>> num_eights(3)\n    0\n    >>> num_eights(8)\n    1\n    >>> num_eights(88888888)\n    8\n    >>> num_eights(2638)\n    1",
        "detail": "homework.hw03.hw03",
        "documentation": {}
    },
    {
        "label": "digit_distance",
        "kind": 2,
        "importPath": "homework.hw03.hw03",
        "description": "homework.hw03.hw03",
        "peekOfCode": "def digit_distance(n):\n    \"\"\"Determines the digit distance of n.\n    >>> digit_distance(3)\n    0\n    >>> digit_distance(777)\n    0\n    >>> digit_distance(314)\n    5\n    >>> digit_distance(31415926535)\n    32",
        "detail": "homework.hw03.hw03",
        "documentation": {}
    },
    {
        "label": "interleaved_sum",
        "kind": 2,
        "importPath": "homework.hw03.hw03",
        "description": "homework.hw03.hw03",
        "peekOfCode": "def interleaved_sum(n, odd_func, even_func):\n    \"\"\"Compute the sum odd_func(1) + even_func(2) + odd_func(3) + ..., up\n    to n.\n    >>> identity = lambda x: x\n    >>> square = lambda x: x * x\n    >>> triple = lambda x: x * 3\n    >>> interleaved_sum(5, identity, square) # 1   + 2*2 + 3   + 4*4 + 5\n    29\n    >>> interleaved_sum(5, square, identity) # 1*1 + 2   + 3*3 + 4   + 5*5\n    41",
        "detail": "homework.hw03.hw03",
        "documentation": {}
    },
    {
        "label": "next_larger_coin",
        "kind": 2,
        "importPath": "homework.hw03.hw03",
        "description": "homework.hw03.hw03",
        "peekOfCode": "def next_larger_coin(coin):\n    \"\"\"Returns the next larger coin in order.\n    >>> next_larger_coin(1)\n    5\n    >>> next_larger_coin(5)\n    10\n    >>> next_larger_coin(10)\n    25\n    >>> next_larger_coin(2) # Other values return None\n    \"\"\"",
        "detail": "homework.hw03.hw03",
        "documentation": {}
    },
    {
        "label": "next_smaller_coin",
        "kind": 2,
        "importPath": "homework.hw03.hw03",
        "description": "homework.hw03.hw03",
        "peekOfCode": "def next_smaller_coin(coin):\n    \"\"\"Returns the next smaller coin in order.\n    >>> next_smaller_coin(25)\n    10\n    >>> next_smaller_coin(10)\n    5\n    >>> next_smaller_coin(5)\n    1\n    >>> next_smaller_coin(2) # Other values return None\n    \"\"\"",
        "detail": "homework.hw03.hw03",
        "documentation": {}
    },
    {
        "label": "count_coins",
        "kind": 2,
        "importPath": "homework.hw03.hw03",
        "description": "homework.hw03.hw03",
        "peekOfCode": "def count_coins(total):\n    \"\"\"Return the number of ways to make change using coins of value of 1, 5, 10, 25.\n    >>> count_coins(15)\n    6\n    >>> count_coins(10)\n    4\n    >>> count_coins(20)\n    9\n    >>> count_coins(100) # How many ways to make change for a dollar?\n    242",
        "detail": "homework.hw03.hw03",
        "documentation": {}
    },
    {
        "label": "print_move",
        "kind": 2,
        "importPath": "homework.hw03.hw03",
        "description": "homework.hw03.hw03",
        "peekOfCode": "def print_move(origin, destination):\n    \"\"\"Print instructions to move a disk.\"\"\"\n    print(\"Move the top disk from rod\", origin, \"to rod\", destination)\ndef find_auxiliary(source, target, all_pole_names):\n    all_pole = set(all_pole_names)\n    auxiliary = list(all_pole - {source,target})\n    return auxiliary[0]\ndef move_stack(n, start, end):\n    \"\"\"Print the moves required to move n disks on the start pole to the end\n    pole without violating the rules of Towers of Hanoi.",
        "detail": "homework.hw03.hw03",
        "documentation": {}
    },
    {
        "label": "find_auxiliary",
        "kind": 2,
        "importPath": "homework.hw03.hw03",
        "description": "homework.hw03.hw03",
        "peekOfCode": "def find_auxiliary(source, target, all_pole_names):\n    all_pole = set(all_pole_names)\n    auxiliary = list(all_pole - {source,target})\n    return auxiliary[0]\ndef move_stack(n, start, end):\n    \"\"\"Print the moves required to move n disks on the start pole to the end\n    pole without violating the rules of Towers of Hanoi.\n    n -- number of disks\n    start -- a pole position, either 1, 2, or 3\n    end -- a pole position, either 1, 2, or 3",
        "detail": "homework.hw03.hw03",
        "documentation": {}
    },
    {
        "label": "move_stack",
        "kind": 2,
        "importPath": "homework.hw03.hw03",
        "description": "homework.hw03.hw03",
        "peekOfCode": "def move_stack(n, start, end):\n    \"\"\"Print the moves required to move n disks on the start pole to the end\n    pole without violating the rules of Towers of Hanoi.\n    n -- number of disks\n    start -- a pole position, either 1, 2, or 3\n    end -- a pole position, either 1, 2, or 3\n    There are exactly three poles, and start and end must be different. Assume\n    that the start pole has at least n disks of increasing size, and the end\n    pole is either empty or has a top disk larger than the top n start disks.\n    >>> move_stack(1, 1, 3)",
        "detail": "homework.hw03.hw03",
        "documentation": {}
    },
    {
        "label": "make_anonymous_factorial",
        "kind": 2,
        "importPath": "homework.hw03.hw03",
        "description": "homework.hw03.hw03",
        "peekOfCode": "def make_anonymous_factorial():\n    \"\"\"Return the value of an expression that computes factorial.\n    >>> make_anonymous_factorial()(5)\n    120\n    >>> from construct_check import check\n    >>> # ban any assignments or recursion\n    >>> check(HW_SOURCE_FILE, 'make_anonymous_factorial',\n    ...     ['Assign', 'AnnAssign', 'AugAssign', 'NamedExpr', 'FunctionDef', 'Recursion'])\n    True\n    \"\"\"",
        "detail": "homework.hw03.hw03",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "lab.lab00.tests.python-basics",
        "description": "lab.lab00.tests.python-basics",
        "peekOfCode": "test = {\n  'name': 'Python Basics',\n  'points': 0,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> x = 20\n          >>> x + 2",
        "detail": "lab.lab00.tests.python-basics",
        "documentation": {}
    },
    {
        "label": "twenty_twenty_four",
        "kind": 2,
        "importPath": "lab.lab00.lab00",
        "description": "lab.lab00.lab00",
        "peekOfCode": "def twenty_twenty_four():\n    \"\"\"Come up with the most creative expression that evaluates to 2024\n    using only numbers and the +, *, and - operators.\n    >>> twenty_twenty_four()\n    2024\n    \"\"\"\n    return 2*2*2*2*2*2*2*2*2*2*2-2*2*2*2-2*2*2",
        "detail": "lab.lab00.lab00",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "lab.lab01.tests.control",
        "description": "lab.lab01.tests.control",
        "peekOfCode": "test = {\n  'name': 'Control',\n  'points': 0,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> def xk(c, d):\n          ...     if c == 4:",
        "detail": "lab.lab01.tests.control",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "lab.lab01.tests.debugging-quiz",
        "description": "lab.lab01.tests.debugging-quiz",
        "peekOfCode": "test = {\n  'name': 'debugging-quiz',\n  'points': 0,\n  'suites': [\n    {\n      'cases': [\n        {\n          'answer': 'h(x + y * 5)',\n          'choices': [\n            'f(\"hi\")',",
        "detail": "lab.lab01.tests.debugging-quiz",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "lab.lab01.tests.if-statements",
        "description": "lab.lab01.tests.if-statements",
        "peekOfCode": "test = {\n  'name': 'What If?',\n  'points': 0,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> def ab(c, d):\n          ...     if c > 5:",
        "detail": "lab.lab01.tests.if-statements",
        "documentation": {}
    },
    {
        "label": "falling",
        "kind": 2,
        "importPath": "lab.lab01.lab01",
        "description": "lab.lab01.lab01",
        "peekOfCode": "def falling(n, k):\n    \"\"\"Compute the falling factorial of n to depth k.\n    >>> falling(6, 3)  # 6 * 5 * 4\n    120\n    >>> falling(4, 3)  # 4 * 3 * 2\n    24\n    >>> falling(4, 1)  # 4\n    4\n    >>> falling(4, 0)\n    1",
        "detail": "lab.lab01.lab01",
        "documentation": {}
    },
    {
        "label": "divisible_by_k",
        "kind": 2,
        "importPath": "lab.lab01.lab01",
        "description": "lab.lab01.lab01",
        "peekOfCode": "def divisible_by_k(n, k):\n    \"\"\"\n    >>> a = divisible_by_k(10, 2)  # 2, 4, 6, 8, and 10 are divisible by 2\n    2\n    4\n    6\n    8\n    10\n    >>> a\n    5",
        "detail": "lab.lab01.lab01",
        "documentation": {}
    },
    {
        "label": "sum_digits",
        "kind": 2,
        "importPath": "lab.lab01.lab01",
        "description": "lab.lab01.lab01",
        "peekOfCode": "def sum_digits(y):\n    \"\"\"Sum all the digits of y.\n    >>> sum_digits(10) # 1 + 0 = 1\n    1\n    >>> sum_digits(4224) # 4 + 2 + 2 + 4 = 12\n    12\n    >>> sum_digits(1234567890)\n    45\n    >>> a = sum_digits(123) # make sure that you are using return rather than print\n    >>> a",
        "detail": "lab.lab01.lab01",
        "documentation": {}
    },
    {
        "label": "double_eights",
        "kind": 2,
        "importPath": "lab.lab01.lab01",
        "description": "lab.lab01.lab01",
        "peekOfCode": "def double_eights(n):\n    \"\"\"Return true if n has two eights in a row.\n    >>> double_eights(8)\n    False\n    >>> double_eights(88)\n    True\n    >>> double_eights(2882)\n    True\n    >>> double_eights(880088)\n    True",
        "detail": "lab.lab01.lab01",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "lab.lab02.tests.hof-wwpd",
        "description": "lab.lab02.tests.hof-wwpd",
        "peekOfCode": "test = {\n  'name': 'Higher Order Functions',\n  'points': 0,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> # If Python displays <function...>, type Function, if it errors type Error, if it displays nothing type Nothing\n          >>> def cake():",
        "detail": "lab.lab02.tests.hof-wwpd",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "lab.lab02.tests.lambda",
        "description": "lab.lab02.tests.lambda",
        "peekOfCode": "test = {\n  'name': 'Lambda the Free',\n  'points': 0,\n  'suites': [\n    {\n      'cases': [\n        {\n          'answer': '28893e4c2667b89b674188e063237622',\n          'choices': [\n            'A lambda expression does not automatically bind the function that it returns to a name.',",
        "detail": "lab.lab02.tests.lambda",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "lab.lab02.tests.short-circuit",
        "description": "lab.lab02.tests.short-circuit",
        "peekOfCode": "test = {\n  'name': 'The Truth Will Prevail',\n  'points': 0,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> True and 13\n          7edad8d629f285ca759c95da679fd452",
        "detail": "lab.lab02.tests.short-circuit",
        "documentation": {}
    },
    {
        "label": "composite_identity",
        "kind": 2,
        "importPath": "lab.lab02.lab02",
        "description": "lab.lab02.lab02",
        "peekOfCode": "def composite_identity(f, g):\n    \"\"\"\n    Return a function with one parameter x that returns True if f(g(x)) is\n    equal to g(f(x)). You can assume the result of g(x) is a valid input for f\n    and vice versa.\n    >>> add_one = lambda x: x + 1        # adds one to x\n    >>> square = lambda x: x**2          # squares x [returns x^2]\n    >>> b1 = composite_identity(square, add_one)\n    >>> b1(0)                            # (0 + 1) ** 2 == 0 ** 2 + 1\n    True",
        "detail": "lab.lab02.lab02",
        "documentation": {}
    },
    {
        "label": "sum_digits",
        "kind": 2,
        "importPath": "lab.lab02.lab02",
        "description": "lab.lab02.lab02",
        "peekOfCode": "def sum_digits(y):\n    \"\"\"Return the sum of the digits of non-negative integer y.\"\"\"\n    total = 0\n    while y > 0:\n        total, y = total + y % 10, y // 10\n    return total\ndef is_prime(n):\n    \"\"\"Return whether positive integer n is prime.\"\"\"\n    if n == 1:\n        return False",
        "detail": "lab.lab02.lab02",
        "documentation": {}
    },
    {
        "label": "is_prime",
        "kind": 2,
        "importPath": "lab.lab02.lab02",
        "description": "lab.lab02.lab02",
        "peekOfCode": "def is_prime(n):\n    \"\"\"Return whether positive integer n is prime.\"\"\"\n    if n == 1:\n        return False\n    k = 2\n    while k < n:\n        if n % k == 0:\n            return False\n        k += 1\n    return True",
        "detail": "lab.lab02.lab02",
        "documentation": {}
    },
    {
        "label": "count_cond",
        "kind": 2,
        "importPath": "lab.lab02.lab02",
        "description": "lab.lab02.lab02",
        "peekOfCode": "def count_cond(condition):\n    \"\"\"Returns a function with one parameter N that counts all the numbers from\n    1 to N that satisfy the two-argument predicate function Condition, where\n    the first argument for Condition is N and the second argument is the\n    number from 1 to N.\n    >>> count_fives = count_cond(lambda n, i: sum_digits(n * i) == 5)\n    >>> count_fives(10)   # 50 (10 * 5)\n    1\n    >>> count_fives(50)   # 50 (50 * 1), 500 (50 * 10), 1400 (50 * 28), 2300 (50 * 46)\n    4",
        "detail": "lab.lab02.lab02",
        "documentation": {}
    },
    {
        "label": "gcd",
        "kind": 2,
        "importPath": "lab.lab02.lab02",
        "description": "lab.lab02.lab02",
        "peekOfCode": "def gcd(x,y):\n    while y:\n        x,y = y,x%y\n    return x\ndef multiple(a, b):\n    \"\"\"Return the smallest number n that is a multiple of both a and b.\n    >>> multiple(3, 4)\n    12\n    >>> multiple(14, 21)\n    42",
        "detail": "lab.lab02.lab02",
        "documentation": {}
    },
    {
        "label": "multiple",
        "kind": 2,
        "importPath": "lab.lab02.lab02",
        "description": "lab.lab02.lab02",
        "peekOfCode": "def multiple(a, b):\n    \"\"\"Return the smallest number n that is a multiple of both a and b.\n    >>> multiple(3, 4)\n    12\n    >>> multiple(14, 21)\n    42\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \"\"\"st = min(a,b)\n    for i in range(1,max(a,b)+1):",
        "detail": "lab.lab02.lab02",
        "documentation": {}
    },
    {
        "label": "cycle",
        "kind": 2,
        "importPath": "lab.lab02.lab02",
        "description": "lab.lab02.lab02",
        "peekOfCode": "def cycle(f1, f2, f3):\n    \"\"\"Returns a function that is itself a higher-order function.\n    >>> def add1(x):\n    ...     return x + 1\n    >>> def times2(x):\n    ...     return x * 2\n    >>> def add3(x):\n    ...     return x + 3\n    >>> my_cycle = cycle(add1, times2, add3)\n    >>> identity = my_cycle(0)",
        "detail": "lab.lab02.lab02",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "lab.lab03.tests.list-comprehensions-wwpd",
        "description": "lab.lab03.tests.list-comprehensions-wwpd",
        "peekOfCode": "test = {\n  'name': 'Comprehensions',\n  'points': 0,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> [2 * x for x in range(4)]\n          40628ea906dbaef22f25b053c4dd1e1e",
        "detail": "lab.lab03.tests.list-comprehensions-wwpd",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "lab.lab03.tests.lists-wwpd",
        "description": "lab.lab03.tests.lists-wwpd",
        "peekOfCode": "test = {\n  'name': 'Lists',\n  'points': 0,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> s = [7//3, 5, [4, 0, 1], 2]\n          >>> s[0]",
        "detail": "lab.lab03.tests.lists-wwpd",
        "documentation": {}
    },
    {
        "label": "ExclusionChecker",
        "kind": 6,
        "importPath": "lab.lab03.construct_check",
        "description": "lab.lab03.construct_check",
        "peekOfCode": "class ExclusionChecker(NodeVisitor):\n    \"\"\"An AST visitor that checks that certain constructs are excluded from\n    parts of a program.  ExclusionChecker(EXC) checks that AST node types\n    whose names are in the sequence or set EXC are not present.  Its check\n    method visits nodes in a given function of a source file checking that the\n    indicated node types are not used.\"\"\"\n    def __init__(self, disallow=()):\n        \"\"\"DISALLOW is the initial default list of disallowed\n        node-type names.\"\"\"\n        self._disallow = set(disallow)",
        "detail": "lab.lab03.construct_check",
        "documentation": {}
    },
    {
        "label": "check",
        "kind": 2,
        "importPath": "lab.lab03.construct_check",
        "description": "lab.lab03.construct_check",
        "peekOfCode": "def check(source_file, checked_funcs, disallow, source=None):\n    \"\"\"Checks that AST nodes whose type names are present in DISALLOW\n    (an object supporting 'in') are not present in the function(s) named\n    CHECKED_FUNCS in SOURCE.  By default, SOURCE is the contents of the\n    file SOURCE_FILE.  CHECKED_FUNCS is either a string (indicating a single\n    name) or an object of some other type that supports 'in'. CHECKED_FUNCS\n    may contain __main__ to indicate an entire  module. Prints reports of\n    each prohibited node and returns True iff none are found.\n    See ast.__dir__() for AST type names.  The special node name 'Recursion'\n    checks for overtly recursive calls (i.e., calls of the form NAME(...) where",
        "detail": "lab.lab03.construct_check",
        "documentation": {}
    },
    {
        "label": "_NAMES",
        "kind": 5,
        "importPath": "lab.lab03.construct_check",
        "description": "lab.lab03.construct_check",
        "peekOfCode": "_NAMES = {\n    'Add': '+',\n    'And': 'and',\n    'Assert': 'assert',\n    'Assign': '=',\n    'AnnAssign': '=',\n    'AugAssign': 'op=',\n    'BitAnd': '&',\n    'BitOr': '|',\n    'BitXor': '^',",
        "detail": "lab.lab03.construct_check",
        "documentation": {}
    },
    {
        "label": "print_if",
        "kind": 2,
        "importPath": "lab.lab03.lab03",
        "description": "lab.lab03.lab03",
        "peekOfCode": "def print_if(s, f):\n    \"\"\"Print each element of s for which f returns a true value.\n    >>> print_if([3, 4, 5, 6], lambda x: x > 4)\n    5\n    6\n    >>> result = print_if([3, 4, 5, 6], lambda x: x % 2 == 0)\n    4\n    6\n    >>> print(result)  # print_if should return None\n    None",
        "detail": "lab.lab03.lab03",
        "documentation": {}
    },
    {
        "label": "close",
        "kind": 2,
        "importPath": "lab.lab03.lab03",
        "description": "lab.lab03.lab03",
        "peekOfCode": "def close(s, k):\n    \"\"\"Return how many elements of s that are within k of their index.\n    >>> t = [6, 2, 4, 3, 5]\n    >>> close(t, 0)  # Only 3 is equal to its index\n    1\n    >>> close(t, 1)  # 2, 3, and 5 are within 1 of their index\n    3\n    >>> close(t, 2)  # 2, 3, 4, and 5 are all within 2 of their index\n    4\n    >>> close(list(range(10)), 0)",
        "detail": "lab.lab03.lab03",
        "documentation": {}
    },
    {
        "label": "close_list",
        "kind": 2,
        "importPath": "lab.lab03.lab03",
        "description": "lab.lab03.lab03",
        "peekOfCode": "def close_list(s, k):\n    \"\"\"Return a list of the elements of s that are within k of their index.\n    >>> t = [6, 2, 4, 3, 5]\n    >>> close_list(t, 0)  # Only 3 is equal to its index\n    [3]\n    >>> close_list(t, 1)  # 2, 3, and 5 are within 1 of their index\n    [2, 3, 5]\n    >>> close_list(t, 2)  # 2, 3, 4, and 5 are all within 2 of their index\n    [2, 4, 3, 5]\n    \"\"\"",
        "detail": "lab.lab03.lab03",
        "documentation": {}
    },
    {
        "label": "squares",
        "kind": 2,
        "importPath": "lab.lab03.lab03",
        "description": "lab.lab03.lab03",
        "peekOfCode": "def squares(s):\n    \"\"\"Returns a new list containing square roots of the elements of the\n    original list that are perfect squares.\n    >>> seq = [8, 49, 8, 9, 2, 1, 100, 102]\n    >>> squares(seq)\n    [7, 3, 1, 10]\n    >>> seq = [500, 30]\n    >>> squares(seq)\n    []\n    \"\"\"",
        "detail": "lab.lab03.lab03",
        "documentation": {}
    },
    {
        "label": "double_eights",
        "kind": 2,
        "importPath": "lab.lab03.lab03",
        "description": "lab.lab03.lab03",
        "peekOfCode": "def double_eights(n):\n    \"\"\" Returns whether or not n has two digits in row that\n    are the number 8. Assume n has at least two digits in it.\n    >>> double_eights(1288)\n    True\n    >>> double_eights(880)\n    True\n    >>> double_eights(538835)\n    True\n    >>> double_eights(284682)",
        "detail": "lab.lab03.lab03",
        "documentation": {}
    },
    {
        "label": "make_onion",
        "kind": 2,
        "importPath": "lab.lab03.lab03",
        "description": "lab.lab03.lab03",
        "peekOfCode": "def make_onion(f, g):\n    \"\"\"Return a function can_reach(x, y, limit) that returns\n    whether some call expression containing only f, g, and x with\n    up to limit calls will give the result y.\n    >>> up = lambda x: x + 1\n    >>> double = lambda y: y * 2\n    >>> can_reach = make_onion(up, double)\n    >>> can_reach(5, 25, 4)      # 25 = up(double(double(up(5))))\n    True\n    >>> can_reach(5, 25, 3)      # Not possible",
        "detail": "lab.lab03.lab03",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "lab.lab04.tests.pokemon",
        "description": "lab.lab04.tests.pokemon",
        "peekOfCode": "test = {\n  'name': 'Dictionaries',\n  'points': 0,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> pokemon = {'pikachu': 25, 'dragonair': 148, 'mew': 151}\n          >>> pokemon['pikachu']",
        "detail": "lab.lab04.tests.pokemon",
        "documentation": {}
    },
    {
        "label": "ExclusionChecker",
        "kind": 6,
        "importPath": "lab.lab04.construct_check",
        "description": "lab.lab04.construct_check",
        "peekOfCode": "class ExclusionChecker(NodeVisitor):\n    \"\"\"An AST visitor that checks that certain constructs are excluded from\n    parts of a program.  ExclusionChecker(EXC) checks that AST node types\n    whose names are in the sequence or set EXC are not present.  Its check\n    method visits nodes in a given function of a source file checking that the\n    indicated node types are not used.\"\"\"\n    def __init__(self, disallow=()):\n        \"\"\"DISALLOW is the initial default list of disallowed\n        node-type names.\"\"\"\n        self._disallow = set(disallow)",
        "detail": "lab.lab04.construct_check",
        "documentation": {}
    },
    {
        "label": "check",
        "kind": 2,
        "importPath": "lab.lab04.construct_check",
        "description": "lab.lab04.construct_check",
        "peekOfCode": "def check(source_file, checked_funcs, disallow, source=None):\n    \"\"\"Checks that AST nodes whose type names are present in DISALLOW\n    (an object supporting 'in') are not present in the function(s) named\n    CHECKED_FUNCS in SOURCE.  By default, SOURCE is the contents of the\n    file SOURCE_FILE.  CHECKED_FUNCS is either a string (indicating a single\n    name) or an object of some other type that supports 'in'. CHECKED_FUNCS\n    may contain __main__ to indicate an entire  module. Prints reports of\n    each prohibited node and returns True iff none are found.\n    See ast.__dir__() for AST type names.  The special node name 'Recursion'\n    checks for overtly recursive calls (i.e., calls of the form NAME(...) where",
        "detail": "lab.lab04.construct_check",
        "documentation": {}
    },
    {
        "label": "_NAMES",
        "kind": 5,
        "importPath": "lab.lab04.construct_check",
        "description": "lab.lab04.construct_check",
        "peekOfCode": "_NAMES = {\n    'Add': '+',\n    'And': 'and',\n    'Assert': 'assert',\n    'Assign': '=',\n    'AnnAssign': '=',\n    'AugAssign': 'op=',\n    'BitAnd': '&',\n    'BitOr': '|',\n    'BitXor': '^',",
        "detail": "lab.lab04.construct_check",
        "documentation": {}
    },
    {
        "label": "divide",
        "kind": 2,
        "importPath": "lab.lab04.lab04",
        "description": "lab.lab04.lab04",
        "peekOfCode": "def divide(quotients, divisors):\n    \"\"\"Return a dictonary in which each quotient q is a key for the list of\n    divisors that it divides evenly.\n    >>> divide([3, 4, 5], [8, 9, 10, 11, 12])\n    {3: [9, 12], 4: [8, 12], 5: [10]}\n    >>> divide(range(1, 5), range(20, 25))\n    {1: [20, 21, 22, 23, 24], 2: [20, 22, 24], 3: [21, 24], 4: [20, 24]}\n    \"\"\"\n    return {q: [d for d in divisors if d % q == 0] for q in quotients }\ndef buy(required_fruits, prices, total_amount):",
        "detail": "lab.lab04.lab04",
        "documentation": {}
    },
    {
        "label": "buy",
        "kind": 2,
        "importPath": "lab.lab04.lab04",
        "description": "lab.lab04.lab04",
        "peekOfCode": "def buy(required_fruits, prices, total_amount):\n    \"\"\"Print ways to buy some of each fruit so that the sum of prices is amount.\n    >>> prices = {'oranges': 4, 'apples': 3, 'bananas': 2, 'kiwis': 9}\n    >>> buy(['apples', 'oranges', 'bananas'], prices, 12)\n    [2 apples][1 orange][1 banana]\n    >>> buy(['apples', 'oranges', 'bananas'], prices, 16)\n    [2 apples][1 orange][3 bananas]\n    [2 apples][2 oranges][1 banana]\n    >>> buy(['apples', 'kiwis'], prices, 36)\n    [3 apples][3 kiwis]",
        "detail": "lab.lab04.lab04",
        "documentation": {}
    },
    {
        "label": "display",
        "kind": 2,
        "importPath": "lab.lab04.lab04",
        "description": "lab.lab04.lab04",
        "peekOfCode": "def display(fruit, count):\n    \"\"\"Display a count of a fruit in square brackets.\n    >>> display('apples', 3)\n    '[3 apples]'\n    >>> display('apples', 1)\n    '[1 apple]'\n    \"\"\"\n    assert count >= 1 and fruit[-1] == 's'\n    if count == 1:\n        fruit = fruit[:-1]  # get rid of the plural s",
        "detail": "lab.lab04.lab04",
        "documentation": {}
    },
    {
        "label": "distance",
        "kind": 2,
        "importPath": "lab.lab04.lab04",
        "description": "lab.lab04.lab04",
        "peekOfCode": "def distance(city_a, city_b):\n    \"\"\"\n    >>> city_a = make_city('city_a', 0, 1)\n    >>> city_b = make_city('city_b', 0, 2)\n    >>> distance(city_a, city_b)\n    1.0\n    >>> city_c = make_city('city_c', 6.5, 12)\n    >>> city_d = make_city('city_d', 2.5, 15)\n    >>> distance(city_c, city_d)\n    5.0",
        "detail": "lab.lab04.lab04",
        "documentation": {}
    },
    {
        "label": "closer_city",
        "kind": 2,
        "importPath": "lab.lab04.lab04",
        "description": "lab.lab04.lab04",
        "peekOfCode": "def closer_city(lat, lon, city_a, city_b):\n    \"\"\"\n    Returns the name of either city_a or city_b, whichever is closest to\n    coordinate (lat, lon). If the two cities are the same distance away\n    from the coordinate, consider city_b to be the closer city.\n    >>> berkeley = make_city('Berkeley', 37.87, 112.26)\n    >>> stanford = make_city('Stanford', 34.05, 118.25)\n    >>> closer_city(38.33, 121.44, berkeley, stanford)\n    'Stanford'\n    >>> bucharest = make_city('Bucharest', 44.43, 26.10)",
        "detail": "lab.lab04.lab04",
        "documentation": {}
    },
    {
        "label": "check_city_abstraction",
        "kind": 2,
        "importPath": "lab.lab04.lab04",
        "description": "lab.lab04.lab04",
        "peekOfCode": "def check_city_abstraction():\n    \"\"\"\n    There's nothing for you to do for this function, it's just here for the extra doctest\n    >>> change_abstraction(True)\n    >>> city_a = make_city('city_a', 0, 1)\n    >>> city_b = make_city('city_b', 0, 2)\n    >>> distance(city_a, city_b)\n    1.0\n    >>> city_c = make_city('city_c', 6.5, 12)\n    >>> city_d = make_city('city_d', 2.5, 15)",
        "detail": "lab.lab04.lab04",
        "documentation": {}
    },
    {
        "label": "make_city",
        "kind": 2,
        "importPath": "lab.lab04.lab04",
        "description": "lab.lab04.lab04",
        "peekOfCode": "def make_city(name, lat, lon):\n    \"\"\"\n    >>> city = make_city('Berkeley', 0, 1)\n    >>> get_name(city)\n    'Berkeley'\n    >>> get_lat(city)\n    0\n    >>> get_lon(city)\n    1\n    \"\"\"",
        "detail": "lab.lab04.lab04",
        "documentation": {}
    },
    {
        "label": "get_name",
        "kind": 2,
        "importPath": "lab.lab04.lab04",
        "description": "lab.lab04.lab04",
        "peekOfCode": "def get_name(city):\n    \"\"\"\n    >>> city = make_city('Berkeley', 0, 1)\n    >>> get_name(city)\n    'Berkeley'\n    \"\"\"\n    if change_abstraction.changed:\n        return city[\"name\"]\n    else:\n        return city[0]",
        "detail": "lab.lab04.lab04",
        "documentation": {}
    },
    {
        "label": "get_lat",
        "kind": 2,
        "importPath": "lab.lab04.lab04",
        "description": "lab.lab04.lab04",
        "peekOfCode": "def get_lat(city):\n    \"\"\"\n    >>> city = make_city('Berkeley', 0, 1)\n    >>> get_lat(city)\n    0\n    \"\"\"\n    if change_abstraction.changed:\n        return city[\"lat\"]\n    else:\n        return city[1]",
        "detail": "lab.lab04.lab04",
        "documentation": {}
    },
    {
        "label": "get_lon",
        "kind": 2,
        "importPath": "lab.lab04.lab04",
        "description": "lab.lab04.lab04",
        "peekOfCode": "def get_lon(city):\n    \"\"\"\n    >>> city = make_city('Berkeley', 0, 1)\n    >>> get_lon(city)\n    1\n    \"\"\"\n    if change_abstraction.changed:\n        return city[\"lon\"]\n    else:\n        return city[2]",
        "detail": "lab.lab04.lab04",
        "documentation": {}
    },
    {
        "label": "change_abstraction",
        "kind": 2,
        "importPath": "lab.lab04.lab04",
        "description": "lab.lab04.lab04",
        "peekOfCode": "def change_abstraction(change):\n    \"\"\"\n    For testing purposes.\n    >>> change_abstraction(True)\n    >>> change_abstraction.changed\n    True\n    \"\"\"\n    change_abstraction.changed = change\nchange_abstraction.changed = False",
        "detail": "lab.lab04.lab04",
        "documentation": {}
    },
    {
        "label": "change_abstraction.changed",
        "kind": 5,
        "importPath": "lab.lab04.lab04",
        "description": "lab.lab04.lab04",
        "peekOfCode": "change_abstraction.changed = False",
        "detail": "lab.lab04.lab04",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "lab.lab05.tests.iterators-wwpd",
        "description": "lab.lab05.tests.iterators-wwpd",
        "peekOfCode": "test = {\n  'name': 'Iterators',\n  'points': 0,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> # Enter StopIteration if StopIteration exception occurs, Error for other errors\n          >>> # Enter Iterator if the output is an iterator object.",
        "detail": "lab.lab05.tests.iterators-wwpd",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "lab.lab05.tests.list-mutation",
        "description": "lab.lab05.tests.list-mutation",
        "peekOfCode": "test = {\n  'name': 'List Mutation',\n  'points': 0,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> # If nothing would be output by Python, type Nothing\n          >>> # If the code would error, type Error",
        "detail": "lab.lab05.tests.list-mutation",
        "documentation": {}
    },
    {
        "label": "insert_items",
        "kind": 2,
        "importPath": "lab.lab05.lab05",
        "description": "lab.lab05.lab05",
        "peekOfCode": "def insert_items(s, before, after):\n    \"\"\"Insert after into s after each occurrence of before and then return s.\n    >>> test_s = [1, 5, 8, 5, 2, 3]\n    >>> new_s = insert_items(test_s, 5, 7)\n    >>> new_s\n    [1, 5, 7, 8, 5, 7, 2, 3]\n    >>> test_s\n    [1, 5, 7, 8, 5, 7, 2, 3]\n    >>> new_s is test_s\n    True",
        "detail": "lab.lab05.lab05",
        "documentation": {}
    },
    {
        "label": "group_by",
        "kind": 2,
        "importPath": "lab.lab05.lab05",
        "description": "lab.lab05.lab05",
        "peekOfCode": "def group_by(s, fn):\n    \"\"\"Return a dictionary of lists that together contain the elements of s.\n    The key for each list is the value that fn returns when called on any of the\n    values of that list.\n    >>> group_by([12, 23, 14, 45], lambda p: p // 10)\n    {1: [12, 14], 2: [23], 4: [45]}\n    >>> group_by(range(-3, 4), lambda x: x * x)\n    {9: [-3, 3], 4: [-2, 2], 1: [-1, 1], 0: [0]}\n    \"\"\"\n    grouped = {}",
        "detail": "lab.lab05.lab05",
        "documentation": {}
    },
    {
        "label": "count_occurrences",
        "kind": 2,
        "importPath": "lab.lab05.lab05",
        "description": "lab.lab05.lab05",
        "peekOfCode": "def count_occurrences(t, n, x):\n    \"\"\"Return the number of times that x is equal to one of the\n    first n elements of iterator t.\n    >>> s = iter([10, 9, 10, 9, 9, 10, 8, 8, 8, 7])\n    >>> count_occurrences(s, 10, 9)\n    3\n    >>> t = iter([10, 9, 10, 9, 9, 10, 8, 8, 8, 7])\n    >>> count_occurrences(t, 3, 10)\n    2\n    >>> u = iter([3, 2, 2, 2, 1, 2, 1, 4, 4, 5, 5, 5])",
        "detail": "lab.lab05.lab05",
        "documentation": {}
    },
    {
        "label": "repeated",
        "kind": 2,
        "importPath": "lab.lab05.lab05",
        "description": "lab.lab05.lab05",
        "peekOfCode": "def repeated(t, k):\n    \"\"\"Return the first value in iterator t that appears k times in a row,\n    calling next on t as few times as possible.\n    >>> s = iter([10, 9, 10, 9, 9, 10, 8, 8, 8, 7])\n    >>> repeated(s, 2)\n    9\n    >>> t = iter([10, 9, 10, 9, 9, 10, 8, 8, 8, 7])\n    >>> repeated(t, 3)\n    8\n    >>> u = iter([3, 2, 2, 2, 1, 2, 1, 4, 4, 5, 5, 5])",
        "detail": "lab.lab05.lab05",
        "documentation": {}
    },
    {
        "label": "sprout_leaves",
        "kind": 2,
        "importPath": "lab.lab05.lab05",
        "description": "lab.lab05.lab05",
        "peekOfCode": "def sprout_leaves(t, leaves):\n    \"\"\"Sprout new leaves containing the labels in leaves at each leaf of\n    the original tree t and return the resulting tree.\n    >>> t1 = tree(1, [tree(2), tree(3)])\n    >>> print_tree(t1)\n    1\n      2\n      3\n    >>> new1 = sprout_leaves(t1, [4, 5])\n    >>> print_tree(new1)",
        "detail": "lab.lab05.lab05",
        "documentation": {}
    },
    {
        "label": "partial_reverse",
        "kind": 2,
        "importPath": "lab.lab05.lab05",
        "description": "lab.lab05.lab05",
        "peekOfCode": "def partial_reverse(s, start):\n    \"\"\"Reverse part of a list in-place, starting with start up to the end of\n    the list.\n    >>> a = [1, 2, 3, 4, 5, 6, 7]\n    >>> partial_reverse(a, 2)\n    >>> a\n    [1, 2, 7, 6, 5, 4, 3]\n    >>> partial_reverse(a, 5)\n    >>> a\n    [1, 2, 7, 6, 5, 3, 4]",
        "detail": "lab.lab05.lab05",
        "documentation": {}
    },
    {
        "label": "tree",
        "kind": 2,
        "importPath": "lab.lab05.lab05",
        "description": "lab.lab05.lab05",
        "peekOfCode": "def tree(label, branches=[]):\n    \"\"\"Construct a tree with the given label value and a list of branches.\"\"\"\n    for branch in branches:\n        assert is_tree(branch), 'branches must be trees'\n    return [label] + list(branches)\ndef label(tree):\n    \"\"\"Return the label value of a tree.\"\"\"\n    return tree[0]\ndef branches(tree):\n    \"\"\"Return the list of branches of the given tree.\"\"\"",
        "detail": "lab.lab05.lab05",
        "documentation": {}
    },
    {
        "label": "label",
        "kind": 2,
        "importPath": "lab.lab05.lab05",
        "description": "lab.lab05.lab05",
        "peekOfCode": "def label(tree):\n    \"\"\"Return the label value of a tree.\"\"\"\n    return tree[0]\ndef branches(tree):\n    \"\"\"Return the list of branches of the given tree.\"\"\"\n    return tree[1:]\ndef is_tree(tree):\n    \"\"\"Returns True if the given tree is a tree, and False otherwise.\"\"\"\n    if type(tree) != list or len(tree) < 1:\n        return False",
        "detail": "lab.lab05.lab05",
        "documentation": {}
    },
    {
        "label": "branches",
        "kind": 2,
        "importPath": "lab.lab05.lab05",
        "description": "lab.lab05.lab05",
        "peekOfCode": "def branches(tree):\n    \"\"\"Return the list of branches of the given tree.\"\"\"\n    return tree[1:]\ndef is_tree(tree):\n    \"\"\"Returns True if the given tree is a tree, and False otherwise.\"\"\"\n    if type(tree) != list or len(tree) < 1:\n        return False\n    for branch in branches(tree):\n        if not is_tree(branch):\n            return False",
        "detail": "lab.lab05.lab05",
        "documentation": {}
    },
    {
        "label": "is_tree",
        "kind": 2,
        "importPath": "lab.lab05.lab05",
        "description": "lab.lab05.lab05",
        "peekOfCode": "def is_tree(tree):\n    \"\"\"Returns True if the given tree is a tree, and False otherwise.\"\"\"\n    if type(tree) != list or len(tree) < 1:\n        return False\n    for branch in branches(tree):\n        if not is_tree(branch):\n            return False\n    return True\ndef is_leaf(tree):\n    \"\"\"Returns True if the given tree's list of branches is empty, and False",
        "detail": "lab.lab05.lab05",
        "documentation": {}
    },
    {
        "label": "is_leaf",
        "kind": 2,
        "importPath": "lab.lab05.lab05",
        "description": "lab.lab05.lab05",
        "peekOfCode": "def is_leaf(tree):\n    \"\"\"Returns True if the given tree's list of branches is empty, and False\n    otherwise.\n    \"\"\"\n    return not branches(tree)\ndef print_tree(t, indent=0):\n    \"\"\"Print a representation of this tree in which each node is\n    indented by two spaces times its depth from the root.\n    >>> print_tree(tree(1))\n    1",
        "detail": "lab.lab05.lab05",
        "documentation": {}
    },
    {
        "label": "print_tree",
        "kind": 2,
        "importPath": "lab.lab05.lab05",
        "description": "lab.lab05.lab05",
        "peekOfCode": "def print_tree(t, indent=0):\n    \"\"\"Print a representation of this tree in which each node is\n    indented by two spaces times its depth from the root.\n    >>> print_tree(tree(1))\n    1\n    >>> print_tree(tree(1, [tree(2)]))\n    1\n      2\n    >>> numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])\n    >>> print_tree(numbers)",
        "detail": "lab.lab05.lab05",
        "documentation": {}
    },
    {
        "label": "copy_tree",
        "kind": 2,
        "importPath": "lab.lab05.lab05",
        "description": "lab.lab05.lab05",
        "peekOfCode": "def copy_tree(t):\n    \"\"\"Returns a copy of t. Only for testing purposes.\n    >>> t = tree(5)\n    >>> copy = copy_tree(t)\n    >>> t = tree(6)\n    >>> print_tree(copy)\n    5\n    \"\"\"\n    return tree(label(t), [copy_tree(b) for b in branches(t)])",
        "detail": "lab.lab05.lab05",
        "documentation": {}
    },
    {
        "label": "tree",
        "kind": 2,
        "importPath": "lab.lab05.tree",
        "description": "lab.lab05.tree",
        "peekOfCode": "def tree(label, branches=[]):\n    \"\"\"Construct a tree with the given label value and a list of branches.\"\"\"\n    for branch in branches:\n        assert is_tree(branch), 'branches must be trees'\n    return [label] + list(branches)\ndef label(tree):\n    \"\"\"Return the label value of a tree.\"\"\"\n    return tree[0]\ndef branches(tree):\n    \"\"\"Return the list of branches of the given tree.\"\"\"",
        "detail": "lab.lab05.tree",
        "documentation": {}
    },
    {
        "label": "label",
        "kind": 2,
        "importPath": "lab.lab05.tree",
        "description": "lab.lab05.tree",
        "peekOfCode": "def label(tree):\n    \"\"\"Return the label value of a tree.\"\"\"\n    return tree[0]\ndef branches(tree):\n    \"\"\"Return the list of branches of the given tree.\"\"\"\n    return tree[1:]\ndef is_tree(tree):\n    \"\"\"Returns True if the given tree is a tree, and False otherwise.\"\"\"\n    if type(tree) != list or len(tree) < 1:\n        return False",
        "detail": "lab.lab05.tree",
        "documentation": {}
    },
    {
        "label": "branches",
        "kind": 2,
        "importPath": "lab.lab05.tree",
        "description": "lab.lab05.tree",
        "peekOfCode": "def branches(tree):\n    \"\"\"Return the list of branches of the given tree.\"\"\"\n    return tree[1:]\ndef is_tree(tree):\n    \"\"\"Returns True if the given tree is a tree, and False otherwise.\"\"\"\n    if type(tree) != list or len(tree) < 1:\n        return False\n    for branch in branches(tree):\n        if not is_tree(branch):\n            return False",
        "detail": "lab.lab05.tree",
        "documentation": {}
    },
    {
        "label": "is_tree",
        "kind": 2,
        "importPath": "lab.lab05.tree",
        "description": "lab.lab05.tree",
        "peekOfCode": "def is_tree(tree):\n    \"\"\"Returns True if the given tree is a tree, and False otherwise.\"\"\"\n    if type(tree) != list or len(tree) < 1:\n        return False\n    for branch in branches(tree):\n        if not is_tree(branch):\n            return False\n    return True\ndef is_leaf(tree):\n    \"\"\"Returns True if the given tree's list of branches is empty, and False",
        "detail": "lab.lab05.tree",
        "documentation": {}
    },
    {
        "label": "is_leaf",
        "kind": 2,
        "importPath": "lab.lab05.tree",
        "description": "lab.lab05.tree",
        "peekOfCode": "def is_leaf(tree):\n    \"\"\"Returns True if the given tree's list of branches is empty, and False\n    otherwise.\n    \"\"\"\n    return not branches(tree)\ndef print_tree(t, indent=0):\n    \"\"\"Print a representation of this tree in which each node is\n    indented by two spaces times its depth from the root.\n    >>> print_tree(tree(1))\n    1",
        "detail": "lab.lab05.tree",
        "documentation": {}
    },
    {
        "label": "print_tree",
        "kind": 2,
        "importPath": "lab.lab05.tree",
        "description": "lab.lab05.tree",
        "peekOfCode": "def print_tree(t, indent=0):\n    \"\"\"Print a representation of this tree in which each node is\n    indented by two spaces times its depth from the root.\n    >>> print_tree(tree(1))\n    1\n    >>> print_tree(tree(1, [tree(2)]))\n    1\n      2\n    >>> numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])\n    >>> print_tree(numbers)",
        "detail": "lab.lab05.tree",
        "documentation": {}
    },
    {
        "label": "copy_tree",
        "kind": 2,
        "importPath": "lab.lab05.tree",
        "description": "lab.lab05.tree",
        "peekOfCode": "def copy_tree(t):\n    \"\"\"Returns a copy of t. Only for testing purposes.\n    >>> t = tree(5)\n    >>> copy = copy_tree(t)\n    >>> t = tree(6)\n    >>> print_tree(copy)\n    5\n    \"\"\"\n    return tree(label(t), [copy_tree(b) for b in branches(t)])",
        "detail": "lab.lab05.tree",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "lab.lab06.tests.inheritance-abc",
        "description": "lab.lab06.tests.inheritance-abc",
        "peekOfCode": "test = {\n  'name': 'Inheritance ABCs',\n  'points': 0,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> class A:\n          ...   x, y = 0, 0",
        "detail": "lab.lab06.tests.inheritance-abc",
        "documentation": {}
    },
    {
        "label": "card_parse",
        "kind": 2,
        "importPath": "lab.lab06.cardgame",
        "description": "lab.lab06.cardgame",
        "peekOfCode": "def card_parse(line, handsize):\n    tokens = line.split()\n    if not tokens:\n        raise SyntaxError('No command given')\n    elif len(tokens) > 1:\n        raise SyntaxError('Too many inputs')\n    card_index = tokens.pop(0)\n    if not card_index.isdigit():\n        raise SyntaxError('Wrong type of input')\n    card_index = int(card_index)",
        "detail": "lab.lab06.cardgame",
        "documentation": {}
    },
    {
        "label": "name_parse",
        "kind": 2,
        "importPath": "lab.lab06.cardgame",
        "description": "lab.lab06.cardgame",
        "peekOfCode": "def name_parse(line):\n    if not line:\n        raise SyntaxError('No command given')\n    return line\n########\n# REPL #\n########\ndef read_eval_print_loop():\n\twhile True:\n\t\ttry:",
        "detail": "lab.lab06.cardgame",
        "documentation": {}
    },
    {
        "label": "read_eval_print_loop",
        "kind": 2,
        "importPath": "lab.lab06.cardgame",
        "description": "lab.lab06.cardgame",
        "peekOfCode": "def read_eval_print_loop():\n\twhile True:\n\t\ttry:\n\t\t\tline = input('What is your name?> ')\n\t\t\tname = name_parse(line)\n\t\t\tbreak\n\t\texcept (KeyboardInterrupt, EOFError, SystemExit): # If you ctrl-c or ctrl-d\n\t\t\tprint('\\nSee you next game!')\n\t\t\treturn\n\t\texcept SyntaxError as e:",
        "detail": "lab.lab06.cardgame",
        "documentation": {}
    },
    {
        "label": "\t\t\tline",
        "kind": 5,
        "importPath": "lab.lab06.cardgame",
        "description": "lab.lab06.cardgame",
        "peekOfCode": "\t\t\tline = input('What is your name?> ')\n\t\t\tname = name_parse(line)\n\t\t\tbreak\n\t\texcept (KeyboardInterrupt, EOFError, SystemExit): # If you ctrl-c or ctrl-d\n\t\t\tprint('\\nSee you next game!')\n\t\t\treturn\n\t\texcept SyntaxError as e:\n\t\t\tprint('ERROR:', e)\n\tp1 = Player(player_deck, name)\n\tp2 = Player(opponent_deck, 'Opponent')",
        "detail": "lab.lab06.cardgame",
        "documentation": {}
    },
    {
        "label": "\t\t\tname",
        "kind": 5,
        "importPath": "lab.lab06.cardgame",
        "description": "lab.lab06.cardgame",
        "peekOfCode": "\t\t\tname = name_parse(line)\n\t\t\tbreak\n\t\texcept (KeyboardInterrupt, EOFError, SystemExit): # If you ctrl-c or ctrl-d\n\t\t\tprint('\\nSee you next game!')\n\t\t\treturn\n\t\texcept SyntaxError as e:\n\t\t\tprint('ERROR:', e)\n\tp1 = Player(player_deck, name)\n\tp2 = Player(opponent_deck, 'Opponent')\n\tprint(WELCOME_MESSAGE)",
        "detail": "lab.lab06.cardgame",
        "documentation": {}
    },
    {
        "label": "\tp1",
        "kind": 5,
        "importPath": "lab.lab06.cardgame",
        "description": "lab.lab06.cardgame",
        "peekOfCode": "\tp1 = Player(player_deck, name)\n\tp2 = Player(opponent_deck, 'Opponent')\n\tprint(WELCOME_MESSAGE)\n\tduel = Game(p1, p2)\n\tdraw = True\n\twhile True:\n\t\tif duel.game_won() == 1:\n\t\t\tprint(WIN_MESSAGE)\n\t\t\treturn\n\t\telif duel.game_won() == 2:",
        "detail": "lab.lab06.cardgame",
        "documentation": {}
    },
    {
        "label": "\tp2",
        "kind": 5,
        "importPath": "lab.lab06.cardgame",
        "description": "lab.lab06.cardgame",
        "peekOfCode": "\tp2 = Player(opponent_deck, 'Opponent')\n\tprint(WELCOME_MESSAGE)\n\tduel = Game(p1, p2)\n\tdraw = True\n\twhile True:\n\t\tif duel.game_won() == 1:\n\t\t\tprint(WIN_MESSAGE)\n\t\t\treturn\n\t\telif duel.game_won() == 2:\n\t\t\tprint(LOSE_MESSAGE)",
        "detail": "lab.lab06.cardgame",
        "documentation": {}
    },
    {
        "label": "\tduel",
        "kind": 5,
        "importPath": "lab.lab06.cardgame",
        "description": "lab.lab06.cardgame",
        "peekOfCode": "\tduel = Game(p1, p2)\n\tdraw = True\n\twhile True:\n\t\tif duel.game_won() == 1:\n\t\t\tprint(WIN_MESSAGE)\n\t\t\treturn\n\t\telif duel.game_won() == 2:\n\t\t\tprint(LOSE_MESSAGE)\n\t\t\treturn\n\t\tprint()",
        "detail": "lab.lab06.cardgame",
        "documentation": {}
    },
    {
        "label": "\tdraw",
        "kind": 5,
        "importPath": "lab.lab06.cardgame",
        "description": "lab.lab06.cardgame",
        "peekOfCode": "\tdraw = True\n\twhile True:\n\t\tif duel.game_won() == 1:\n\t\t\tprint(WIN_MESSAGE)\n\t\t\treturn\n\t\telif duel.game_won() == 2:\n\t\t\tprint(LOSE_MESSAGE)\n\t\t\treturn\n\t\tprint()\n\t\ttry:",
        "detail": "lab.lab06.cardgame",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tdraw",
        "kind": 5,
        "importPath": "lab.lab06.cardgame",
        "description": "lab.lab06.cardgame",
        "peekOfCode": "\t\t\t\tdraw = True\n\t\t\tp1.display_hand()\n\t\t\tprint('Please enter the number next to the card you would like to play this round.')\n\t\t\tline = input('card> ')\n\t\t\tcard_index = card_parse(line, len(p1.hand))\n\t\t\tduel.play_round(p1.play(card_index), p2.play_random())\n\t\t\tduel.display_scores()\n\t\texcept (KeyboardInterrupt, EOFError, SystemExit): # If you ctrl-c or ctrl-d\n\t\t\tprint('\\nGood game. Bye!')\n\t\t\treturn",
        "detail": "lab.lab06.cardgame",
        "documentation": {}
    },
    {
        "label": "\t\t\tline",
        "kind": 5,
        "importPath": "lab.lab06.cardgame",
        "description": "lab.lab06.cardgame",
        "peekOfCode": "\t\t\tline = input('card> ')\n\t\t\tcard_index = card_parse(line, len(p1.hand))\n\t\t\tduel.play_round(p1.play(card_index), p2.play_random())\n\t\t\tduel.display_scores()\n\t\texcept (KeyboardInterrupt, EOFError, SystemExit): # If you ctrl-c or ctrl-d\n\t\t\tprint('\\nGood game. Bye!')\n\t\t\treturn\n\t\texcept AssertionError: # Deck out\n\t\t\tif p1.deck.is_empty() and p2.deck.is_empty():\n\t\t\t\tprint(TIE_MESSAGE)",
        "detail": "lab.lab06.cardgame",
        "documentation": {}
    },
    {
        "label": "\t\t\tcard_index",
        "kind": 5,
        "importPath": "lab.lab06.cardgame",
        "description": "lab.lab06.cardgame",
        "peekOfCode": "\t\t\tcard_index = card_parse(line, len(p1.hand))\n\t\t\tduel.play_round(p1.play(card_index), p2.play_random())\n\t\t\tduel.display_scores()\n\t\texcept (KeyboardInterrupt, EOFError, SystemExit): # If you ctrl-c or ctrl-d\n\t\t\tprint('\\nGood game. Bye!')\n\t\t\treturn\n\t\texcept AssertionError: # Deck out\n\t\t\tif p1.deck.is_empty() and p2.deck.is_empty():\n\t\t\t\tprint(TIE_MESSAGE)\n\t\t\t\treturn",
        "detail": "lab.lab06.cardgame",
        "documentation": {}
    },
    {
        "label": "\t\t\tdraw",
        "kind": 5,
        "importPath": "lab.lab06.cardgame",
        "description": "lab.lab06.cardgame",
        "peekOfCode": "\t\t\tdraw = False\n#################\n# Configuration #\n#################\nWELCOME_MESSAGE = \"\"\"\nWelcome to Magic: The Lambda-ing!\nYour code has taken on a mind of its own and has\nchallenged you to a game of cards! If you need a refresher\non the rules, check out the section on the project page.\nLet's get this duel started, shall we?",
        "detail": "lab.lab06.cardgame",
        "documentation": {}
    },
    {
        "label": "WELCOME_MESSAGE",
        "kind": 5,
        "importPath": "lab.lab06.cardgame",
        "description": "lab.lab06.cardgame",
        "peekOfCode": "WELCOME_MESSAGE = \"\"\"\nWelcome to Magic: The Lambda-ing!\nYour code has taken on a mind of its own and has\nchallenged you to a game of cards! If you need a refresher\non the rules, check out the section on the project page.\nLet's get this duel started, shall we?\n\"\"\"\nWIN_MESSAGE = \"\"\"\nYou have vanquished your foe in a duel!\nCongratulations! You won this game of Magic: The Lambda-ing!",
        "detail": "lab.lab06.cardgame",
        "documentation": {}
    },
    {
        "label": "WIN_MESSAGE",
        "kind": 5,
        "importPath": "lab.lab06.cardgame",
        "description": "lab.lab06.cardgame",
        "peekOfCode": "WIN_MESSAGE = \"\"\"\nYou have vanquished your foe in a duel!\nCongratulations! You won this game of Magic: The Lambda-ing!\n\"\"\"\nLOSE_MESSAGE = \"\"\"\nYou have been defeated by your foe in a duel!\nI'm sorry, you lost this game of Magic: The Lambda-ing.\n\"\"\"\nTIE_MESSAGE = \"\"\"\nYou and your opponent have no cards left in your decks!",
        "detail": "lab.lab06.cardgame",
        "documentation": {}
    },
    {
        "label": "LOSE_MESSAGE",
        "kind": 5,
        "importPath": "lab.lab06.cardgame",
        "description": "lab.lab06.cardgame",
        "peekOfCode": "LOSE_MESSAGE = \"\"\"\nYou have been defeated by your foe in a duel!\nI'm sorry, you lost this game of Magic: The Lambda-ing.\n\"\"\"\nTIE_MESSAGE = \"\"\"\nYou and your opponent have no cards left in your decks!\nYou tied this game of Magic: The Lambda-ing. Who will win if you play again?\n\"\"\"\nPLAYER_DECKOUT_MESSAGE = \"\"\"\nYou have no cards left in your deck!",
        "detail": "lab.lab06.cardgame",
        "documentation": {}
    },
    {
        "label": "TIE_MESSAGE",
        "kind": 5,
        "importPath": "lab.lab06.cardgame",
        "description": "lab.lab06.cardgame",
        "peekOfCode": "TIE_MESSAGE = \"\"\"\nYou and your opponent have no cards left in your decks!\nYou tied this game of Magic: The Lambda-ing. Who will win if you play again?\n\"\"\"\nPLAYER_DECKOUT_MESSAGE = \"\"\"\nYou have no cards left in your deck!\nI'm sorry, you lost this game of Magic: The Lambda-ing.\n\"\"\"\nOPPONENT_DECKOUT_MESSAGE = \"\"\"\nYour opponent has no cards left in their deck!",
        "detail": "lab.lab06.cardgame",
        "documentation": {}
    },
    {
        "label": "PLAYER_DECKOUT_MESSAGE",
        "kind": 5,
        "importPath": "lab.lab06.cardgame",
        "description": "lab.lab06.cardgame",
        "peekOfCode": "PLAYER_DECKOUT_MESSAGE = \"\"\"\nYou have no cards left in your deck!\nI'm sorry, you lost this game of Magic: The Lambda-ing.\n\"\"\"\nOPPONENT_DECKOUT_MESSAGE = \"\"\"\nYour opponent has no cards left in their deck!\nCongratulations! You won this game of Magic: The Lambda-ing!\n\"\"\"\nif __name__ == '__main__':\n    read_eval_print_loop()",
        "detail": "lab.lab06.cardgame",
        "documentation": {}
    },
    {
        "label": "OPPONENT_DECKOUT_MESSAGE",
        "kind": 5,
        "importPath": "lab.lab06.cardgame",
        "description": "lab.lab06.cardgame",
        "peekOfCode": "OPPONENT_DECKOUT_MESSAGE = \"\"\"\nYour opponent has no cards left in their deck!\nCongratulations! You won this game of Magic: The Lambda-ing!\n\"\"\"\nif __name__ == '__main__':\n    read_eval_print_loop()",
        "detail": "lab.lab06.cardgame",
        "documentation": {}
    },
    {
        "label": "standard_cards",
        "kind": 5,
        "importPath": "lab.lab06.cards",
        "description": "lab.lab06.cards",
        "peekOfCode": "standard_cards = [\n\tTACard('Rachel, Bringer of Boba', 1200, 2200),\n\tTutorCard('RichRocks', 2200, 1100),\n\tTutorCard('Apoo, Answerer of Ed', 2400, 1000),\n\tTutorCard('Ratthew, King of the Rats', 2000, 1000),\n\tTutorCard('Hans, Compiler of Chaos', 1800, 1500),\n\tTACard('Cyrus, Cereal Consumer', 1500, 1500),\n\tTutorCard('jade, jabbering jester', 2299, 1001),\n\tTutorCard('Arnold, Description Here', 1600, 1600),\n\tTutorCard('Sophia, Soda Slayer', 1700, 1600),",
        "detail": "lab.lab06.cards",
        "documentation": {}
    },
    {
        "label": "standard_deck",
        "kind": 5,
        "importPath": "lab.lab06.cards",
        "description": "lab.lab06.cards",
        "peekOfCode": "standard_deck = Deck(standard_cards)\nplayer_deck = standard_deck.copy()\nopponent_deck = standard_deck.copy()",
        "detail": "lab.lab06.cards",
        "documentation": {}
    },
    {
        "label": "player_deck",
        "kind": 5,
        "importPath": "lab.lab06.cards",
        "description": "lab.lab06.cards",
        "peekOfCode": "player_deck = standard_deck.copy()\nopponent_deck = standard_deck.copy()",
        "detail": "lab.lab06.cards",
        "documentation": {}
    },
    {
        "label": "opponent_deck",
        "kind": 5,
        "importPath": "lab.lab06.cards",
        "description": "lab.lab06.cards",
        "peekOfCode": "opponent_deck = standard_deck.copy()",
        "detail": "lab.lab06.cards",
        "documentation": {}
    },
    {
        "label": "Card",
        "kind": 6,
        "importPath": "lab.lab06.classes",
        "description": "lab.lab06.classes",
        "peekOfCode": "class Card:\n    cardtype = 'Staff'\n    def __init__(self, name, attack, defense):\n        \"\"\"\n        Create a Card object with a name, attack,\n        and defense.\n        >>> staff_member = Card('staff', 400, 300)\n        >>> staff_member.name\n        'staff'\n        >>> staff_member.attack",
        "detail": "lab.lab06.classes",
        "documentation": {}
    },
    {
        "label": "Player",
        "kind": 6,
        "importPath": "lab.lab06.classes",
        "description": "lab.lab06.classes",
        "peekOfCode": "class Player:\n    def __init__(self, deck, name):\n        \"\"\"Initialize a Player object.\n        A Player starts the game by drawing 5 cards from their deck. Each turn,\n        a Player draws another card from the deck and chooses one to play.\n        >>> test_card = Card('test', 100, 100)\n        >>> test_deck = Deck([test_card.copy() for _ in range(6)])\n        >>> test_player = Player(test_deck, 'tester')\n        >>> len(test_deck.cards)\n        1",
        "detail": "lab.lab06.classes",
        "documentation": {}
    },
    {
        "label": "AICard",
        "kind": 6,
        "importPath": "lab.lab06.classes",
        "description": "lab.lab06.classes",
        "peekOfCode": "class AICard(Card):\n    cardtype = 'AI'\n    def effect(self, opponent_card, player, opponent):\n        \"\"\"\n        Add the top two cards of your deck to your hand via drawing.\n        Once you have finished writing your code for this problem,\n        set implemented to True so that the text is printed when\n        playing an AICard.\n        >>> from cards import *\n        >>> player1, player2 = Player(standard_deck.copy(), 'p1'), Player(standard_deck.copy(), 'p2')",
        "detail": "lab.lab06.classes",
        "documentation": {}
    },
    {
        "label": "TutorCard",
        "kind": 6,
        "importPath": "lab.lab06.classes",
        "description": "lab.lab06.classes",
        "peekOfCode": "class TutorCard(Card):\n    cardtype = 'Tutor'\n    def effect(self, opponent_card, player, opponent):\n        \"\"\"\n        Add a copy of the first card in your hand\n        to your hand, at the cost of losing the current\n        round. If there are no cards in hand, this card does\n        not add any cards, but still loses the round.  To\n        implement the second part of this effect, a Tutor\n        card's power should be less than all non-Tutor cards.",
        "detail": "lab.lab06.classes",
        "documentation": {}
    },
    {
        "label": "TACard",
        "kind": 6,
        "importPath": "lab.lab06.classes",
        "description": "lab.lab06.classes",
        "peekOfCode": "class TACard(Card):\n    cardtype = 'TA'\n    def effect(self, opponent_card, player, opponent, arg=None):\n        \"\"\"\n        Discard the card with the highest `power` in your hand,\n        and add the discarded card's attack and defense\n        to this card's own respective stats.\n        >>> from cards import *\n        >>> player1, player2 = Player(standard_deck.copy(), 'p1'), Player(standard_deck.copy(), 'p2')\n        >>> opponent_card = Card(\"other\", 500, 500)",
        "detail": "lab.lab06.classes",
        "documentation": {}
    },
    {
        "label": "InstructorCard",
        "kind": 6,
        "importPath": "lab.lab06.classes",
        "description": "lab.lab06.classes",
        "peekOfCode": "class InstructorCard(Card):\n    cardtype = 'Instructor'\n    def effect(self, opponent_card, player, opponent, arg=None):\n        \"\"\"\n        Survives multiple rounds, as long as it has a non-negative\n        attack or defense at the end of a round. At the beginning of the round,\n        its attack and defense are permanently reduced by 1000 each.\n        If this card would survive, it is added back to the hand.\n        >>> from cards import *\n        >>> player1, player2 = Player(standard_deck.copy(), 'p1'), Player(standard_deck.copy(), 'p2')",
        "detail": "lab.lab06.classes",
        "documentation": {}
    },
    {
        "label": "Deck",
        "kind": 6,
        "importPath": "lab.lab06.classes",
        "description": "lab.lab06.classes",
        "peekOfCode": "class Deck:\n    def __init__(self, cards):\n        \"\"\"\n        With a list of cards as input, create a deck.\n        This deck should keep track of the cards it contains, and\n        we should be able to draw from the deck, taking a random\n        card out of it.\n        \"\"\"\n        self.cards = cards\n    def draw(self):",
        "detail": "lab.lab06.classes",
        "documentation": {}
    },
    {
        "label": "Game",
        "kind": 6,
        "importPath": "lab.lab06.classes",
        "description": "lab.lab06.classes",
        "peekOfCode": "class Game:\n    win_score = 8\n    def __init__(self, player1, player2):\n        \"\"\"\n        Initialize a game of Magic: the Lambda-ing.\n        \"\"\"\n        self.player1, self.player2 = player1, player2\n        self.p1_score = 0\n        self.p2_score = 0\n    def play_round(self, p1_card, p2_card):",
        "detail": "lab.lab06.classes",
        "documentation": {}
    },
    {
        "label": "ExclusionChecker",
        "kind": 6,
        "importPath": "lab.lab06.construct_check",
        "description": "lab.lab06.construct_check",
        "peekOfCode": "class ExclusionChecker(NodeVisitor):\n    \"\"\"An AST visitor that checks that certain constructs are excluded from\n    parts of a program.  ExclusionChecker(EXC) checks that AST node types\n    whose names are in the sequence or set EXC are not present.  Its check\n    method visits nodes in a given function of a source file checking that the\n    indicated node types are not used.\"\"\"\n    def __init__(self, disallow=()):\n        \"\"\"DISALLOW is the initial default list of disallowed\n        node-type names.\"\"\"\n        self._disallow = set(disallow)",
        "detail": "lab.lab06.construct_check",
        "documentation": {}
    },
    {
        "label": "check",
        "kind": 2,
        "importPath": "lab.lab06.construct_check",
        "description": "lab.lab06.construct_check",
        "peekOfCode": "def check(source_file, checked_funcs, disallow, source=None):\n    \"\"\"Checks that AST nodes whose type names are present in DISALLOW\n    (an object supporting 'in') are not present in the function(s) named\n    CHECKED_FUNCS in SOURCE.  By default, SOURCE is the contents of the\n    file SOURCE_FILE.  CHECKED_FUNCS is either a string (indicating a single\n    name) or an object of some other type that supports 'in'. CHECKED_FUNCS\n    may contain __main__ to indicate an entire  module. Prints reports of\n    each prohibited node and returns True iff none are found.\n    See ast.__dir__() for AST type names.  The special node name 'Recursion'\n    checks for overtly recursive calls (i.e., calls of the form NAME(...) where",
        "detail": "lab.lab06.construct_check",
        "documentation": {}
    },
    {
        "label": "_NAMES",
        "kind": 5,
        "importPath": "lab.lab06.construct_check",
        "description": "lab.lab06.construct_check",
        "peekOfCode": "_NAMES = {\n    'Add': '+',\n    'And': 'and',\n    'Assert': 'assert',\n    'Assign': '=',\n    'AnnAssign': '=',\n    'AugAssign': 'op=',\n    'BitAnd': '&',\n    'BitOr': '|',\n    'BitXor': '^',",
        "detail": "lab.lab06.construct_check",
        "documentation": {}
    },
    {
        "label": "Transaction",
        "kind": 6,
        "importPath": "lab.lab06.lab06",
        "description": "lab.lab06.lab06",
        "peekOfCode": "class Transaction:\n    def __init__(self, id, before, after):\n        self.id = id\n        self.before = before\n        self.after = after\n    def changed(self):\n        \"\"\"Return whether the transaction resulted in a changed balance.\"\"\"\n        \"*** YOUR CODE HERE ***\"\n        return self.before != self.after\n    def report(self):",
        "detail": "lab.lab06.lab06",
        "documentation": {}
    },
    {
        "label": "Account",
        "kind": 6,
        "importPath": "lab.lab06.lab06",
        "description": "lab.lab06.lab06",
        "peekOfCode": "class Account:\n    \"\"\"A bank account that tracks its transaction history.\n    >>> a = Account('Eric')\n    >>> a.deposit(100)    # Transaction 0 for a\n    100\n    >>> b = Account('Erica')\n    >>> a.withdraw(30)    # Transaction 1 for a\n    70\n    >>> a.deposit(10)     # Transaction 2 for a\n    80",
        "detail": "lab.lab06.lab06",
        "documentation": {}
    },
    {
        "label": "Email",
        "kind": 6,
        "importPath": "lab.lab06.lab06",
        "description": "lab.lab06.lab06",
        "peekOfCode": "class Email:\n    \"\"\"An email has the following instance attributes:\n        msg (str): the contents of the message\n        sender (Client): the client that sent the email\n        recipient_name (str): the name of the recipient (another client)\n    \"\"\"\n    def __init__(self, msg, sender, recipient_name):\n        self.msg = msg\n        self.sender = sender\n        self.recipient_name = recipient_name",
        "detail": "lab.lab06.lab06",
        "documentation": {}
    },
    {
        "label": "Server",
        "kind": 6,
        "importPath": "lab.lab06.lab06",
        "description": "lab.lab06.lab06",
        "peekOfCode": "class Server:\n    \"\"\"Each Server has one instance attribute called clients that is a\n    dictionary from client names to client objects.\n    \"\"\"\n    def __init__(self):\n        self.clients = {}\n    def send(self, email):\n        \"\"\"Append the email to the inbox of the client it is addressed to.\"\"\"\n        self.clients[email.recipient_name].inbox.append(email)\n    def register_client(self, client):",
        "detail": "lab.lab06.lab06",
        "documentation": {}
    },
    {
        "label": "Client",
        "kind": 6,
        "importPath": "lab.lab06.lab06",
        "description": "lab.lab06.lab06",
        "peekOfCode": "class Client:\n    \"\"\"A client has a server, a name (str), and an inbox (list).\n    >>> s = Server()\n    >>> a = Client(s, 'Alice')\n    >>> b = Client(s, 'Bob')\n    >>> a.compose('Hello, World!', 'Bob')\n    >>> b.inbox[0].msg\n    'Hello, World!'\n    >>> a.compose('CS 61A Rocks!', 'Bob')\n    >>> len(b.inbox)",
        "detail": "lab.lab06.lab06",
        "documentation": {}
    },
    {
        "label": "ChangeMachine",
        "kind": 6,
        "importPath": "lab.lab06.lab06",
        "description": "lab.lab06.lab06",
        "peekOfCode": "class ChangeMachine:\n    \"\"\"A change machine holds a certain number of coins, initially all pennies.\n    The change method adds a single coin of some denomination X and returns a\n    list of coins that sums to X. The machine prefers to return the smallest\n    coins available. The total value in the machine never changes, and it can\n    always make change for any coin (perhaps by returning the coin passed in).\n    The coins attribute is a dictionary with keys that are positive integer\n    denominations and values that are positive integer coin counts.\n    >>> m = ChangeMachine(2)\n    >>> m.coins == {1: 2}",
        "detail": "lab.lab06.lab06",
        "documentation": {}
    },
    {
        "label": "make_change",
        "kind": 2,
        "importPath": "lab.lab06.lab06",
        "description": "lab.lab06.lab06",
        "peekOfCode": "def make_change(amount, coins):\n    \"\"\"Return a list of coins that sum to amount, preferring the smallest coins\n    available and placing the smallest coins first in the returned list.\n    The coins argument is a dictionary with keys that are positive integer\n    denominations and values that are positive integer coin counts.\n    >>> make_change(2, {2: 1})\n    [2]\n    >>> make_change(2, {1: 2, 2: 1})\n    [1, 1]\n    >>> make_change(4, {1: 2, 2: 1})",
        "detail": "lab.lab06.lab06",
        "documentation": {}
    },
    {
        "label": "remove_one",
        "kind": 2,
        "importPath": "lab.lab06.lab06",
        "description": "lab.lab06.lab06",
        "peekOfCode": "def remove_one(coins, coin):\n    \"\"\"Remove one coin from a dictionary of coins. Return a new dictionary,\n    leaving the original dictionary coins unchanged.\n    >>> coins = {2: 5, 3: 2, 6: 1}\n    >>> remove_one(coins, 2) == {2: 4, 3: 2, 6: 1}\n    True\n    >>> remove_one(coins, 6) == {2: 5, 3: 2}\n    True\n    >>> coins == {2: 5, 3: 2, 6: 1} # Unchanged\n    True",
        "detail": "lab.lab06.lab06",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "lab.lab07.tests.inheritance-abc",
        "description": "lab.lab07.tests.inheritance-abc",
        "peekOfCode": "test = {\n  'name': 'Inheritance ABCs',\n  'points': 0,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> class A:\n          ...   x, y = 0, 0",
        "detail": "lab.lab07.tests.inheritance-abc",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "lab.lab07.tests.link",
        "description": "lab.lab07.tests.link",
        "peekOfCode": "test = {\n  'name': 'Link',\n  'points': 0,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> from lab08 import *\n          >>> link = Link(1000)",
        "detail": "lab.lab07.tests.link",
        "documentation": {}
    },
    {
        "label": "Account",
        "kind": 6,
        "importPath": "lab.lab07.lab07",
        "description": "lab.lab07.lab07",
        "peekOfCode": "class Account:\n    \"\"\"An account has a balance and a holder.\n    >>> a = Account('John')\n    >>> a.deposit(10)\n    10\n    >>> a.balance\n    10\n    >>> a.interest\n    0.02\n    >>> a.time_to_retire(10.25)  # 10 -> 10.2 -> 10.404",
        "detail": "lab.lab07.lab07",
        "documentation": {}
    },
    {
        "label": "FreeChecking",
        "kind": 6,
        "importPath": "lab.lab07.lab07",
        "description": "lab.lab07.lab07",
        "peekOfCode": "class FreeChecking(Account):\n    \"\"\"A bank account that charges for withdrawals, but the first two are free!\n    >>> ch = FreeChecking('Jack')\n    >>> ch.balance = 20\n    >>> ch.withdraw(100)  # First one's free. Still counts as a free withdrawal even though it was unsuccessful\n    'Insufficient funds'\n    >>> ch.withdraw(3)    # Second withdrawal is also free\n    17\n    >>> ch.balance\n    17",
        "detail": "lab.lab07.lab07",
        "documentation": {}
    },
    {
        "label": "Link",
        "kind": 6,
        "importPath": "lab.lab07.lab07",
        "description": "lab.lab07.lab07",
        "peekOfCode": "class Link:\n    \"\"\"A linked list.\n    >>> s = Link(1)\n    >>> s.first\n    1\n    >>> s.rest is Link.empty\n    True\n    >>> s = Link(2, Link(3, Link(4)))\n    >>> s.first = 5\n    >>> s.rest.first = 6",
        "detail": "lab.lab07.lab07",
        "documentation": {}
    },
    {
        "label": "duplicate_link",
        "kind": 2,
        "importPath": "lab.lab07.lab07",
        "description": "lab.lab07.lab07",
        "peekOfCode": "def duplicate_link(s, val):\n    \"\"\"Mutates s so that each element equal to val is followed by another val.\n    >>> x = Link(5, Link(4, Link(5)))\n    >>> duplicate_link(x, 5)\n    >>> x\n    Link(5, Link(5, Link(4, Link(5, Link(5)))))\n    >>> y = Link(2, Link(4, Link(6, Link(8))))\n    >>> duplicate_link(y, 10)\n    >>> y\n    Link(2, Link(4, Link(6, Link(8))))",
        "detail": "lab.lab07.lab07",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "lab.lab08.tests.trees-wwpd",
        "description": "lab.lab08.tests.trees-wwpd",
        "peekOfCode": "test = {\n  'name': 'Trees',\n  'points': 0,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> t = Tree(1, Tree(2)) # Enter Function if you believe the answer is <function ...>, Error if it errors, and Nothing if nothing is displayed.\n          Error",
        "detail": "lab.lab08.tests.trees-wwpd",
        "documentation": {}
    },
    {
        "label": "ExclusionChecker",
        "kind": 6,
        "importPath": "lab.lab08.construct_check",
        "description": "lab.lab08.construct_check",
        "peekOfCode": "class ExclusionChecker(NodeVisitor):\n    \"\"\"An AST visitor that checks that certain constructs are excluded from\n    parts of a program.  ExclusionChecker(EXC) checks that AST node types\n    whose names are in the sequence or set EXC are not present.  Its check\n    method visits nodes in a given function of a source file checking that the\n    indicated node types are not used.\"\"\"\n    def __init__(self, disallow=()):\n        \"\"\"DISALLOW is the initial default list of disallowed\n        node-type names.\"\"\"\n        self._disallow = set(disallow)",
        "detail": "lab.lab08.construct_check",
        "documentation": {}
    },
    {
        "label": "check",
        "kind": 2,
        "importPath": "lab.lab08.construct_check",
        "description": "lab.lab08.construct_check",
        "peekOfCode": "def check(source_file, checked_funcs, disallow, source=None):\n    \"\"\"Checks that AST nodes whose type names are present in DISALLOW\n    (an object supporting 'in') are not present in the function(s) named\n    CHECKED_FUNCS in SOURCE.  By default, SOURCE is the contents of the\n    file SOURCE_FILE.  CHECKED_FUNCS is either a string (indicating a single\n    name) or an object of some other type that supports 'in'. CHECKED_FUNCS\n    may contain __main__ to indicate an entire  module. Prints reports of\n    each prohibited node and returns True iff none are found.\n    See ast.__dir__() for AST type names.  The special node name 'Recursion'\n    checks for overtly recursive calls (i.e., calls of the form NAME(...) where",
        "detail": "lab.lab08.construct_check",
        "documentation": {}
    },
    {
        "label": "_NAMES",
        "kind": 5,
        "importPath": "lab.lab08.construct_check",
        "description": "lab.lab08.construct_check",
        "peekOfCode": "_NAMES = {\n    'Add': '+',\n    'And': 'and',\n    'Assert': 'assert',\n    'Assign': '=',\n    'AnnAssign': '=',\n    'AugAssign': 'op=',\n    'BitAnd': '&',\n    'BitOr': '|',\n    'BitXor': '^',",
        "detail": "lab.lab08.construct_check",
        "documentation": {}
    },
    {
        "label": "Tree",
        "kind": 6,
        "importPath": "lab.lab08.lab08",
        "description": "lab.lab08.lab08",
        "peekOfCode": "class Tree:\n    \"\"\"\n    >>> t = Tree(3, [Tree(2, [Tree(5)]), Tree(4)])\n    >>> t.label\n    3\n    >>> t.branches[0].label\n    2\n    >>> t.branches[1].is_leaf()\n    True\n    \"\"\"",
        "detail": "lab.lab08.lab08",
        "documentation": {}
    },
    {
        "label": "cumulative_mul",
        "kind": 2,
        "importPath": "lab.lab08.lab08",
        "description": "lab.lab08.lab08",
        "peekOfCode": "def cumulative_mul(t):\n    \"\"\"Mutates t so that each node's label becomes the product of its own\n    label and all labels in the corresponding subtree rooted at t.\n    >>> t = Tree(1, [Tree(3, [Tree(5)]), Tree(7)])\n    >>> cumulative_mul(t)\n    >>> t\n    Tree(105, [Tree(15, [Tree(5)]), Tree(7)])\n    >>> otherTree = Tree(2, [Tree(1, [Tree(3), Tree(4), Tree(5)]), Tree(6, [Tree(7)])])\n    >>> cumulative_mul(otherTree)\n    >>> otherTree",
        "detail": "lab.lab08.lab08",
        "documentation": {}
    },
    {
        "label": "prune_small",
        "kind": 2,
        "importPath": "lab.lab08.lab08",
        "description": "lab.lab08.lab08",
        "peekOfCode": "def prune_small(t, n):\n    \"\"\"Prune the tree mutatively, keeping only the n branches\n    of each node with the smallest labels.\n    while len(t.branches) > n:\n        largest = max(t.branches,key = lambda b:b.lable)\n        t.branches.remove(largest)\n    for branch in t.branches:\n        prune_small(branch, n)\n    >>> t1 = Tree(6)\n    >>> prune_small(t1, 2)",
        "detail": "lab.lab08.lab08",
        "documentation": {}
    },
    {
        "label": "delete",
        "kind": 2,
        "importPath": "lab.lab08.lab08",
        "description": "lab.lab08.lab08",
        "peekOfCode": "def delete(t, x):\n    \"\"\"Remove all nodes labeled x below the root within Tree t. When a non-leaf\n    node is deleted, the deleted node's children become children of its parent.\n    The root node will never be removed.\n    new_branch = []\n    for branch in t.branches:\n        delete(branch, x)\n        if branch.lable == x:\n            new_branch.extend(branch.branches)\n        else:",
        "detail": "lab.lab08.lab08",
        "documentation": {}
    },
    {
        "label": "BlockGrammar",
        "kind": 6,
        "importPath": "lab.lab09.editor.libraries.mistune",
        "description": "lab.lab09.editor.libraries.mistune",
        "peekOfCode": "class BlockGrammar(object):\n    \"\"\"Grammars for block level tokens.\"\"\"\n    def_links = re.compile(\n        r'^ *\\[([^^\\]]+)\\]: *'  # [key]:\n        r'<?([^\\s>]+)>?'  # <link> or link\n        r'(?: +[\"(]([^\\n]+)[\")])? *(?:\\n+|$)'\n    )\n    def_footnotes = re.compile(\n        r'^\\[\\^([^\\]]+)\\]: *('\n        r'[^\\n]*(?:\\n+|$)'  # [^key]:",
        "detail": "lab.lab09.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "BlockLexer",
        "kind": 6,
        "importPath": "lab.lab09.editor.libraries.mistune",
        "description": "lab.lab09.editor.libraries.mistune",
        "peekOfCode": "class BlockLexer(object):\n    \"\"\"Block level lexer for block grammars.\"\"\"\n    grammar_class = BlockGrammar\n    default_rules = [\n        'newline', 'hrule', 'block_code', 'fences', 'heading',\n        'nptable', 'lheading', 'block_quote',\n        'list_block', 'block_html', 'def_links',\n        'def_footnotes', 'table', 'paragraph', 'text'\n    ]\n    list_rules = (",
        "detail": "lab.lab09.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "InlineGrammar",
        "kind": 6,
        "importPath": "lab.lab09.editor.libraries.mistune",
        "description": "lab.lab09.editor.libraries.mistune",
        "peekOfCode": "class InlineGrammar(object):\n    \"\"\"Grammars for inline level tokens.\"\"\"\n    escape = re.compile(r'^\\\\([\\\\`*{}\\[\\]()#+\\-.!_>~|])')  # \\* \\+ \\! ....\n    inline_html = re.compile(\n        r'^(?:%s|%s|%s)' % (\n            r'<!--[\\s\\S]*?-->',\n            r'<(\\w+%s)((?:%s)*?)\\s*>([\\s\\S]*?)<\\/\\1>' % (\n                _valid_end, _valid_attr),\n            r'<\\w+%s(?:%s)*?\\s*\\/?>' % (_valid_end, _valid_attr),\n        )",
        "detail": "lab.lab09.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "InlineLexer",
        "kind": 6,
        "importPath": "lab.lab09.editor.libraries.mistune",
        "description": "lab.lab09.editor.libraries.mistune",
        "peekOfCode": "class InlineLexer(object):\n    \"\"\"Inline level lexer for inline grammars.\"\"\"\n    grammar_class = InlineGrammar\n    default_rules = [\n        'escape', 'inline_html', 'autolink', 'url',\n        'footnote', 'link', 'reflink', 'nolink',\n        'double_emphasis', 'emphasis', 'code',\n        'linebreak', 'strikethrough', 'text',\n    ]\n    inline_html_rules = [",
        "detail": "lab.lab09.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "Renderer",
        "kind": 6,
        "importPath": "lab.lab09.editor.libraries.mistune",
        "description": "lab.lab09.editor.libraries.mistune",
        "peekOfCode": "class Renderer(object):\n    \"\"\"The default HTML renderer for rendering Markdown.\n    \"\"\"\n    def __init__(self, **kwargs):\n        self.options = kwargs\n    def placeholder(self):\n        \"\"\"Returns the default, empty output value for the renderer.\n        All renderer methods use the '+=' operator to append to this value.\n        Default is a string so rendering HTML can build up a result string with\n        the rendered Markdown.",
        "detail": "lab.lab09.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "Markdown",
        "kind": 6,
        "importPath": "lab.lab09.editor.libraries.mistune",
        "description": "lab.lab09.editor.libraries.mistune",
        "peekOfCode": "class Markdown(object):\n    \"\"\"The Markdown parser.\n    :param renderer: An instance of ``Renderer``.\n    :param inline: An inline lexer class or instance.\n    :param block: A block lexer class or instance.\n    \"\"\"\n    def __init__(self, renderer=None, inline=None, block=None, **kwargs):\n        if not renderer:\n            renderer = Renderer(**kwargs)\n        else:",
        "detail": "lab.lab09.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "escape",
        "kind": 2,
        "importPath": "lab.lab09.editor.libraries.mistune",
        "description": "lab.lab09.editor.libraries.mistune",
        "peekOfCode": "def escape(text, quote=False, smart_amp=True):\n    \"\"\"Replace special characters \"&\", \"<\" and \">\" to HTML-safe sequences.\n    The original cgi.escape will always escape \"&\", but you can control\n    this one for a smart escape amp.\n    :param quote: if set to True, \" and ' will be escaped.\n    :param smart_amp: if set to False, & will always be escaped.\n    \"\"\"\n    if smart_amp:\n        text = _escape_pattern.sub('&amp;', text)\n    else:",
        "detail": "lab.lab09.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "escape_link",
        "kind": 2,
        "importPath": "lab.lab09.editor.libraries.mistune",
        "description": "lab.lab09.editor.libraries.mistune",
        "peekOfCode": "def escape_link(url):\n    \"\"\"Remove dangerous URL schemes like javascript: and escape afterwards.\"\"\"\n    lower_url = url.lower().strip('\\x00\\x1a \\n\\r\\t')\n    for scheme in _scheme_blacklist:\n        if re.sub(r'[^A-Za-z0-9\\/:]+', '', lower_url).startswith(scheme):\n            return ''\n    return escape(url, quote=True, smart_amp=False)\ndef preprocessing(text, tab=4):\n    text = _newline_pattern.sub('\\n', text)\n    text = text.expandtabs(tab)",
        "detail": "lab.lab09.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "preprocessing",
        "kind": 2,
        "importPath": "lab.lab09.editor.libraries.mistune",
        "description": "lab.lab09.editor.libraries.mistune",
        "peekOfCode": "def preprocessing(text, tab=4):\n    text = _newline_pattern.sub('\\n', text)\n    text = text.expandtabs(tab)\n    text = text.replace('\\u2424', '\\n')\n    pattern = re.compile(r'^ +$', re.M)\n    return pattern.sub('', text)\nclass BlockGrammar(object):\n    \"\"\"Grammars for block level tokens.\"\"\"\n    def_links = re.compile(\n        r'^ *\\[([^^\\]]+)\\]: *'  # [key]:",
        "detail": "lab.lab09.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "markdown",
        "kind": 2,
        "importPath": "lab.lab09.editor.libraries.mistune",
        "description": "lab.lab09.editor.libraries.mistune",
        "peekOfCode": "def markdown(text, escape=True, **kwargs):\n    \"\"\"Render markdown formatted text to html.\n    :param text: markdown formatted text content.\n    :param escape: if set to False, all html tags will not be escaped.\n    :param use_xhtml: output with xhtml tags.\n    :param hard_wrap: if set to True, it will use the GFM line breaks feature.\n    :param parse_block_html: parse text only in block level html.\n    :param parse_inline_html: parse text only in inline level html.\n    \"\"\"\n    return Markdown(escape=escape, **kwargs)(text)",
        "detail": "lab.lab09.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "lab.lab09.editor.libraries.mistune",
        "description": "lab.lab09.editor.libraries.mistune",
        "peekOfCode": "__version__ = '0.8.4'\n__author__ = 'Hsiaoming Yang <me@lepture.com>'\n__all__ = [\n    'BlockGrammar', 'BlockLexer',\n    'InlineGrammar', 'InlineLexer',\n    'Renderer', 'Markdown',\n    'markdown', 'escape',\n]\n_key_pattern = re.compile(r'\\s+')\n_nonalpha_pattern = re.compile(r'\\W')",
        "detail": "lab.lab09.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "__author__",
        "kind": 5,
        "importPath": "lab.lab09.editor.libraries.mistune",
        "description": "lab.lab09.editor.libraries.mistune",
        "peekOfCode": "__author__ = 'Hsiaoming Yang <me@lepture.com>'\n__all__ = [\n    'BlockGrammar', 'BlockLexer',\n    'InlineGrammar', 'InlineLexer',\n    'Renderer', 'Markdown',\n    'markdown', 'escape',\n]\n_key_pattern = re.compile(r'\\s+')\n_nonalpha_pattern = re.compile(r'\\W')\n_escape_pattern = re.compile(r'&(?!#?\\w+;)')",
        "detail": "lab.lab09.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "lab.lab09.editor.libraries.mistune",
        "description": "lab.lab09.editor.libraries.mistune",
        "peekOfCode": "__all__ = [\n    'BlockGrammar', 'BlockLexer',\n    'InlineGrammar', 'InlineLexer',\n    'Renderer', 'Markdown',\n    'markdown', 'escape',\n]\n_key_pattern = re.compile(r'\\s+')\n_nonalpha_pattern = re.compile(r'\\W')\n_escape_pattern = re.compile(r'&(?!#?\\w+;)')\n_newline_pattern = re.compile(r'\\r\\n|\\r')",
        "detail": "lab.lab09.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "_key_pattern",
        "kind": 5,
        "importPath": "lab.lab09.editor.libraries.mistune",
        "description": "lab.lab09.editor.libraries.mistune",
        "peekOfCode": "_key_pattern = re.compile(r'\\s+')\n_nonalpha_pattern = re.compile(r'\\W')\n_escape_pattern = re.compile(r'&(?!#?\\w+;)')\n_newline_pattern = re.compile(r'\\r\\n|\\r')\n_block_quote_leading_pattern = re.compile(r'^ *> ?', flags=re.M)\n_block_code_leading_pattern = re.compile(r'^ {4}', re.M)\n_inline_tags = [\n    'a', 'em', 'strong', 'small', 's', 'cite', 'q', 'dfn', 'abbr', 'data',\n    'time', 'code', 'var', 'samp', 'kbd', 'sub', 'sup', 'i', 'b', 'u', 'mark',\n    'ruby', 'rt', 'rp', 'bdi', 'bdo', 'span', 'br', 'wbr', 'ins', 'del',",
        "detail": "lab.lab09.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "_nonalpha_pattern",
        "kind": 5,
        "importPath": "lab.lab09.editor.libraries.mistune",
        "description": "lab.lab09.editor.libraries.mistune",
        "peekOfCode": "_nonalpha_pattern = re.compile(r'\\W')\n_escape_pattern = re.compile(r'&(?!#?\\w+;)')\n_newline_pattern = re.compile(r'\\r\\n|\\r')\n_block_quote_leading_pattern = re.compile(r'^ *> ?', flags=re.M)\n_block_code_leading_pattern = re.compile(r'^ {4}', re.M)\n_inline_tags = [\n    'a', 'em', 'strong', 'small', 's', 'cite', 'q', 'dfn', 'abbr', 'data',\n    'time', 'code', 'var', 'samp', 'kbd', 'sub', 'sup', 'i', 'b', 'u', 'mark',\n    'ruby', 'rt', 'rp', 'bdi', 'bdo', 'span', 'br', 'wbr', 'ins', 'del',\n    'img', 'font',",
        "detail": "lab.lab09.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "_escape_pattern",
        "kind": 5,
        "importPath": "lab.lab09.editor.libraries.mistune",
        "description": "lab.lab09.editor.libraries.mistune",
        "peekOfCode": "_escape_pattern = re.compile(r'&(?!#?\\w+;)')\n_newline_pattern = re.compile(r'\\r\\n|\\r')\n_block_quote_leading_pattern = re.compile(r'^ *> ?', flags=re.M)\n_block_code_leading_pattern = re.compile(r'^ {4}', re.M)\n_inline_tags = [\n    'a', 'em', 'strong', 'small', 's', 'cite', 'q', 'dfn', 'abbr', 'data',\n    'time', 'code', 'var', 'samp', 'kbd', 'sub', 'sup', 'i', 'b', 'u', 'mark',\n    'ruby', 'rt', 'rp', 'bdi', 'bdo', 'span', 'br', 'wbr', 'ins', 'del',\n    'img', 'font',\n]",
        "detail": "lab.lab09.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "_newline_pattern",
        "kind": 5,
        "importPath": "lab.lab09.editor.libraries.mistune",
        "description": "lab.lab09.editor.libraries.mistune",
        "peekOfCode": "_newline_pattern = re.compile(r'\\r\\n|\\r')\n_block_quote_leading_pattern = re.compile(r'^ *> ?', flags=re.M)\n_block_code_leading_pattern = re.compile(r'^ {4}', re.M)\n_inline_tags = [\n    'a', 'em', 'strong', 'small', 's', 'cite', 'q', 'dfn', 'abbr', 'data',\n    'time', 'code', 'var', 'samp', 'kbd', 'sub', 'sup', 'i', 'b', 'u', 'mark',\n    'ruby', 'rt', 'rp', 'bdi', 'bdo', 'span', 'br', 'wbr', 'ins', 'del',\n    'img', 'font',\n]\n_pre_tags = ['pre', 'script', 'style']",
        "detail": "lab.lab09.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "_block_quote_leading_pattern",
        "kind": 5,
        "importPath": "lab.lab09.editor.libraries.mistune",
        "description": "lab.lab09.editor.libraries.mistune",
        "peekOfCode": "_block_quote_leading_pattern = re.compile(r'^ *> ?', flags=re.M)\n_block_code_leading_pattern = re.compile(r'^ {4}', re.M)\n_inline_tags = [\n    'a', 'em', 'strong', 'small', 's', 'cite', 'q', 'dfn', 'abbr', 'data',\n    'time', 'code', 'var', 'samp', 'kbd', 'sub', 'sup', 'i', 'b', 'u', 'mark',\n    'ruby', 'rt', 'rp', 'bdi', 'bdo', 'span', 'br', 'wbr', 'ins', 'del',\n    'img', 'font',\n]\n_pre_tags = ['pre', 'script', 'style']\n_valid_end = r'(?!:/|[^\\w\\s@]*@)\\b'",
        "detail": "lab.lab09.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "_block_code_leading_pattern",
        "kind": 5,
        "importPath": "lab.lab09.editor.libraries.mistune",
        "description": "lab.lab09.editor.libraries.mistune",
        "peekOfCode": "_block_code_leading_pattern = re.compile(r'^ {4}', re.M)\n_inline_tags = [\n    'a', 'em', 'strong', 'small', 's', 'cite', 'q', 'dfn', 'abbr', 'data',\n    'time', 'code', 'var', 'samp', 'kbd', 'sub', 'sup', 'i', 'b', 'u', 'mark',\n    'ruby', 'rt', 'rp', 'bdi', 'bdo', 'span', 'br', 'wbr', 'ins', 'del',\n    'img', 'font',\n]\n_pre_tags = ['pre', 'script', 'style']\n_valid_end = r'(?!:/|[^\\w\\s@]*@)\\b'\n_valid_attr = r'''\\s*[a-zA-Z\\-](?:\\s*\\=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">]+))?'''",
        "detail": "lab.lab09.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "_inline_tags",
        "kind": 5,
        "importPath": "lab.lab09.editor.libraries.mistune",
        "description": "lab.lab09.editor.libraries.mistune",
        "peekOfCode": "_inline_tags = [\n    'a', 'em', 'strong', 'small', 's', 'cite', 'q', 'dfn', 'abbr', 'data',\n    'time', 'code', 'var', 'samp', 'kbd', 'sub', 'sup', 'i', 'b', 'u', 'mark',\n    'ruby', 'rt', 'rp', 'bdi', 'bdo', 'span', 'br', 'wbr', 'ins', 'del',\n    'img', 'font',\n]\n_pre_tags = ['pre', 'script', 'style']\n_valid_end = r'(?!:/|[^\\w\\s@]*@)\\b'\n_valid_attr = r'''\\s*[a-zA-Z\\-](?:\\s*\\=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">]+))?'''\n_block_tag = r'(?!(?:%s)\\b)\\w+%s' % ('|'.join(_inline_tags), _valid_end)",
        "detail": "lab.lab09.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "_pre_tags",
        "kind": 5,
        "importPath": "lab.lab09.editor.libraries.mistune",
        "description": "lab.lab09.editor.libraries.mistune",
        "peekOfCode": "_pre_tags = ['pre', 'script', 'style']\n_valid_end = r'(?!:/|[^\\w\\s@]*@)\\b'\n_valid_attr = r'''\\s*[a-zA-Z\\-](?:\\s*\\=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">]+))?'''\n_block_tag = r'(?!(?:%s)\\b)\\w+%s' % ('|'.join(_inline_tags), _valid_end)\n_scheme_blacklist = ('javascript:', 'vbscript:')\ndef _pure_pattern(regex):\n    pattern = regex.pattern\n    if pattern.startswith('^'):\n        pattern = pattern[1:]\n    return pattern",
        "detail": "lab.lab09.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "_valid_end",
        "kind": 5,
        "importPath": "lab.lab09.editor.libraries.mistune",
        "description": "lab.lab09.editor.libraries.mistune",
        "peekOfCode": "_valid_end = r'(?!:/|[^\\w\\s@]*@)\\b'\n_valid_attr = r'''\\s*[a-zA-Z\\-](?:\\s*\\=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">]+))?'''\n_block_tag = r'(?!(?:%s)\\b)\\w+%s' % ('|'.join(_inline_tags), _valid_end)\n_scheme_blacklist = ('javascript:', 'vbscript:')\ndef _pure_pattern(regex):\n    pattern = regex.pattern\n    if pattern.startswith('^'):\n        pattern = pattern[1:]\n    return pattern\ndef _keyify(key):",
        "detail": "lab.lab09.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "_valid_attr",
        "kind": 5,
        "importPath": "lab.lab09.editor.libraries.mistune",
        "description": "lab.lab09.editor.libraries.mistune",
        "peekOfCode": "_valid_attr = r'''\\s*[a-zA-Z\\-](?:\\s*\\=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">]+))?'''\n_block_tag = r'(?!(?:%s)\\b)\\w+%s' % ('|'.join(_inline_tags), _valid_end)\n_scheme_blacklist = ('javascript:', 'vbscript:')\ndef _pure_pattern(regex):\n    pattern = regex.pattern\n    if pattern.startswith('^'):\n        pattern = pattern[1:]\n    return pattern\ndef _keyify(key):\n    key = escape(key.lower(), quote=True)",
        "detail": "lab.lab09.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "_block_tag",
        "kind": 5,
        "importPath": "lab.lab09.editor.libraries.mistune",
        "description": "lab.lab09.editor.libraries.mistune",
        "peekOfCode": "_block_tag = r'(?!(?:%s)\\b)\\w+%s' % ('|'.join(_inline_tags), _valid_end)\n_scheme_blacklist = ('javascript:', 'vbscript:')\ndef _pure_pattern(regex):\n    pattern = regex.pattern\n    if pattern.startswith('^'):\n        pattern = pattern[1:]\n    return pattern\ndef _keyify(key):\n    key = escape(key.lower(), quote=True)\n    return _key_pattern.sub(' ', key)",
        "detail": "lab.lab09.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "_scheme_blacklist",
        "kind": 5,
        "importPath": "lab.lab09.editor.libraries.mistune",
        "description": "lab.lab09.editor.libraries.mistune",
        "peekOfCode": "_scheme_blacklist = ('javascript:', 'vbscript:')\ndef _pure_pattern(regex):\n    pattern = regex.pattern\n    if pattern.startswith('^'):\n        pattern = pattern[1:]\n    return pattern\ndef _keyify(key):\n    key = escape(key.lower(), quote=True)\n    return _key_pattern.sub(' ', key)\ndef escape(text, quote=False, smart_amp=True):",
        "detail": "lab.lab09.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "Add",
        "kind": 6,
        "importPath": "lab.lab09.editor.arithmetic",
        "description": "lab.lab09.editor.arithmetic",
        "peekOfCode": "class Add(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame):\n        assert_all_numbers(operands)\n        return Number(sum(operand.value for operand in operands))\n@global_attr(\"-\")\nclass Subtract(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame):\n        verify_min_callable_length(self, 1, len(operands))\n        assert_all_numbers(operands)\n        if len(operands) == 1:",
        "detail": "lab.lab09.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "Subtract",
        "kind": 6,
        "importPath": "lab.lab09.editor.arithmetic",
        "description": "lab.lab09.editor.arithmetic",
        "peekOfCode": "class Subtract(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame):\n        verify_min_callable_length(self, 1, len(operands))\n        assert_all_numbers(operands)\n        if len(operands) == 1:\n            return Number(-operands[0].value)\n        return Number(operands[0].value - sum(operand.value for operand in operands[1:]))\n@global_attr(\"*\")\nclass Multiply(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame):",
        "detail": "lab.lab09.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "Multiply",
        "kind": 6,
        "importPath": "lab.lab09.editor.arithmetic",
        "description": "lab.lab09.editor.arithmetic",
        "peekOfCode": "class Multiply(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame):\n        assert_all_numbers(operands)\n        out = 1\n        for operand in operands:\n            out *= operand.value\n        return Number(out)\n@global_attr(\"/\")\nclass Divide(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:",
        "detail": "lab.lab09.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "Divide",
        "kind": 6,
        "importPath": "lab.lab09.editor.arithmetic",
        "description": "lab.lab09.editor.arithmetic",
        "peekOfCode": "class Divide(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_min_callable_length(self, 1, len(operands))\n        assert_all_numbers(operands)\n        if len(operands) == 1:\n            return Number(1 / operands[0].value)\n        out = operands[0].value\n        for operand in operands[1:]:\n            out /= operand.value\n        return Number(out)",
        "detail": "lab.lab09.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "Abs",
        "kind": 6,
        "importPath": "lab.lab09.editor.arithmetic",
        "description": "lab.lab09.editor.arithmetic",
        "peekOfCode": "class Abs(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        assert_all_numbers([operand])\n        return Number(abs(operand.value))\n@global_attr(\"expt\")\nclass Expt(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        assert_all_numbers(operands)\n        return Number(operands[0].value ** operands[1].value)",
        "detail": "lab.lab09.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "Expt",
        "kind": 6,
        "importPath": "lab.lab09.editor.arithmetic",
        "description": "lab.lab09.editor.arithmetic",
        "peekOfCode": "class Expt(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        assert_all_numbers(operands)\n        return Number(operands[0].value ** operands[1].value)\n@global_attr(\"modulo\")\nclass Modulo(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        assert_all_numbers(operands)",
        "detail": "lab.lab09.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "Modulo",
        "kind": 6,
        "importPath": "lab.lab09.editor.arithmetic",
        "description": "lab.lab09.editor.arithmetic",
        "peekOfCode": "class Modulo(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        assert_all_numbers(operands)\n        return Number(operands[0].value % abs(operands[1].value))\n@global_attr(\"quotient\")\nclass Quotient(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        assert_all_numbers(operands)",
        "detail": "lab.lab09.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "Quotient",
        "kind": 6,
        "importPath": "lab.lab09.editor.arithmetic",
        "description": "lab.lab09.editor.arithmetic",
        "peekOfCode": "class Quotient(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        assert_all_numbers(operands)\n        negate = (operands[0].value < 0) != (operands[1].value < 0)\n        negate = -1 if negate else 1\n        return Number(negate * operands[0].value // operands[1].value)\n@global_attr(\"remainder\")\nclass Remainder(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:",
        "detail": "lab.lab09.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "Remainder",
        "kind": 6,
        "importPath": "lab.lab09.editor.arithmetic",
        "description": "lab.lab09.editor.arithmetic",
        "peekOfCode": "class Remainder(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        assert_all_numbers(operands)\n        negate = (operands[0].value < 0)\n        negate = -1 if negate else 1\n        return Number(negate * (abs(operands[0].value) % abs(operands[1].value)))\n@global_attr(\"=\")\nclass NumEq(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:",
        "detail": "lab.lab09.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "NumEq",
        "kind": 6,
        "importPath": "lab.lab09.editor.arithmetic",
        "description": "lab.lab09.editor.arithmetic",
        "peekOfCode": "class NumEq(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        assert_all_numbers(operands)\n        return bools[operands[0].value == operands[1].value]\n@global_attr(\"<\")\nclass Less(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        assert_all_numbers(operands)",
        "detail": "lab.lab09.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "Less",
        "kind": 6,
        "importPath": "lab.lab09.editor.arithmetic",
        "description": "lab.lab09.editor.arithmetic",
        "peekOfCode": "class Less(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        assert_all_numbers(operands)\n        return bools[operands[0].value < operands[1].value]\n@global_attr(\"<=\")\nclass LessOrEq(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        assert_all_numbers(operands)",
        "detail": "lab.lab09.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "LessOrEq",
        "kind": 6,
        "importPath": "lab.lab09.editor.arithmetic",
        "description": "lab.lab09.editor.arithmetic",
        "peekOfCode": "class LessOrEq(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        assert_all_numbers(operands)\n        return bools[operands[0].value <= operands[1].value]\n@global_attr(\">\")\nclass Greater(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        assert_all_numbers(operands)",
        "detail": "lab.lab09.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "Greater",
        "kind": 6,
        "importPath": "lab.lab09.editor.arithmetic",
        "description": "lab.lab09.editor.arithmetic",
        "peekOfCode": "class Greater(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        assert_all_numbers(operands)\n        return bools[operands[0].value > operands[1].value]\n@global_attr(\">=\")\nclass GreaterOrEq(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        assert_all_numbers(operands)",
        "detail": "lab.lab09.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "GreaterOrEq",
        "kind": 6,
        "importPath": "lab.lab09.editor.arithmetic",
        "description": "lab.lab09.editor.arithmetic",
        "peekOfCode": "class GreaterOrEq(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        assert_all_numbers(operands)\n        return bools[operands[0].value >= operands[1].value]\n@global_attr(\"even?\")\nclass IsEven(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        assert_all_numbers([operand])\n        return bools[not operand.value % 2]",
        "detail": "lab.lab09.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "IsEven",
        "kind": 6,
        "importPath": "lab.lab09.editor.arithmetic",
        "description": "lab.lab09.editor.arithmetic",
        "peekOfCode": "class IsEven(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        assert_all_numbers([operand])\n        return bools[not operand.value % 2]\n@global_attr(\"odd?\")\nclass IsOdd(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        assert_all_numbers([operand])\n        return bools[operand.value % 2]\n@global_attr(\"zero?\")",
        "detail": "lab.lab09.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "IsOdd",
        "kind": 6,
        "importPath": "lab.lab09.editor.arithmetic",
        "description": "lab.lab09.editor.arithmetic",
        "peekOfCode": "class IsOdd(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        assert_all_numbers([operand])\n        return bools[operand.value % 2]\n@global_attr(\"zero?\")\nclass IsZero(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        assert_all_numbers([operand])\n        return bools[operand.value == 0]\n@global_attr(\"not\")",
        "detail": "lab.lab09.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "IsZero",
        "kind": 6,
        "importPath": "lab.lab09.editor.arithmetic",
        "description": "lab.lab09.editor.arithmetic",
        "peekOfCode": "class IsZero(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        assert_all_numbers([operand])\n        return bools[operand.value == 0]\n@global_attr(\"not\")\nclass Not(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        return bools[operand is SingletonFalse]\n@global_attr(\"eqv?\")\nclass IsEqv(BuiltIn):",
        "detail": "lab.lab09.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "Not",
        "kind": 6,
        "importPath": "lab.lab09.editor.arithmetic",
        "description": "lab.lab09.editor.arithmetic",
        "peekOfCode": "class Not(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        return bools[operand is SingletonFalse]\n@global_attr(\"eqv?\")\nclass IsEqv(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame):\n        verify_exact_callable_length(self, 2, len(operands))\n        if all(isinstance(x, ValueHolder) for x in operands):\n            return bools[operands[0].value == operands[1].value]\n        return bools[operands[0] is operands[1]]",
        "detail": "lab.lab09.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "IsEqv",
        "kind": 6,
        "importPath": "lab.lab09.editor.arithmetic",
        "description": "lab.lab09.editor.arithmetic",
        "peekOfCode": "class IsEqv(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame):\n        verify_exact_callable_length(self, 2, len(operands))\n        if all(isinstance(x, ValueHolder) for x in operands):\n            return bools[operands[0].value == operands[1].value]\n        return bools[operands[0] is operands[1]]\n@global_attr(\"eq?\")\nclass IsEq(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame):\n        verify_exact_callable_length(self, 2, len(operands))",
        "detail": "lab.lab09.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "IsEq",
        "kind": 6,
        "importPath": "lab.lab09.editor.arithmetic",
        "description": "lab.lab09.editor.arithmetic",
        "peekOfCode": "class IsEq(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame):\n        verify_exact_callable_length(self, 2, len(operands))\n        if all(isinstance(x, ValueHolder) for x in operands):\n            if isinstance(operands[0], Number):\n                return bools[operands[0] is operands[1]]\n            else:\n                return bools[operands[0].value == operands[1].value]\n        return bools[operands[0] is operands[1]]\n@global_attr(\"equal?\")",
        "detail": "lab.lab09.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "IsEqual",
        "kind": 6,
        "importPath": "lab.lab09.editor.arithmetic",
        "description": "lab.lab09.editor.arithmetic",
        "peekOfCode": "class IsEqual(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame):\n        verify_exact_callable_length(self, 2, len(operands))\n        if all(isinstance(x, ValueHolder) for x in operands):\n            return bools[operands[0].value == operands[1].value]\n        elif all(isinstance(x, Pair) for x in operands):\n            return bools[IsEqual().execute_evaluated([operands[0].first, operands[1].first], frame) is SingletonTrue and \\\n                         IsEqual().execute_evaluated([operands[0].rest, operands[1].rest], frame) is SingletonTrue]\n        else:\n            return IsEqv().execute_evaluated(operands, frame)",
        "detail": "lab.lab09.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "Print",
        "kind": 6,
        "importPath": "lab.lab09.editor.console",
        "description": "lab.lab09.editor.console",
        "peekOfCode": "class Print(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        log.logger.out(operand)\n        return Undefined\n@global_attr(\"display\")\nclass Display(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if isinstance(operand, String):\n            log.logger.raw_out(operand.value)\n        else:",
        "detail": "lab.lab09.editor.console",
        "documentation": {}
    },
    {
        "label": "Display",
        "kind": 6,
        "importPath": "lab.lab09.editor.console",
        "description": "lab.lab09.editor.console",
        "peekOfCode": "class Display(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if isinstance(operand, String):\n            log.logger.raw_out(operand.value)\n        else:\n            log.logger.out(operand, end=\"\")\n        return Undefined\n@global_attr(\"newline\")\nclass Newline(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:",
        "detail": "lab.lab09.editor.console",
        "documentation": {}
    },
    {
        "label": "Newline",
        "kind": 6,
        "importPath": "lab.lab09.editor.console",
        "description": "lab.lab09.editor.console",
        "peekOfCode": "class Newline(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 0, len(operands))\n        log.logger.raw_out(\"\\n\")\n        return Undefined",
        "detail": "lab.lab09.editor.console",
        "documentation": {}
    },
    {
        "label": "COLORS",
        "kind": 5,
        "importPath": "lab.lab09.editor.css_colors",
        "description": "lab.lab09.editor.css_colors",
        "peekOfCode": "COLORS = {\n  \"aliceblue\": \"#f0f8ff\",\n  \"antiquewhite\": \"#faebd7\",\n  \"aqua\": \"#00ffff\",\n  \"aquamarine\": \"#7fffd4\",\n  \"azure\": \"#f0ffff\",\n  \"beige\": \"#f5f5dc\",\n  \"bisque\": \"#ffe4c4\",\n  \"black\": \"#000000\",\n  \"blanchedalmond\": \"#ffebcd\",",
        "detail": "lab.lab09.editor.css_colors",
        "documentation": {}
    },
    {
        "label": "get_word",
        "kind": 2,
        "importPath": "lab.lab09.editor.database",
        "description": "lab.lab09.editor.database",
        "peekOfCode": "def get_word() -> str:\n    with open(\"src/words.txt\") as file:\n        word = next(file)\n        for i, trial in enumerate(file):\n            if randrange(i + 2) != 0:\n                continue\n            word = trial\n        return word\ndef generate_id(n=3):\n    return \"\".join(get_word().lower().capitalize().strip() for _ in range(3))",
        "detail": "lab.lab09.editor.database",
        "documentation": {}
    },
    {
        "label": "generate_id",
        "kind": 2,
        "importPath": "lab.lab09.editor.database",
        "description": "lab.lab09.editor.database",
        "peekOfCode": "def generate_id(n=3):\n    return \"\".join(get_word().lower().capitalize().strip() for _ in range(3))\ndef save(code_lines, skip_envs, hide_return_frames):\n    conn = sqlite3.connect(\"saved\")\n    to_store = repr(code_lines)\n    lookup = generate_id()\n    conn.execute(\"INSERT INTO stored_lines VALUES(?, ?, ?, ?)\",\n                 (lookup, to_store, skip_envs, hide_return_frames))\n    conn.commit()\n    conn.close()",
        "detail": "lab.lab09.editor.database",
        "documentation": {}
    },
    {
        "label": "save",
        "kind": 2,
        "importPath": "lab.lab09.editor.database",
        "description": "lab.lab09.editor.database",
        "peekOfCode": "def save(code_lines, skip_envs, hide_return_frames):\n    conn = sqlite3.connect(\"saved\")\n    to_store = repr(code_lines)\n    lookup = generate_id()\n    conn.execute(\"INSERT INTO stored_lines VALUES(?, ?, ?, ?)\",\n                 (lookup, to_store, skip_envs, hide_return_frames))\n    conn.commit()\n    conn.close()\n    return lookup\ndef load(lookup) -> Union[Tuple, None]:",
        "detail": "lab.lab09.editor.database",
        "documentation": {}
    },
    {
        "label": "load",
        "kind": 2,
        "importPath": "lab.lab09.editor.database",
        "description": "lab.lab09.editor.database",
        "peekOfCode": "def load(lookup) -> Union[Tuple, None]:\n    conn = sqlite3.connect(\"saved\")\n    for row in conn.execute('SELECT * FROM stored_lines WHERE code=?', (lookup,)):\n        return row[1:]\n    conn.close()",
        "detail": "lab.lab09.editor.database",
        "documentation": {}
    },
    {
        "label": "Expression",
        "kind": 6,
        "importPath": "lab.lab09.editor.datamodel",
        "description": "lab.lab09.editor.datamodel",
        "peekOfCode": "class Expression:\n    def __init__(self):\n        self.id = None\nclass ValueHolder(Expression):\n    def __init__(self, value):\n        super().__init__()\n        self.value = value\n    def __repr__(self):\n        return str(self.value)\nclass Symbol(ValueHolder):",
        "detail": "lab.lab09.editor.datamodel",
        "documentation": {}
    },
    {
        "label": "ValueHolder",
        "kind": 6,
        "importPath": "lab.lab09.editor.datamodel",
        "description": "lab.lab09.editor.datamodel",
        "peekOfCode": "class ValueHolder(Expression):\n    def __init__(self, value):\n        super().__init__()\n        self.value = value\n    def __repr__(self):\n        return str(self.value)\nclass Symbol(ValueHolder):\n    pass\nclass Number(ValueHolder):\n    def __init__(self, value, *, force_float=False):",
        "detail": "lab.lab09.editor.datamodel",
        "documentation": {}
    },
    {
        "label": "Symbol",
        "kind": 6,
        "importPath": "lab.lab09.editor.datamodel",
        "description": "lab.lab09.editor.datamodel",
        "peekOfCode": "class Symbol(ValueHolder):\n    pass\nclass Number(ValueHolder):\n    def __init__(self, value, *, force_float=False):\n        super().__init__(value)\n        if value == round(value) and not force_float:\n            self.value = round(value)\n        else:\n            self.value = value\n    def __repr__(self):",
        "detail": "lab.lab09.editor.datamodel",
        "documentation": {}
    },
    {
        "label": "Number",
        "kind": 6,
        "importPath": "lab.lab09.editor.datamodel",
        "description": "lab.lab09.editor.datamodel",
        "peekOfCode": "class Number(ValueHolder):\n    def __init__(self, value, *, force_float=False):\n        super().__init__(value)\n        if value == round(value) and not force_float:\n            self.value = round(value)\n        else:\n            self.value = value\n    def __repr__(self):\n        return super().__repr__()\nclass Pair(Expression):",
        "detail": "lab.lab09.editor.datamodel",
        "documentation": {}
    },
    {
        "label": "Pair",
        "kind": 6,
        "importPath": "lab.lab09.editor.datamodel",
        "description": "lab.lab09.editor.datamodel",
        "peekOfCode": "class Pair(Expression):\n    def __init__(self, first: Expression, rest: Expression):\n        import log\n        super().__init__()\n        self.first = first\n        if not log.logger.dotted and not isinstance(rest, (Pair, NilType, Promise)):\n            raise TypeMismatchError(\n                f\"Unable to construct a Pair with a cdr of {rest}, expected a Pair, Nil, or Promise.\")\n        self.rest = rest\n    def __repr__(self):",
        "detail": "lab.lab09.editor.datamodel",
        "documentation": {}
    },
    {
        "label": "NilType",
        "kind": 6,
        "importPath": "lab.lab09.editor.datamodel",
        "description": "lab.lab09.editor.datamodel",
        "peekOfCode": "class NilType(Expression):\n    def __repr__(self):\n        return \"()\"\nclass UndefinedType(Expression):\n    def __repr__(self):\n        from log import logger\n        if logger.strict_mode:\n            return \"\"\n        return \"undefined\"\nclass Boolean(ValueHolder):",
        "detail": "lab.lab09.editor.datamodel",
        "documentation": {}
    },
    {
        "label": "UndefinedType",
        "kind": 6,
        "importPath": "lab.lab09.editor.datamodel",
        "description": "lab.lab09.editor.datamodel",
        "peekOfCode": "class UndefinedType(Expression):\n    def __repr__(self):\n        from log import logger\n        if logger.strict_mode:\n            return \"\"\n        return \"undefined\"\nclass Boolean(ValueHolder):\n    def __repr__(self):\n        if self.value:\n            return \"#t\"",
        "detail": "lab.lab09.editor.datamodel",
        "documentation": {}
    },
    {
        "label": "Boolean",
        "kind": 6,
        "importPath": "lab.lab09.editor.datamodel",
        "description": "lab.lab09.editor.datamodel",
        "peekOfCode": "class Boolean(ValueHolder):\n    def __repr__(self):\n        if self.value:\n            return \"#t\"\n        else:\n            return \"#f\"\nclass String(ValueHolder):\n    def __init__(self, value):\n        super().__init__(value)\n    def __repr__(self):",
        "detail": "lab.lab09.editor.datamodel",
        "documentation": {}
    },
    {
        "label": "String",
        "kind": 6,
        "importPath": "lab.lab09.editor.datamodel",
        "description": "lab.lab09.editor.datamodel",
        "peekOfCode": "class String(ValueHolder):\n    def __init__(self, value):\n        super().__init__(value)\n    def __repr__(self):\n        return \"\\\"\" + self.value.replace(\"\\n\", \"\\\\n\").replace(\"\\\"\", \"\\\\\\\"\").replace(\"\\'\", \"'\") + \"\\\"\"\nclass Promise(Expression):\n    def __init__(self, expr: Expression, frame: 'Frame'):\n        super().__init__()\n        self.forced = False\n        self.force_i = None",
        "detail": "lab.lab09.editor.datamodel",
        "documentation": {}
    },
    {
        "label": "Promise",
        "kind": 6,
        "importPath": "lab.lab09.editor.datamodel",
        "description": "lab.lab09.editor.datamodel",
        "peekOfCode": "class Promise(Expression):\n    def __init__(self, expr: Expression, frame: 'Frame'):\n        super().__init__()\n        self.forced = False\n        self.force_i = None\n        self.expr = expr\n        self.frame = frame\n        self.targets = []\n        self.id = get_id()\n    def __repr__(self):",
        "detail": "lab.lab09.editor.datamodel",
        "documentation": {}
    },
    {
        "label": "SingletonTrue",
        "kind": 5,
        "importPath": "lab.lab09.editor.datamodel",
        "description": "lab.lab09.editor.datamodel",
        "peekOfCode": "SingletonTrue = Boolean(True)\nSingletonFalse = Boolean(False)\nbools = [SingletonFalse, SingletonTrue]\nNil = NilType()\nUndefined = UndefinedType()",
        "detail": "lab.lab09.editor.datamodel",
        "documentation": {}
    },
    {
        "label": "SingletonFalse",
        "kind": 5,
        "importPath": "lab.lab09.editor.datamodel",
        "description": "lab.lab09.editor.datamodel",
        "peekOfCode": "SingletonFalse = Boolean(False)\nbools = [SingletonFalse, SingletonTrue]\nNil = NilType()\nUndefined = UndefinedType()",
        "detail": "lab.lab09.editor.datamodel",
        "documentation": {}
    },
    {
        "label": "bools",
        "kind": 5,
        "importPath": "lab.lab09.editor.datamodel",
        "description": "lab.lab09.editor.datamodel",
        "peekOfCode": "bools = [SingletonFalse, SingletonTrue]\nNil = NilType()\nUndefined = UndefinedType()",
        "detail": "lab.lab09.editor.datamodel",
        "documentation": {}
    },
    {
        "label": "Nil",
        "kind": 5,
        "importPath": "lab.lab09.editor.datamodel",
        "description": "lab.lab09.editor.datamodel",
        "peekOfCode": "Nil = NilType()\nUndefined = UndefinedType()",
        "detail": "lab.lab09.editor.datamodel",
        "documentation": {}
    },
    {
        "label": "Undefined",
        "kind": 5,
        "importPath": "lab.lab09.editor.datamodel",
        "description": "lab.lab09.editor.datamodel",
        "peekOfCode": "Undefined = UndefinedType()",
        "detail": "lab.lab09.editor.datamodel",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 2,
        "importPath": "lab.lab09.editor.documentation",
        "description": "lab.lab09.editor.documentation",
        "peekOfCode": "def rank(query):\n    def fraction(source):\n        return source.count(query) / len(source)\n    def quality(elem):\n        return 20 * fraction(elem.split(\"\\n\")[0]) + fraction(elem)\n    return quality\ndef search(query):\n    with open(\"editor/scheme_documentation.md\") as f:\n        query = query.strip().lower()\n        contents = str(f.read())",
        "detail": "lab.lab09.editor.documentation",
        "documentation": {}
    },
    {
        "label": "search",
        "kind": 2,
        "importPath": "lab.lab09.editor.documentation",
        "description": "lab.lab09.editor.documentation",
        "peekOfCode": "def search(query):\n    with open(\"editor/scheme_documentation.md\") as f:\n        query = query.strip().lower()\n        contents = str(f.read())\n        contents = re.sub(r\"<a class='builtin-header' id='.*?'>\\*\\*(.*?)\\*\\*</a>\", r\"### **\\1**\", contents)\n        divider = \"##\"\n        elements = [divider + elem for elem in contents.split(divider)]\n        elements = [elem for elem in elements if \"\\n\" in elem.strip()]\n        relevant_elems = []\n        for elem in elements:",
        "detail": "lab.lab09.editor.documentation",
        "documentation": {}
    },
    {
        "label": "MathProcedure",
        "kind": 6,
        "importPath": "lab.lab09.editor.environment",
        "description": "lab.lab09.editor.environment",
        "peekOfCode": "class MathProcedure(BuiltIn):\n    def __init__(self, func, name):\n        super().__init__()\n        self.func = func\n        self.name = name\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        for operand in operands:\n            if not isinstance(operand, Number):\n                raise MathError()\n        try:",
        "detail": "lab.lab09.editor.environment",
        "documentation": {}
    },
    {
        "label": "make_frame_decorator",
        "kind": 2,
        "importPath": "lab.lab09.editor.environment",
        "description": "lab.lab09.editor.environment",
        "peekOfCode": "def make_frame_decorator(defdict):\n    def global_builtin(name):\n        def decorator(cls):\n            cls.__repr__ = lambda self: f\"#[{name}]\"\n            defdict[name] = cls\n            return cls\n        return decorator\n    return global_builtin\ndefdict = {}\nglobal_attr = make_frame_decorator(defdict)",
        "detail": "lab.lab09.editor.environment",
        "documentation": {}
    },
    {
        "label": "get_special_form",
        "kind": 2,
        "importPath": "lab.lab09.editor.environment",
        "description": "lab.lab09.editor.environment",
        "peekOfCode": "def get_special_form(name: str):\n    if name in special_forms:\n        return special_forms[name]()\n    else:\n        return None\ndef build_global_frame():\n    import primitives\n    primitives.load_primitives()\n    frame = Frame(\"builtins\")\n    for k, v in defdict.items():",
        "detail": "lab.lab09.editor.environment",
        "documentation": {}
    },
    {
        "label": "build_global_frame",
        "kind": 2,
        "importPath": "lab.lab09.editor.environment",
        "description": "lab.lab09.editor.environment",
        "peekOfCode": "def build_global_frame():\n    import primitives\n    primitives.load_primitives()\n    frame = Frame(\"builtins\")\n    for k, v in defdict.items():\n        frame.assign(Symbol(k), v())\n    # moved to the parser\n    # frame.assign(Symbol(\"nil\"), Nil)\n    # frame.assign(Symbol(\"#t\"), SingletonTrue)\n    # frame.assign(Symbol(\"#f\"), SingletonFalse)",
        "detail": "lab.lab09.editor.environment",
        "documentation": {}
    },
    {
        "label": "defdict",
        "kind": 5,
        "importPath": "lab.lab09.editor.environment",
        "description": "lab.lab09.editor.environment",
        "peekOfCode": "defdict = {}\nglobal_attr = make_frame_decorator(defdict)\nspecial_forms = {}\nspecial_form = make_frame_decorator(special_forms)\nclass MathProcedure(BuiltIn):\n    def __init__(self, func, name):\n        super().__init__()\n        self.func = func\n        self.name = name\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:",
        "detail": "lab.lab09.editor.environment",
        "documentation": {}
    },
    {
        "label": "global_attr",
        "kind": 5,
        "importPath": "lab.lab09.editor.environment",
        "description": "lab.lab09.editor.environment",
        "peekOfCode": "global_attr = make_frame_decorator(defdict)\nspecial_forms = {}\nspecial_form = make_frame_decorator(special_forms)\nclass MathProcedure(BuiltIn):\n    def __init__(self, func, name):\n        super().__init__()\n        self.func = func\n        self.name = name\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        for operand in operands:",
        "detail": "lab.lab09.editor.environment",
        "documentation": {}
    },
    {
        "label": "special_forms",
        "kind": 5,
        "importPath": "lab.lab09.editor.environment",
        "description": "lab.lab09.editor.environment",
        "peekOfCode": "special_forms = {}\nspecial_form = make_frame_decorator(special_forms)\nclass MathProcedure(BuiltIn):\n    def __init__(self, func, name):\n        super().__init__()\n        self.func = func\n        self.name = name\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        for operand in operands:\n            if not isinstance(operand, Number):",
        "detail": "lab.lab09.editor.environment",
        "documentation": {}
    },
    {
        "label": "special_form",
        "kind": 5,
        "importPath": "lab.lab09.editor.environment",
        "description": "lab.lab09.editor.environment",
        "peekOfCode": "special_form = make_frame_decorator(special_forms)\nclass MathProcedure(BuiltIn):\n    def __init__(self, func, name):\n        super().__init__()\n        self.func = func\n        self.name = name\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        for operand in operands:\n            if not isinstance(operand, Number):\n                raise MathError()",
        "detail": "lab.lab09.editor.environment",
        "documentation": {}
    },
    {
        "label": "Frame",
        "kind": 6,
        "importPath": "lab.lab09.editor.evaluate_apply",
        "description": "lab.lab09.editor.evaluate_apply",
        "peekOfCode": "class Frame:\n    def __init__(self, name: str, parent: 'Frame' = None):\n        self.parent = parent\n        self.name = name\n        self.vars: Dict[str, Expression] = {}\n        self.id = \"unknown\"\n        self.temp = log.logger.fragile\n        log.logger.frame_create(self)\n    def assign(self, varname: Symbol, varval: Expression):\n        if log.logger.fragile and not self.temp:",
        "detail": "lab.lab09.editor.evaluate_apply",
        "documentation": {}
    },
    {
        "label": "Thunk",
        "kind": 6,
        "importPath": "lab.lab09.editor.evaluate_apply",
        "description": "lab.lab09.editor.evaluate_apply",
        "peekOfCode": "class Thunk:\n    def __init__(self, expr: Expression, frame: Frame, gui_holder: log.Holder, log_stack: bool):\n        self.expr = expr\n        self.frame = frame\n        self.log_stack = log_stack\n        self.gui_holder = gui_holder\n        self.return_frame: Optional[Frame] = None\n    def __repr__(self):\n        return \"thunk\"\n    def evaluate(self, expr: Expression):",
        "detail": "lab.lab09.editor.evaluate_apply",
        "documentation": {}
    },
    {
        "label": "Callable",
        "kind": 6,
        "importPath": "lab.lab09.editor.evaluate_apply",
        "description": "lab.lab09.editor.evaluate_apply",
        "peekOfCode": "class Callable(Expression):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: log.Holder):\n        raise NotImplementedError()\nclass Applicable(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: log.Holder, eval_operands=True):\n        raise NotImplementedError()\ndef evaluate_all(operands: List[Expression], frame: Frame, operand_holders: List[log.Holder]) -> List[Expression]:\n    return [evaluate(operand, frame, holder) for operand, holder in zip(operands, operand_holders)]",
        "detail": "lab.lab09.editor.evaluate_apply",
        "documentation": {}
    },
    {
        "label": "Applicable",
        "kind": 6,
        "importPath": "lab.lab09.editor.evaluate_apply",
        "description": "lab.lab09.editor.evaluate_apply",
        "peekOfCode": "class Applicable(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: log.Holder, eval_operands=True):\n        raise NotImplementedError()\ndef evaluate_all(operands: List[Expression], frame: Frame, operand_holders: List[log.Holder]) -> List[Expression]:\n    return [evaluate(operand, frame, holder) for operand, holder in zip(operands, operand_holders)]",
        "detail": "lab.lab09.editor.evaluate_apply",
        "documentation": {}
    },
    {
        "label": "evaluate",
        "kind": 2,
        "importPath": "lab.lab09.editor.evaluate_apply",
        "description": "lab.lab09.editor.evaluate_apply",
        "peekOfCode": "def evaluate(expr: Expression, frame: Frame, gui_holder: log.Holder,\n             tail_context: bool = False, *, log_stack: bool=True) -> Union[Expression, Thunk]:\n    depth = 0\n    thunks = []\n    holders = []\n    while True:\n        if depth > RECURSION_LIMIT:\n            raise OutOfMemoryError(\"Debugger ran out of memory due to excessively deep recursion.\")\n        visual_expression = gui_holder.expression\n        if log_stack:",
        "detail": "lab.lab09.editor.evaluate_apply",
        "documentation": {}
    },
    {
        "label": "apply",
        "kind": 2,
        "importPath": "lab.lab09.editor.evaluate_apply",
        "description": "lab.lab09.editor.evaluate_apply",
        "peekOfCode": "def apply(operator: Expression, operands: List[Expression], frame: Frame, gui_holder: log.Holder):\n    if isinstance(operator, Callable):\n        return operator.execute(operands, frame, gui_holder)\n    elif isinstance(operator, Symbol):\n        raise CallableResolutionError(f\"Unable to pass parameters into the Symbol '{operator}'\")\n    else:\n        raise CallableResolutionError(f\"Unable to pass parameters into: '{operator}'\")\nclass Callable(Expression):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: log.Holder):\n        raise NotImplementedError()",
        "detail": "lab.lab09.editor.evaluate_apply",
        "documentation": {}
    },
    {
        "label": "evaluate_all",
        "kind": 2,
        "importPath": "lab.lab09.editor.evaluate_apply",
        "description": "lab.lab09.editor.evaluate_apply",
        "peekOfCode": "def evaluate_all(operands: List[Expression], frame: Frame, operand_holders: List[log.Holder]) -> List[Expression]:\n    return [evaluate(operand, frame, holder) for operand, holder in zip(operands, operand_holders)]",
        "detail": "lab.lab09.editor.evaluate_apply",
        "documentation": {}
    },
    {
        "label": "RECURSION_LIMIT",
        "kind": 5,
        "importPath": "lab.lab09.editor.evaluate_apply",
        "description": "lab.lab09.editor.evaluate_apply",
        "peekOfCode": "RECURSION_LIMIT = 100000\nclass Frame:\n    def __init__(self, name: str, parent: 'Frame' = None):\n        self.parent = parent\n        self.name = name\n        self.vars: Dict[str, Expression] = {}\n        self.id = \"unknown\"\n        self.temp = log.logger.fragile\n        log.logger.frame_create(self)\n    def assign(self, varname: Symbol, varval: Expression):",
        "detail": "lab.lab09.editor.evaluate_apply",
        "documentation": {}
    },
    {
        "label": "string_exec",
        "kind": 2,
        "importPath": "lab.lab09.editor.execution",
        "description": "lab.lab09.editor.execution",
        "peekOfCode": "def string_exec(strings, out, visualize_tail_calls, global_frame=None):\n    import log\n    empty = False\n    if global_frame is None:\n        empty = True\n        from environment import build_global_frame\n        log.logger.f_delta -= 1\n        global_frame = build_global_frame()\n        log.logger.active_frames.pop(0)  # clear builtin frame\n        log.logger.f_delta += 1",
        "detail": "lab.lab09.editor.execution",
        "documentation": {}
    },
    {
        "label": "MAX_TRACEBACK_LENGTH",
        "kind": 5,
        "importPath": "lab.lab09.editor.execution",
        "description": "lab.lab09.editor.execution",
        "peekOfCode": "MAX_TRACEBACK_LENGTH = 20\nMAX_AUTODRAW_LENGTH = 50\ndef string_exec(strings, out, visualize_tail_calls, global_frame=None):\n    import log\n    empty = False\n    if global_frame is None:\n        empty = True\n        from environment import build_global_frame\n        log.logger.f_delta -= 1\n        global_frame = build_global_frame()",
        "detail": "lab.lab09.editor.execution",
        "documentation": {}
    },
    {
        "label": "MAX_AUTODRAW_LENGTH",
        "kind": 5,
        "importPath": "lab.lab09.editor.execution",
        "description": "lab.lab09.editor.execution",
        "peekOfCode": "MAX_AUTODRAW_LENGTH = 50\ndef string_exec(strings, out, visualize_tail_calls, global_frame=None):\n    import log\n    empty = False\n    if global_frame is None:\n        empty = True\n        from environment import build_global_frame\n        log.logger.f_delta -= 1\n        global_frame = build_global_frame()\n        log.logger.active_frames.pop(0)  # clear builtin frame",
        "detail": "lab.lab09.editor.execution",
        "documentation": {}
    },
    {
        "label": "strip_comments",
        "kind": 2,
        "importPath": "lab.lab09.editor.execution_parser",
        "description": "lab.lab09.editor.execution_parser",
        "peekOfCode": "def strip_comments(code):\n    try:\n        out = \"\"\n        for string in code:\n            if not string.strip():\n                continue\n            buff = TokenBuffer([string])\n            while not buff.done:\n                out += str(get_expression(buff))\n        return out",
        "detail": "lab.lab09.editor.execution_parser",
        "documentation": {}
    },
    {
        "label": "tokenize",
        "kind": 2,
        "importPath": "lab.lab09.editor.execution_parser",
        "description": "lab.lab09.editor.execution_parser",
        "peekOfCode": "def tokenize(buffer: TokenBuffer):\n    \"\"\"\n    >>> buff = TokenBuffer([\"(1 (2 cat) (cat+dog-2 (5 6)  ) )\"])\n    >>> tokenize(buff)\n    [(1 (2 cat) (cat+dog-2 (5 6)))]\n    >>> buff = TokenBuffer([\"(1 . 2)\"])\n    >>> tokenize(buff)\n    [(1 . 2)]\n    >>> buff = TokenBuffer([\"(1 2 . 3)\"])\n    >>> tokenize(buff)",
        "detail": "lab.lab09.editor.execution_parser",
        "documentation": {}
    },
    {
        "label": "get_expression",
        "kind": 2,
        "importPath": "lab.lab09.editor.execution_parser",
        "description": "lab.lab09.editor.execution_parser",
        "peekOfCode": "def get_expression(buffer: TokenBuffer) -> Union[Expression, None]:\n    token = buffer.pop_next_token()\n    if token is None:\n        return None\n    elif token in (\"(\", \"[\"):\n        return get_rest_of_list(buffer, \")\" if token == \"(\" else \"]\")\n    elif token == \"'\":\n        return make_list([Symbol(\"quote\"), get_expression(buffer)])\n    elif token == \",\":\n        if buffer.get_next_token() == \"@\":",
        "detail": "lab.lab09.editor.execution_parser",
        "documentation": {}
    },
    {
        "label": "get_string",
        "kind": 2,
        "importPath": "lab.lab09.editor.execution_parser",
        "description": "lab.lab09.editor.execution_parser",
        "peekOfCode": "def get_string(buffer: TokenBuffer) -> String:\n    out = []\n    string = buffer.pop_next_token()\n    escaping = False\n    for char in string.value:\n        if escaping:\n            if char == \"n\":\n                out.append(\"\\n\")\n            else:\n                out.append(char)",
        "detail": "lab.lab09.editor.execution_parser",
        "documentation": {}
    },
    {
        "label": "get_rest_of_list",
        "kind": 2,
        "importPath": "lab.lab09.editor.execution_parser",
        "description": "lab.lab09.editor.execution_parser",
        "peekOfCode": "def get_rest_of_list(buffer: TokenBuffer, end_paren: str) -> Expression:\n    out = []\n    last = Nil\n    while True:\n        next = buffer.get_next_token()\n        if next == end_paren:\n            buffer.pop_next_token()\n            break\n        elif logger.dotted and next == \".\":\n            buffer.pop_next_token()",
        "detail": "lab.lab09.editor.execution_parser",
        "documentation": {}
    },
    {
        "label": "is_number",
        "kind": 2,
        "importPath": "lab.lab09.editor.execution_parser",
        "description": "lab.lab09.editor.execution_parser",
        "peekOfCode": "def is_number(token: str) -> bool:\n    try:\n        float(token)\n        return True\n    except ValueError:\n        return False\ndef is_str(token: str) -> bool:\n    return True",
        "detail": "lab.lab09.editor.execution_parser",
        "documentation": {}
    },
    {
        "label": "is_str",
        "kind": 2,
        "importPath": "lab.lab09.editor.execution_parser",
        "description": "lab.lab09.editor.execution_parser",
        "peekOfCode": "def is_str(token: str) -> bool:\n    return True",
        "detail": "lab.lab09.editor.execution_parser",
        "documentation": {}
    },
    {
        "label": "get_scm_files",
        "kind": 2,
        "importPath": "lab.lab09.editor.file_manager",
        "description": "lab.lab09.editor.file_manager",
        "peekOfCode": "def get_scm_files():\n    files = filter(lambda x: x.lower().endswith(\".scm\"), os.listdir(os.curdir))\n    return sorted(files)\ndef save(code, filename):\n    with open(filename, \"w+\") as file:\n        file.truncate(0)\n        file.seek(0)\n        file.write(\"\\n\".join(code))\n        file.flush()\ndef read_file(filename):",
        "detail": "lab.lab09.editor.file_manager",
        "documentation": {}
    },
    {
        "label": "save",
        "kind": 2,
        "importPath": "lab.lab09.editor.file_manager",
        "description": "lab.lab09.editor.file_manager",
        "peekOfCode": "def save(code, filename):\n    with open(filename, \"w+\") as file:\n        file.truncate(0)\n        file.seek(0)\n        file.write(\"\\n\".join(code))\n        file.flush()\ndef read_file(filename):\n    with open(filename, \"r\") as file:\n        return \"\".join([x for x in file])\ndef new_file(filename):",
        "detail": "lab.lab09.editor.file_manager",
        "documentation": {}
    },
    {
        "label": "read_file",
        "kind": 2,
        "importPath": "lab.lab09.editor.file_manager",
        "description": "lab.lab09.editor.file_manager",
        "peekOfCode": "def read_file(filename):\n    with open(filename, \"r\") as file:\n        return \"\".join([x for x in file])\ndef new_file(filename):\n    if filename + \".scm\" in get_scm_files():\n        return False\n    open(filename + \".scm\", \"w\")\n    return True",
        "detail": "lab.lab09.editor.file_manager",
        "documentation": {}
    },
    {
        "label": "new_file",
        "kind": 2,
        "importPath": "lab.lab09.editor.file_manager",
        "description": "lab.lab09.editor.file_manager",
        "peekOfCode": "def new_file(filename):\n    if filename + \".scm\" in get_scm_files():\n        return False\n    open(filename + \".scm\", \"w\")\n    return True",
        "detail": "lab.lab09.editor.file_manager",
        "documentation": {}
    },
    {
        "label": "OptimalFormattingReached",
        "kind": 6,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "class OptimalFormattingReached(Exception):\n    pass\nclass MatchFailure(Exception):\n    pass\nclass WeakMatchFailure(MatchFailure):\n    pass\nclass StrongMatchFailure(MatchFailure):\n    ...\nclass FormatSeq:\n    def __init__(self):",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "MatchFailure",
        "kind": 6,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "class MatchFailure(Exception):\n    pass\nclass WeakMatchFailure(MatchFailure):\n    pass\nclass StrongMatchFailure(MatchFailure):\n    ...\nclass FormatSeq:\n    def __init__(self):\n        self.left: FormatOp = None\n        self.right: FormatOp = None",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "WeakMatchFailure",
        "kind": 6,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "class WeakMatchFailure(MatchFailure):\n    pass\nclass StrongMatchFailure(MatchFailure):\n    ...\nclass FormatSeq:\n    def __init__(self):\n        self.left: FormatOp = None\n        self.right: FormatOp = None\n        self.active = True\n        self.line_lengths = [0]",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "StrongMatchFailure",
        "kind": 6,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "class StrongMatchFailure(MatchFailure):\n    ...\nclass FormatSeq:\n    def __init__(self):\n        self.left: FormatOp = None\n        self.right: FormatOp = None\n        self.active = True\n        self.line_lengths = [0]\n        self.max_line_len = 0\n        self.cost = 0",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "FormatSeq",
        "kind": 6,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "class FormatSeq:\n    def __init__(self):\n        self.left: FormatOp = None\n        self.right: FormatOp = None\n        self.active = True\n        self.line_lengths = [0]\n        self.max_line_len = 0\n        self.cost = 0\n    def __add__(self, other):\n        if other is None:",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "FormatOp",
        "kind": 6,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "class FormatOp:\n    def __init__(self):\n        self.next = None\nclass _Token(FormatOp):\n    def __init__(self, value):\n        super().__init__()\n        assert isinstance(value, str)\n        self.value = value\nclass Token(FormatSeq):\n    def __init__(self, value):",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "_Token",
        "kind": 6,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "class _Token(FormatOp):\n    def __init__(self, value):\n        super().__init__()\n        assert isinstance(value, str)\n        self.value = value\nclass Token(FormatSeq):\n    def __init__(self, value):\n        super().__init__()\n        self.left = self.right = _Token(value)\n        self.max_line_len = self.line_lengths[0] = len(value)",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "Token",
        "kind": 6,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "class Token(FormatSeq):\n    def __init__(self, value):\n        super().__init__()\n        self.left = self.right = _Token(value)\n        self.max_line_len = self.line_lengths[0] = len(value)\nclass _ChangeIndent(FormatOp):\n    def __init__(self, level):\n        super().__init__()\n        self.level = level\nclass ChangeIndent(FormatSeq):",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "_ChangeIndent",
        "kind": 6,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "class _ChangeIndent(FormatOp):\n    def __init__(self, level):\n        super().__init__()\n        self.level = level\nclass ChangeIndent(FormatSeq):\n    def __init__(self, level):\n        super().__init__()\n        self.left = self.right = _ChangeIndent(level)\nclass Newline(Token):\n    def __init__(self):",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "ChangeIndent",
        "kind": 6,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "class ChangeIndent(FormatSeq):\n    def __init__(self, level):\n        super().__init__()\n        self.left = self.right = _ChangeIndent(level)\nclass Newline(Token):\n    def __init__(self):\n        super().__init__(\"\\n\")\n        self.max_line_len = self.line_lengths[0] = 0\n        self.line_lengths.append(0)\nclass Space(Token):",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "Newline",
        "kind": 6,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "class Newline(Token):\n    def __init__(self):\n        super().__init__(\"\\n\")\n        self.max_line_len = self.line_lengths[0] = 0\n        self.line_lengths.append(0)\nclass Space(Token):\n    def __init__(self):\n        super().__init__(\" \")\nclass Formatter(ABC):\n    javastyle = False",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "Space",
        "kind": 6,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "class Space(Token):\n    def __init__(self):\n        super().__init__(\" \")\nclass Formatter(ABC):\n    javastyle = False\n    @staticmethod\n    def format(expr: Formatted, remaining: int) -> FormatSeq:\n        raise NotImplementedError()\n    @staticmethod\n    def set_javastyle(javastyle: bool):",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "Formatter",
        "kind": 6,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "class Formatter(ABC):\n    javastyle = False\n    @staticmethod\n    def format(expr: Formatted, remaining: int) -> FormatSeq:\n        raise NotImplementedError()\n    @staticmethod\n    def set_javastyle(javastyle: bool):\n        Formatter.javastyle = javastyle\nclass SpecialFormFormatter(Formatter, ABC):\n    @classmethod",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "SpecialFormFormatter",
        "kind": 6,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "class SpecialFormFormatter(Formatter, ABC):\n    @classmethod\n    def assert_form(cls, expr: Formatted, form: Union[str, List[str]]):\n        if isinstance(form, list):\n            for elem in form:\n                try:\n                    cls.assert_form(expr, elem)\n                except WeakMatchFailure:\n                    continue\n                else:",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "AlignedCondFormatter",
        "kind": 6,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "class AlignedCondFormatter(SpecialFormFormatter):\n    class Clause(Formatter):\n        @staticmethod\n        def format(expr: Formatted, remaining: int, max_pred_len: int = 0) -> FormatSeq:\n            if isinstance(expr, FormatComment):\n                return CommentFormatter.format(expr)\n            else:\n                out = Token(expr.prefix) + Token(expr.open_paren)\n                inlined_pred = InlineFormatter.format(expr.contents[0])\n                pred_len = len(expr.prefix) + inlined_pred.max_line_len",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "MultilineCondFormatter",
        "kind": 6,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "class MultilineCondFormatter(SpecialFormFormatter):\n    class Clause(Formatter):\n        @staticmethod\n        def format(expr: Formatted, remaining: int) -> FormatSeq:\n            if isinstance(expr, FormatList):\n                return NoHangingListFormatter.format(expr, remaining)\n            else:\n                return ExpressionFormatter.format(expr, remaining)\n    @classmethod\n    def format(cls, expr: Formatted, remaining) -> FormatSeq:",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "LetFormatter",
        "kind": 6,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "class LetFormatter(SpecialFormFormatter):\n    class LetHandler(Formatter):\n        def __init__(self):\n            self.bindings_next = True\n        def format(self, expr: Formatted, remaining: int) -> FormatSeq:\n            if isinstance(expr, FormatList) and self.bindings_next:\n                self.bindings_next = False\n                out = NoHangingListFormatter.format(expr, remaining)\n                out += ChangeIndent(-3)\n                return out",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "ProcedureFormatter",
        "kind": 6,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "class ProcedureFormatter(SpecialFormFormatter):\n    class ProcedureHandler(Formatter):\n        def __init__(self, indent_level):\n            self.formals_next = True\n            self.indent_level = indent_level\n        def format(self, expr: Formatted, remaining: int) -> FormatSeq:\n            out = ExpressionFormatter.format(expr, remaining)\n            if isinstance(expr, FormatList) and self.formals_next:\n                self.formals_next = False\n                out += ChangeIndent(2 - self.indent_level)",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "AtomFormatter",
        "kind": 6,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "class AtomFormatter(Formatter):\n    @staticmethod\n    def format(expr: Formatted, remaining: int = None) -> FormatSeq:\n        if not isinstance(expr, FormatAtom):\n            raise WeakMatchFailure(\"expr is not atomic\")\n        return Token(expr.prefix + expr.value)\nclass InlineFormatter(Formatter):\n    @staticmethod\n    def format(expr: Formatted, remaining: int = None) -> FormatSeq:\n        if isinstance(expr, FormatComment):",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "InlineFormatter",
        "kind": 6,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "class InlineFormatter(Formatter):\n    @staticmethod\n    def format(expr: Formatted, remaining: int = None) -> FormatSeq:\n        if isinstance(expr, FormatComment):\n            raise WeakMatchFailure(\"Cannot inline-format a comment\")\n        if isinstance(expr, FormatAtom):\n            return AtomFormatter.format(expr, remaining)\n        if SpecialFormFormatter.is_multiline(expr):\n            raise WeakMatchFailure(\"Cannot inline-format a multiline expr\")\n        formatted_exprs = [InlineFormatter.format(elem) for elem in expr.contents]",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "ListFormatter",
        "kind": 6,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "class ListFormatter(Formatter):\n    @staticmethod\n    def format(expr: Formatted, remaining: int) -> FormatSeq:\n        if not isinstance(expr, FormatList):\n            raise WeakMatchFailure(\"expr is not a list\")\n        return find_best(expr, [InlineFormatter, PrefixedListFormatter, CallExprFormatter, NoHangingListFormatter],\n                         remaining)\nclass CallExprFormatter(Formatter):\n    @staticmethod\n    def format(expr: FormatList, remaining: int) -> FormatSeq:",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "CallExprFormatter",
        "kind": 6,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "class CallExprFormatter(Formatter):\n    @staticmethod\n    def format(expr: FormatList, remaining: int) -> FormatSeq:\n        assert isinstance(expr, FormatList)\n        if len(expr.contents) <= 1:\n            raise WeakMatchFailure(\"Call expr must have at least 2 arguments, otherwise handle using DataListFormatter\")\n        if expr.prefix:\n            raise WeakMatchFailure(\"Call expr cannot be prefixed\")\n        if not isinstance(expr.contents[0], FormatAtom):\n            raise WeakMatchFailure(\"Unable to inline first two arguments, fallback to DataListFormatter\")",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "PrefixedListFormatter",
        "kind": 6,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "class PrefixedListFormatter(Formatter):\n    @staticmethod\n    def format(expr: FormatList, remaining: int):\n        assert isinstance(expr, FormatList)\n        if not expr.prefix:\n            raise WeakMatchFailure(\"Expr is not prefixed\")\n        with expr.hold_prefix() as prefix:\n            if prefix == \"`\":\n                ret = ListFormatter.format(expr, remaining - 1)\n            else:",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "DefaultCallExprFormatter",
        "kind": 6,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "class DefaultCallExprFormatter(Formatter):\n    @staticmethod\n    def format(expr: FormatList, remaining: int) -> FormatSeq:\n        operator = expr.contents[0]\n        assert isinstance(operator, FormatAtom)\n        indent_level = len(operator.value) + 2\n        out = Token(expr.open_paren)\n        out += AtomFormatter.format(operator)\n        out += ChangeIndent(indent_level) + Space()\n        out += rest_format(expr.contents[1:], remaining - indent_level,",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "DataFormatter",
        "kind": 6,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "class DataFormatter(Formatter):\n    @staticmethod\n    def format(expr: Formatted, remaining: int) -> FormatSeq:\n        if isinstance(expr, FormatComment):\n            return CommentFormatter.format(expr)\n        elif isinstance(expr, FormatAtom):\n            return AtomFormatter.format(expr)\n        else:\n            return NoHangingListFormatter.format(expr, remaining, DataFormatter)\nclass NoHangingListFormatter(Formatter):",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "NoHangingListFormatter",
        "kind": 6,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "class NoHangingListFormatter(Formatter):\n    @staticmethod\n    def format(expr: Formatted, remaining: int, callback: Type[Formatter] = None) -> FormatSeq:\n        if callback is None:\n            callback = ExpressionFormatter\n        if expr.prefix:\n            raise WeakMatchFailure(\"Cannot format prefixed datalist\")\n        out = Token(expr.open_paren) + ChangeIndent(1)\n        out += rest_format(expr.contents, remaining - 1,\n                           formatter=callback, indent_level=1, close_paren=expr.close_paren)",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "CommentFormatter",
        "kind": 6,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "class CommentFormatter(Formatter):\n    @staticmethod\n    def format(expr: Formatted, remaining: int = None) -> FormatSeq:\n        if not isinstance(expr, FormatComment):\n            raise WeakMatchFailure(\"Expr is not a comment\")\n        leading_space = \"\" if expr.value.startswith(\" \") else \" \"\n        return Token(expr.prefix + \";\" + leading_space + expr.value)\nclass ExpressionFormatter(Formatter):\n    @staticmethod\n    def format(expr: Formatted, remaining: int) -> FormatSeq:",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "ExpressionFormatter",
        "kind": 6,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "class ExpressionFormatter(Formatter):\n    @staticmethod\n    def format(expr: Formatted, remaining: int) -> FormatSeq:\n        candidates = [AtomFormatter, ListFormatter, CommentFormatter]\n        return find_best(expr, candidates, remaining)\nclass Best:\n    def __init__(self, remaining):\n        self.curr_best = None\n        self.curr_cost = None\n        self.remaining = remaining",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "Best",
        "kind": 6,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "class Best:\n    def __init__(self, remaining):\n        self.curr_best = None\n        self.curr_cost = None\n        self.remaining = remaining\n    def heuristic(self, chain: FormatSeq) -> int:\n        return max(0, chain.max_line_len - 50) + chain.cost\n    def add(self, formatted: FormatSeq):\n        cost = self.heuristic(formatted)\n        if self.curr_cost is None or cost < self.curr_cost:",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "prettify",
        "kind": 2,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "def prettify(strings: List[str], javastyle: bool = False) -> str:\n    out = []\n    for i, string in enumerate(strings):\n        if not string.strip():\n            continue\n        out.extend(prettify_single(string, javastyle))\n    raw_out = []\n    for expr in out:\n        if expr.startswith(\";\"):\n            raw_out.append(expr)",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "prettify_single",
        "kind": 2,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "def prettify_single(string: str, javastyle: bool) -> List[str]:\n    Formatter.set_javastyle(javastyle)\n    out = []\n    buff = lexer.TokenBuffer([string], True)\n    while not buff.done:\n        expr = get_expression(buff)\n        out.append(ExpressionFormatter.format(expr, LINE_LENGTH).stringify())\n    return out\nclass OptimalFormattingReached(Exception):\n    pass",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "find_best",
        "kind": 2,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "def find_best(raw: Formatted, candidates: List[Type[Formatter]], remaining) -> FormatSeq:\n    best = Best(remaining)\n    for candidate in candidates:\n        try:\n            best.add(candidate.format(raw, remaining))\n        except WeakMatchFailure as e:\n            continue\n        except StrongMatchFailure:\n            # TODO: Warn about potentially invalid special form\n            continue",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "rest_format",
        "kind": 2,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "def rest_format(exprs: List[Formatted],\n                *args,\n                formatter: Union[Formatter, Type[Formatter]] = ExpressionFormatter,\n                indent_level: int,\n                close_paren: str) -> Tuple[FormatSeq, bool]:\n    out = None\n    i = 0\n    while i != len(exprs):\n        curr_expr = exprs[i]\n        i += 1",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "LINE_LENGTH",
        "kind": 5,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "LINE_LENGTH = 50\nMAX_EXPR_COUNT = 10\nMAX_EXPR_LEN = 30\nINDENT = 4\nDEFINE_VALS = [\"define\", \"define-macro\"]\nDECLARE_VALS = [\"lambda\", \"mu\"]\nSHORTHAND = {\"quote\": \"'\", \"quasiquote\": \"`\", \"unquote\": \",\", \"unquote-splicing\": \",@\", \"variadic\": \".\"}\nMULTILINE_VALS = [\"let\", \"cond\", \"if\"]\nFREE_TOKENS = [\"if\", \"define\", \"define-macro\", \"mu\", \"lambda\"]\nOPEN_PARENS = [\"(\", \"[\"]",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "MAX_EXPR_COUNT",
        "kind": 5,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "MAX_EXPR_COUNT = 10\nMAX_EXPR_LEN = 30\nINDENT = 4\nDEFINE_VALS = [\"define\", \"define-macro\"]\nDECLARE_VALS = [\"lambda\", \"mu\"]\nSHORTHAND = {\"quote\": \"'\", \"quasiquote\": \"`\", \"unquote\": \",\", \"unquote-splicing\": \",@\", \"variadic\": \".\"}\nMULTILINE_VALS = [\"let\", \"cond\", \"if\"]\nFREE_TOKENS = [\"if\", \"define\", \"define-macro\", \"mu\", \"lambda\"]\nOPEN_PARENS = [\"(\", \"[\"]\nCLOSE_PARENS = [\")\", \"]\"]",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "MAX_EXPR_LEN",
        "kind": 5,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "MAX_EXPR_LEN = 30\nINDENT = 4\nDEFINE_VALS = [\"define\", \"define-macro\"]\nDECLARE_VALS = [\"lambda\", \"mu\"]\nSHORTHAND = {\"quote\": \"'\", \"quasiquote\": \"`\", \"unquote\": \",\", \"unquote-splicing\": \",@\", \"variadic\": \".\"}\nMULTILINE_VALS = [\"let\", \"cond\", \"if\"]\nFREE_TOKENS = [\"if\", \"define\", \"define-macro\", \"mu\", \"lambda\"]\nOPEN_PARENS = [\"(\", \"[\"]\nCLOSE_PARENS = [\")\", \"]\"]\nCACHE_SIZE = 2 ** 8",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "INDENT",
        "kind": 5,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "INDENT = 4\nDEFINE_VALS = [\"define\", \"define-macro\"]\nDECLARE_VALS = [\"lambda\", \"mu\"]\nSHORTHAND = {\"quote\": \"'\", \"quasiquote\": \"`\", \"unquote\": \",\", \"unquote-splicing\": \",@\", \"variadic\": \".\"}\nMULTILINE_VALS = [\"let\", \"cond\", \"if\"]\nFREE_TOKENS = [\"if\", \"define\", \"define-macro\", \"mu\", \"lambda\"]\nOPEN_PARENS = [\"(\", \"[\"]\nCLOSE_PARENS = [\")\", \"]\"]\nCACHE_SIZE = 2 ** 8\ndef prettify(strings: List[str], javastyle: bool = False) -> str:",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "DEFINE_VALS",
        "kind": 5,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "DEFINE_VALS = [\"define\", \"define-macro\"]\nDECLARE_VALS = [\"lambda\", \"mu\"]\nSHORTHAND = {\"quote\": \"'\", \"quasiquote\": \"`\", \"unquote\": \",\", \"unquote-splicing\": \",@\", \"variadic\": \".\"}\nMULTILINE_VALS = [\"let\", \"cond\", \"if\"]\nFREE_TOKENS = [\"if\", \"define\", \"define-macro\", \"mu\", \"lambda\"]\nOPEN_PARENS = [\"(\", \"[\"]\nCLOSE_PARENS = [\")\", \"]\"]\nCACHE_SIZE = 2 ** 8\ndef prettify(strings: List[str], javastyle: bool = False) -> str:\n    out = []",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "DECLARE_VALS",
        "kind": 5,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "DECLARE_VALS = [\"lambda\", \"mu\"]\nSHORTHAND = {\"quote\": \"'\", \"quasiquote\": \"`\", \"unquote\": \",\", \"unquote-splicing\": \",@\", \"variadic\": \".\"}\nMULTILINE_VALS = [\"let\", \"cond\", \"if\"]\nFREE_TOKENS = [\"if\", \"define\", \"define-macro\", \"mu\", \"lambda\"]\nOPEN_PARENS = [\"(\", \"[\"]\nCLOSE_PARENS = [\")\", \"]\"]\nCACHE_SIZE = 2 ** 8\ndef prettify(strings: List[str], javastyle: bool = False) -> str:\n    out = []\n    for i, string in enumerate(strings):",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "SHORTHAND",
        "kind": 5,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "SHORTHAND = {\"quote\": \"'\", \"quasiquote\": \"`\", \"unquote\": \",\", \"unquote-splicing\": \",@\", \"variadic\": \".\"}\nMULTILINE_VALS = [\"let\", \"cond\", \"if\"]\nFREE_TOKENS = [\"if\", \"define\", \"define-macro\", \"mu\", \"lambda\"]\nOPEN_PARENS = [\"(\", \"[\"]\nCLOSE_PARENS = [\")\", \"]\"]\nCACHE_SIZE = 2 ** 8\ndef prettify(strings: List[str], javastyle: bool = False) -> str:\n    out = []\n    for i, string in enumerate(strings):\n        if not string.strip():",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "MULTILINE_VALS",
        "kind": 5,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "MULTILINE_VALS = [\"let\", \"cond\", \"if\"]\nFREE_TOKENS = [\"if\", \"define\", \"define-macro\", \"mu\", \"lambda\"]\nOPEN_PARENS = [\"(\", \"[\"]\nCLOSE_PARENS = [\")\", \"]\"]\nCACHE_SIZE = 2 ** 8\ndef prettify(strings: List[str], javastyle: bool = False) -> str:\n    out = []\n    for i, string in enumerate(strings):\n        if not string.strip():\n            continue",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "FREE_TOKENS",
        "kind": 5,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "FREE_TOKENS = [\"if\", \"define\", \"define-macro\", \"mu\", \"lambda\"]\nOPEN_PARENS = [\"(\", \"[\"]\nCLOSE_PARENS = [\")\", \"]\"]\nCACHE_SIZE = 2 ** 8\ndef prettify(strings: List[str], javastyle: bool = False) -> str:\n    out = []\n    for i, string in enumerate(strings):\n        if not string.strip():\n            continue\n        out.extend(prettify_single(string, javastyle))",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "OPEN_PARENS",
        "kind": 5,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "OPEN_PARENS = [\"(\", \"[\"]\nCLOSE_PARENS = [\")\", \"]\"]\nCACHE_SIZE = 2 ** 8\ndef prettify(strings: List[str], javastyle: bool = False) -> str:\n    out = []\n    for i, string in enumerate(strings):\n        if not string.strip():\n            continue\n        out.extend(prettify_single(string, javastyle))\n    raw_out = []",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "CLOSE_PARENS",
        "kind": 5,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "CLOSE_PARENS = [\")\", \"]\"]\nCACHE_SIZE = 2 ** 8\ndef prettify(strings: List[str], javastyle: bool = False) -> str:\n    out = []\n    for i, string in enumerate(strings):\n        if not string.strip():\n            continue\n        out.extend(prettify_single(string, javastyle))\n    raw_out = []\n    for expr in out:",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "CACHE_SIZE",
        "kind": 5,
        "importPath": "lab.lab09.editor.formatter",
        "description": "lab.lab09.editor.formatter",
        "peekOfCode": "CACHE_SIZE = 2 ** 8\ndef prettify(strings: List[str], javastyle: bool = False) -> str:\n    out = []\n    for i, string in enumerate(strings):\n        if not string.strip():\n            continue\n        out.extend(prettify_single(string, javastyle))\n    raw_out = []\n    for expr in out:\n        if expr.startswith(\";\"):",
        "detail": "lab.lab09.editor.formatter",
        "documentation": {}
    },
    {
        "label": "FormatList",
        "kind": 6,
        "importPath": "lab.lab09.editor.format_parser",
        "description": "lab.lab09.editor.format_parser",
        "peekOfCode": "class FormatList:\n    def __init__(self,\n                 contents: List['Formatted'],\n                 close_paren,\n                 prefix: str=\"\"):\n        self.contents = contents\n        self.open_paren = \"(\" if close_paren == \")\" else \"[\"\n        self.close_paren = close_paren\n        self.prefix = prefix\n    class PrefixManager:",
        "detail": "lab.lab09.editor.format_parser",
        "documentation": {}
    },
    {
        "label": "FormatAtom",
        "kind": 6,
        "importPath": "lab.lab09.editor.format_parser",
        "description": "lab.lab09.editor.format_parser",
        "peekOfCode": "class FormatAtom:\n    def __init__(self, value: str):\n        self.value = value\n        self.prefix = \"\"\nclass FormatComment:\n    def __init__(self, value: str, allow_inline: bool):\n        self.value = value\n        self.prefix = \"\"\n        self.allow_inline = allow_inline\nFormatted = Union[FormatList, FormatAtom, FormatComment]",
        "detail": "lab.lab09.editor.format_parser",
        "documentation": {}
    },
    {
        "label": "FormatComment",
        "kind": 6,
        "importPath": "lab.lab09.editor.format_parser",
        "description": "lab.lab09.editor.format_parser",
        "peekOfCode": "class FormatComment:\n    def __init__(self, value: str, allow_inline: bool):\n        self.value = value\n        self.prefix = \"\"\n        self.allow_inline = allow_inline\nFormatted = Union[FormatList, FormatAtom, FormatComment]\ndef get_expression(buffer: TokenBuffer) -> Formatted:\n    token = buffer.pop_next_token()\n    if isinstance(token, Comment):\n        return FormatComment(token.value, not token.first_in_line)",
        "detail": "lab.lab09.editor.format_parser",
        "documentation": {}
    },
    {
        "label": "get_expression",
        "kind": 2,
        "importPath": "lab.lab09.editor.format_parser",
        "description": "lab.lab09.editor.format_parser",
        "peekOfCode": "def get_expression(buffer: TokenBuffer) -> Formatted:\n    token = buffer.pop_next_token()\n    if isinstance(token, Comment):\n        return FormatComment(token.value, not token.first_in_line)\n    elif token == \"#\" and not buffer.done and buffer.get_next_token() == \"[\":\n        buffer.pop_next_token()\n        out = FormatAtom(\"#[\" + buffer.pop_next_token().value + \"]\")\n        buffer.pop_next_token()\n    elif token in SPECIALS:\n        if token in (\"(\", \"[\"):",
        "detail": "lab.lab09.editor.format_parser",
        "documentation": {}
    },
    {
        "label": "get_rest_of_list",
        "kind": 2,
        "importPath": "lab.lab09.editor.format_parser",
        "description": "lab.lab09.editor.format_parser",
        "peekOfCode": "def get_rest_of_list(buffer: TokenBuffer, end_paren: str):\n    out = []\n    while buffer.get_next_token() != end_paren:\n        out.append(get_expression(buffer))\n    buffer.pop_next_token()\n    return FormatList(out, end_paren)",
        "detail": "lab.lab09.editor.format_parser",
        "documentation": {}
    },
    {
        "label": "Formatted",
        "kind": 5,
        "importPath": "lab.lab09.editor.format_parser",
        "description": "lab.lab09.editor.format_parser",
        "peekOfCode": "Formatted = Union[FormatList, FormatAtom, FormatComment]\ndef get_expression(buffer: TokenBuffer) -> Formatted:\n    token = buffer.pop_next_token()\n    if isinstance(token, Comment):\n        return FormatComment(token.value, not token.first_in_line)\n    elif token == \"#\" and not buffer.done and buffer.get_next_token() == \"[\":\n        buffer.pop_next_token()\n        out = FormatAtom(\"#[\" + buffer.pop_next_token().value + \"]\")\n        buffer.pop_next_token()\n    elif token in SPECIALS:",
        "detail": "lab.lab09.editor.format_parser",
        "documentation": {}
    },
    {
        "label": "Move",
        "kind": 6,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "class Move:\n    def __init__(self, stroke, fill):\n        self.stroke = stroke\n        self.fill = fill\n        self.seq = []\n    def export(self):\n        return {\n            \"seq\": \" \".join(self.seq),\n            \"stroke\": self.stroke,\n            \"fill\": self.fill,",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "Canvas",
        "kind": 6,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "class Canvas:\n    SIZE = 1024\n    def __init__(self):\n        self.x = None\n        self.y = None\n        self.angle = None\n        self.bg_color = None\n        self.moves: List[Move] = None\n        self.fill_move: Optional[Move] = None\n        self.pen_down = None",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "Backward",
        "kind": 6,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "class Backward(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if not isinstance(operand, Number):\n            raise OperandDeduceError(f\"Expected operand to be Number, not {operand}\")\n        log.logger.get_canvas().forward(-operand.value)\n        return Undefined\n@global_attr(\"begin_fill\")\nclass BeginFill(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 0, len(operands))",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "BeginFill",
        "kind": 6,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "class BeginFill(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 0, len(operands))\n        log.logger.get_canvas().begin_fill()\n        return Undefined\n@global_attr(\"bgcolor\")\nclass BGColor(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression):\n        log.logger.get_canvas().set_bg(make_color(operand))\n        return Undefined",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "BGColor",
        "kind": 6,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "class BGColor(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression):\n        log.logger.get_canvas().set_bg(make_color(operand))\n        return Undefined\n@global_attr(\"circle\")\nclass Circle(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_min_callable_length(self, 1, len(operands))\n        if len(operands) > 2:\n            verify_exact_callable_length(self, 2, len(operands))",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "Circle",
        "kind": 6,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "class Circle(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_min_callable_length(self, 1, len(operands))\n        if len(operands) > 2:\n            verify_exact_callable_length(self, 2, len(operands))\n        if not isinstance(operands[0], Number):\n            raise OperandDeduceError(f\"Expected radius to be Number, not {operands[0]}\")\n        if len(operands) > 2 and not isinstance(operands[1], Number):\n            raise OperandDeduceError(f\"Expected angle to be Number, not {operands[1]}\")\n        degs = 360 if len(operands) == 1 else operands[1].value",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "Clear",
        "kind": 6,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "class Clear(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 0, len(operands))\n        log.logger.get_canvas().reset()\n        return Undefined\n@global_attr(\"color\")\nclass Color(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression):\n        log.logger.get_canvas().set_color(make_color(operand))\n        return Undefined",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "Color",
        "kind": 6,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "class Color(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression):\n        log.logger.get_canvas().set_color(make_color(operand))\n        return Undefined\n@global_attr(\"end_fill\")\nclass EndFill(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 0, len(operands))\n        log.logger.get_canvas().end_fill()\n        return Undefined",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "EndFill",
        "kind": 6,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "class EndFill(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 0, len(operands))\n        log.logger.get_canvas().end_fill()\n        return Undefined\n@global_attr(\"exitonclick\")\nclass ExitOnClick(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 0, len(operands))\n        return Undefined",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "ExitOnClick",
        "kind": 6,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "class ExitOnClick(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 0, len(operands))\n        return Undefined\n@global_attr(\"forward\")\n@global_attr(\"fd\")\nclass Forward(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if not isinstance(operand, Number):\n            raise OperandDeduceError(f\"Expected operand to be Number, not {operand}\")",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "Forward",
        "kind": 6,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "class Forward(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if not isinstance(operand, Number):\n            raise OperandDeduceError(f\"Expected operand to be Number, not {operand}\")\n        log.logger.get_canvas().forward(operand.value)\n        return Undefined\n@global_attr(\"hideturtle\")\n@global_attr(\"ht\")\nclass HideTurtle(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "HideTurtle",
        "kind": 6,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "class HideTurtle(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 0, len(operands))\n        log.logger.get_canvas().hide_turtle()\n        return Undefined\n@global_attr(\"left\")\n@global_attr(\"lt\")\nclass Left(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if not isinstance(operand, Number):",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "Left",
        "kind": 6,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "class Left(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if not isinstance(operand, Number):\n            raise OperandDeduceError(f\"Expected operand to be Number, not {operand}\")\n        log.logger.get_canvas().rotate(operand.value)\n        return Undefined\n@global_attr(\"pendown\")\n@global_attr(\"pd\")\nclass PenDown(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "PenDown",
        "kind": 6,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "class PenDown(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 0, len(operands))\n        log.logger.get_canvas().pendown()\n        return Undefined\n@global_attr(\"penup\")\n@global_attr(\"pu\")\nclass PenUp(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 0, len(operands))",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "PenUp",
        "kind": 6,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "class PenUp(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 0, len(operands))\n        log.logger.get_canvas().penup()\n        return Undefined\n@global_attr(\"pixel\")\nclass Pixel(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 3, len(operands))\n        x, y, c, = operands",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "Pixel",
        "kind": 6,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "class Pixel(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 3, len(operands))\n        x, y, c, = operands\n        for v in x, y:\n            if not isinstance(v, Number):\n                raise OperandDeduceError(f\"Expected operand to be Number, not {v}\")\n        log.logger.get_canvas().pixel(x.value, y.value, make_color(c))\n        return Undefined\n@global_attr(\"pixelsize\")",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "PixelSize",
        "kind": 6,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "class PixelSize(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if not isinstance(operand, Number):\n            raise OperandDeduceError(f\"Expected operand to be Number, not {operand}\")\n        log.logger.get_canvas().set_pixel_size(operand.value)\n        return Undefined\n@global_attr(\"rgb\")\nclass RGB(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 3, len(operands))",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "RGB",
        "kind": 6,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "class RGB(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 3, len(operands))\n        for operand in operands:\n            if not isinstance(operand, Number):\n                raise OperandDeduceError(f\"Expected operand to be Number, not {operand}\")\n            if not 0 <= operand.value <= 1:\n                raise OperandDeduceError(f\"RGB values must be between 0 and 1, not {operand}\")\n        return String(\"#\" + \"\".join('{:02X}'.format(int(x.value * 255)) for x in operands))\n@global_attr(\"right\")",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "Right",
        "kind": 6,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "class Right(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if not isinstance(operand, Number):\n            raise OperandDeduceError(f\"Expected operand to be Number, not {operand}\")\n        log.logger.get_canvas().rotate(-operand.value)\n        return Undefined\n@global_attr(\"screen_width\")\n@global_attr(\"screen_height\")\nclass ScreenSize(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "ScreenSize",
        "kind": 6,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "class ScreenSize(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 0, len(operands))\n        return Number(log.logger.get_canvas().SIZE)\n@global_attr(\"setheading\")\n@global_attr(\"seth\")\nclass SetHeading(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if not isinstance(operand, Number):\n            raise OperandDeduceError(f\"Expected operand to be Number, not {operand}\")",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "SetHeading",
        "kind": 6,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "class SetHeading(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if not isinstance(operand, Number):\n            raise OperandDeduceError(f\"Expected operand to be Number, not {operand}\")\n        log.logger.get_canvas().abs_rotate(90 - operand.value)\n        return Undefined\n@global_attr(\"setposition\")\n@global_attr(\"setpos\")\n@global_attr(\"goto\")\nclass SetPosition(BuiltIn):",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "SetPosition",
        "kind": 6,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "class SetPosition(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame):\n        verify_exact_callable_length(self, 2, len(operands))\n        for operand in operands:\n            if not isinstance(operand, Number):\n                raise OperandDeduceError(f\"Expected operand to be Number, not {operand}\")\n        log.logger.get_canvas().move(operands[0].value, -operands[1].value)\n        return Undefined\n@global_attr(\"showturtle\")\n@global_attr(\"st\")",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "ShowTurtle",
        "kind": 6,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "class ShowTurtle(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 0, len(operands))\n        log.logger.get_canvas().show_turtle()\n        return Undefined\n@global_attr(\"speed\")\nclass Speed(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if not isinstance(operand, Number):\n            raise OperandDeduceError(f\"Expected operand to be Number, not {operand}\")",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "Speed",
        "kind": 6,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "class Speed(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if not isinstance(operand, Number):\n            raise OperandDeduceError(f\"Expected operand to be Number, not {operand}\")\n        return Undefined",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "make_action",
        "kind": 2,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "def make_action(command: str, *params: float) -> str:\n    return command + \" \" + \" \".join(str(param) for param in params)\ndef graphics_fragile(func):\n    def out(*args, **kwargs):\n        if log.logger.fragile:\n            raise IrreversibleOperationError()\n        return func(*args, **kwargs)\n    return out\nclass Move:\n    def __init__(self, stroke, fill):",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "graphics_fragile",
        "kind": 2,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "def graphics_fragile(func):\n    def out(*args, **kwargs):\n        if log.logger.fragile:\n            raise IrreversibleOperationError()\n        return func(*args, **kwargs)\n    return out\nclass Move:\n    def __init__(self, stroke, fill):\n        self.stroke = stroke\n        self.fill = fill",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "make_color",
        "kind": 2,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "def make_color(expression: Expression) -> str:\n    if not isinstance(expression, String) and not isinstance(expression, Symbol):\n        raise OperandDeduceError(f\"Expected a String or Symbol, received {expression}.\")\n    color = expression.value.lower()\n    # regex from https://stackoverflow.com/questions/30241375/python-how-to-check-if-string-is-a-hex-color-code\n    if color not in COLORS and not re.search(r'^#(?:[0-9a-fA-F]{3}){1,2}$', color):\n        raise OperandDeduceError(f\"Expected a valid CSS or hex color code, received {expression}.\")\n    return color\n@global_attr(\"backward\")\n@global_attr(\"back\")",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "ABSOLUTE_MOVE",
        "kind": 5,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "ABSOLUTE_MOVE = \"M\"\nRELATIVE_MOVE = \"m\"\nABSOLUTE_LINE = \"L\"\nRELATIVE_LINE = \"l\"\nCOMPLETE_PATH = \"Z\"\nABSOLUTE_ARC = \"A\"\nRELATIVE_ARC = \"a\"\ndef make_action(command: str, *params: float) -> str:\n    return command + \" \" + \" \".join(str(param) for param in params)\ndef graphics_fragile(func):",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "RELATIVE_MOVE",
        "kind": 5,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "RELATIVE_MOVE = \"m\"\nABSOLUTE_LINE = \"L\"\nRELATIVE_LINE = \"l\"\nCOMPLETE_PATH = \"Z\"\nABSOLUTE_ARC = \"A\"\nRELATIVE_ARC = \"a\"\ndef make_action(command: str, *params: float) -> str:\n    return command + \" \" + \" \".join(str(param) for param in params)\ndef graphics_fragile(func):\n    def out(*args, **kwargs):",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "ABSOLUTE_LINE",
        "kind": 5,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "ABSOLUTE_LINE = \"L\"\nRELATIVE_LINE = \"l\"\nCOMPLETE_PATH = \"Z\"\nABSOLUTE_ARC = \"A\"\nRELATIVE_ARC = \"a\"\ndef make_action(command: str, *params: float) -> str:\n    return command + \" \" + \" \".join(str(param) for param in params)\ndef graphics_fragile(func):\n    def out(*args, **kwargs):\n        if log.logger.fragile:",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "RELATIVE_LINE",
        "kind": 5,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "RELATIVE_LINE = \"l\"\nCOMPLETE_PATH = \"Z\"\nABSOLUTE_ARC = \"A\"\nRELATIVE_ARC = \"a\"\ndef make_action(command: str, *params: float) -> str:\n    return command + \" \" + \" \".join(str(param) for param in params)\ndef graphics_fragile(func):\n    def out(*args, **kwargs):\n        if log.logger.fragile:\n            raise IrreversibleOperationError()",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "COMPLETE_PATH",
        "kind": 5,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "COMPLETE_PATH = \"Z\"\nABSOLUTE_ARC = \"A\"\nRELATIVE_ARC = \"a\"\ndef make_action(command: str, *params: float) -> str:\n    return command + \" \" + \" \".join(str(param) for param in params)\ndef graphics_fragile(func):\n    def out(*args, **kwargs):\n        if log.logger.fragile:\n            raise IrreversibleOperationError()\n        return func(*args, **kwargs)",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "ABSOLUTE_ARC",
        "kind": 5,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "ABSOLUTE_ARC = \"A\"\nRELATIVE_ARC = \"a\"\ndef make_action(command: str, *params: float) -> str:\n    return command + \" \" + \" \".join(str(param) for param in params)\ndef graphics_fragile(func):\n    def out(*args, **kwargs):\n        if log.logger.fragile:\n            raise IrreversibleOperationError()\n        return func(*args, **kwargs)\n    return out",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "RELATIVE_ARC",
        "kind": 5,
        "importPath": "lab.lab09.editor.graphics",
        "description": "lab.lab09.editor.graphics",
        "peekOfCode": "RELATIVE_ARC = \"a\"\ndef make_action(command: str, *params: float) -> str:\n    return command + \" \" + \" \".join(str(param) for param in params)\ndef graphics_fragile(func):\n    def out(*args, **kwargs):\n        if log.logger.fragile:\n            raise IrreversibleOperationError()\n        return func(*args, **kwargs)\n    return out\nclass Move:",
        "detail": "lab.lab09.editor.graphics",
        "documentation": {}
    },
    {
        "label": "pair_to_list",
        "kind": 2,
        "importPath": "lab.lab09.editor.helper",
        "description": "lab.lab09.editor.helper",
        "peekOfCode": "def pair_to_list(pos: Pair) -> List[Expression]:\n    out = []\n    while pos is not Nil:\n        if not isinstance(pos, Pair):\n            raise OperandDeduceError(f\"List terminated with '{pos}', not nil\")\n        out.append(pos.first)\n        pos = pos.rest\n    return out\ndef dotted_pair_to_list(pos: Expression) -> Tuple[List[Expression], Optional[Expression]]:\n    out = []",
        "detail": "lab.lab09.editor.helper",
        "documentation": {}
    },
    {
        "label": "dotted_pair_to_list",
        "kind": 2,
        "importPath": "lab.lab09.editor.helper",
        "description": "lab.lab09.editor.helper",
        "peekOfCode": "def dotted_pair_to_list(pos: Expression) -> Tuple[List[Expression], Optional[Expression]]:\n    out = []\n    vararg = None\n    while pos is not Nil:\n        if not isinstance(pos, Pair):\n            vararg = pos\n            break\n        out.append(pos.first)\n        pos = pos.rest\n    return out, vararg",
        "detail": "lab.lab09.editor.helper",
        "documentation": {}
    },
    {
        "label": "assert_all_numbers",
        "kind": 2,
        "importPath": "lab.lab09.editor.helper",
        "description": "lab.lab09.editor.helper",
        "peekOfCode": "def assert_all_numbers(operands):\n    for operand in operands:\n        if not isinstance(operand, Number):\n            raise MathError(f\"Unable to perform arithmetic, as {operand} is not a number.\")\ndef verify_exact_callable_length(operator: Expression, expected: int, actual: int):\n    if expected != actual:\n        raise CallableResolutionError(f\"{operator} expected {expected} operands, received {actual}.\")\ndef verify_min_callable_length(operator: Expression, expected: int, actual: int):\n    if expected > actual:\n        raise CallableResolutionError(f\"{operator} expected at least {expected} operands, received {actual}.\")",
        "detail": "lab.lab09.editor.helper",
        "documentation": {}
    },
    {
        "label": "verify_exact_callable_length",
        "kind": 2,
        "importPath": "lab.lab09.editor.helper",
        "description": "lab.lab09.editor.helper",
        "peekOfCode": "def verify_exact_callable_length(operator: Expression, expected: int, actual: int):\n    if expected != actual:\n        raise CallableResolutionError(f\"{operator} expected {expected} operands, received {actual}.\")\ndef verify_min_callable_length(operator: Expression, expected: int, actual: int):\n    if expected > actual:\n        raise CallableResolutionError(f\"{operator} expected at least {expected} operands, received {actual}.\")\ndef make_list(exprs: List[Expression], last: Expression = Nil) -> Union[Pair, NilType]:\n    out = last\n    for expr in reversed(exprs):\n        out = Pair(expr, out)",
        "detail": "lab.lab09.editor.helper",
        "documentation": {}
    },
    {
        "label": "verify_min_callable_length",
        "kind": 2,
        "importPath": "lab.lab09.editor.helper",
        "description": "lab.lab09.editor.helper",
        "peekOfCode": "def verify_min_callable_length(operator: Expression, expected: int, actual: int):\n    if expected > actual:\n        raise CallableResolutionError(f\"{operator} expected at least {expected} operands, received {actual}.\")\ndef make_list(exprs: List[Expression], last: Expression = Nil) -> Union[Pair, NilType]:\n    out = last\n    for expr in reversed(exprs):\n        out = Pair(expr, out)\n    return out",
        "detail": "lab.lab09.editor.helper",
        "documentation": {}
    },
    {
        "label": "make_list",
        "kind": 2,
        "importPath": "lab.lab09.editor.helper",
        "description": "lab.lab09.editor.helper",
        "peekOfCode": "def make_list(exprs: List[Expression], last: Expression = Nil) -> Union[Pair, NilType]:\n    out = last\n    for expr in reversed(exprs):\n        out = Pair(expr, out)\n    return out",
        "detail": "lab.lab09.editor.helper",
        "documentation": {}
    },
    {
        "label": "Token",
        "kind": 6,
        "importPath": "lab.lab09.editor.lexer",
        "description": "lab.lab09.editor.lexer",
        "peekOfCode": "class Token:\n    def __init__(self, value: str):\n        self.value = value\n    def __eq__(self, other):\n        return other == self.value\n    def __hash__(self):\n        return hash(self.value)\n    def __repr__(self):\n        return repr(self.value)\n    def __str__(self):",
        "detail": "lab.lab09.editor.lexer",
        "documentation": {}
    },
    {
        "label": "Comment",
        "kind": 6,
        "importPath": "lab.lab09.editor.lexer",
        "description": "lab.lab09.editor.lexer",
        "peekOfCode": "class Comment(Token):\n    def __init__(self, value: str, first_in_line: bool):\n        super().__init__(value)\n        self.first_in_line = first_in_line\nclass TokenBuffer:\n    def __init__(self, lines, do_comments=False, ignore_brackets=False):\n        self.string = \"\\n\".join(lines)\n        self.tokens = tokenize(self.string, do_comments, ignore_brackets)\n        self.done = not self.tokens\n        self.i = 0",
        "detail": "lab.lab09.editor.lexer",
        "documentation": {}
    },
    {
        "label": "TokenBuffer",
        "kind": 6,
        "importPath": "lab.lab09.editor.lexer",
        "description": "lab.lab09.editor.lexer",
        "peekOfCode": "class TokenBuffer:\n    def __init__(self, lines, do_comments=False, ignore_brackets=False):\n        self.string = \"\\n\".join(lines)\n        self.tokens = tokenize(self.string, do_comments, ignore_brackets)\n        self.done = not self.tokens\n        self.i = 0\n    def get_next_token(self) -> Token:\n        if self.done:\n            raise ParseError(\"Incomplete expression, probably due to unmatched parentheses.\")\n        return self.tokens[self.i]",
        "detail": "lab.lab09.editor.lexer",
        "documentation": {}
    },
    {
        "label": "tokenize",
        "kind": 2,
        "importPath": "lab.lab09.editor.lexer",
        "description": "lab.lab09.editor.lexer",
        "peekOfCode": "def tokenize(string, do_comments, ignore_brackets) -> List[Token]:\n    string = string.strip()\n    tokens = []\n    i = 0\n    first_in_line = True\n    def _get_token():\n        \"\"\"Always starts at a non-space character\"\"\"\n        nonlocal i\n        if i == len(string):\n            return",
        "detail": "lab.lab09.editor.lexer",
        "documentation": {}
    },
    {
        "label": "SPECIALS",
        "kind": 5,
        "importPath": "lab.lab09.editor.lexer",
        "description": "lab.lab09.editor.lexer",
        "peekOfCode": "SPECIALS = [\"(\", \")\", \"[\", \"]\", \"'\", \"`\", \",\", \"@\", \"\\\"\", \";\"]\nclass Token:\n    def __init__(self, value: str):\n        self.value = value\n    def __eq__(self, other):\n        return other == self.value\n    def __hash__(self):\n        return hash(self.value)\n    def __repr__(self):\n        return repr(self.value)",
        "detail": "lab.lab09.editor.lexer",
        "documentation": {}
    },
    {
        "label": "Append",
        "kind": 6,
        "importPath": "lab.lab09.editor.lists",
        "description": "lab.lab09.editor.lists",
        "peekOfCode": "class Append(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        if len(operands) == 0:\n            return Nil\n        exprs = []\n        for operand in operands[:-1]:\n            if not isinstance(operand, Pair) and operand is not Nil:\n                raise OperandDeduceError(f\"Expected operand to be valid list, not {operand}\")\n            exprs.extend(pair_to_list(operand))\n        out = operands[-1]",
        "detail": "lab.lab09.editor.lists",
        "documentation": {}
    },
    {
        "label": "Car",
        "kind": 6,
        "importPath": "lab.lab09.editor.lists",
        "description": "lab.lab09.editor.lists",
        "peekOfCode": "class Car(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if isinstance(operand, Pair):\n            return operand.first\n        else:\n            raise OperandDeduceError(f\"Unable to extract first element, as {operand} is not a Pair.\")\n@global_attr(\"cdr\")\nclass Cdr(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if isinstance(operand, Pair):",
        "detail": "lab.lab09.editor.lists",
        "documentation": {}
    },
    {
        "label": "Cdr",
        "kind": 6,
        "importPath": "lab.lab09.editor.lists",
        "description": "lab.lab09.editor.lists",
        "peekOfCode": "class Cdr(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if isinstance(operand, Pair):\n            return operand.rest\n        else:\n            raise OperandDeduceError(f\"Unable to extract second element, as {operand} is not a Pair.\")\n@global_attr(\"cons\")\nclass Cons(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))",
        "detail": "lab.lab09.editor.lists",
        "documentation": {}
    },
    {
        "label": "Cons",
        "kind": 6,
        "importPath": "lab.lab09.editor.lists",
        "description": "lab.lab09.editor.lists",
        "peekOfCode": "class Cons(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        return Pair(operands[0], operands[1])\n@global_attr(\"length\")\nclass Length(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if not isinstance(operand, Pair) and operand is not Nil:\n            raise OperandDeduceError(f\"Unable to calculate length, as {operand} is not a valid list.\")\n        return Number(len(pair_to_list(operand)))",
        "detail": "lab.lab09.editor.lists",
        "documentation": {}
    },
    {
        "label": "Length",
        "kind": 6,
        "importPath": "lab.lab09.editor.lists",
        "description": "lab.lab09.editor.lists",
        "peekOfCode": "class Length(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if not isinstance(operand, Pair) and operand is not Nil:\n            raise OperandDeduceError(f\"Unable to calculate length, as {operand} is not a valid list.\")\n        return Number(len(pair_to_list(operand)))\n# @global_attr(\"map\")\n# class Map(BuiltIn):\n#     def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n#         verify_exact_callable_length(self, 2, len(operands))\n#",
        "detail": "lab.lab09.editor.lists",
        "documentation": {}
    },
    {
        "label": "MakeList",
        "kind": 6,
        "importPath": "lab.lab09.editor.lists",
        "description": "lab.lab09.editor.lists",
        "peekOfCode": "class MakeList(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        return make_list(operands)\n@global_attr(\"set-car!\")\nclass SetCar(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        if log.logger.fragile:\n            raise IrreversibleOperationError()\n        pair, val = operands",
        "detail": "lab.lab09.editor.lists",
        "documentation": {}
    },
    {
        "label": "SetCar",
        "kind": 6,
        "importPath": "lab.lab09.editor.lists",
        "description": "lab.lab09.editor.lists",
        "peekOfCode": "class SetCar(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        if log.logger.fragile:\n            raise IrreversibleOperationError()\n        pair, val = operands\n        if not isinstance(pair, Pair):\n            raise OperandDeduceError(f\"set-car! expected a Pair, received {pair}.\")\n        pair.first = val\n        log.logger.raw_out(\"WARNING: Mutation operations on pairs are not yet supported by the debugger.\")",
        "detail": "lab.lab09.editor.lists",
        "documentation": {}
    },
    {
        "label": "SetCdr",
        "kind": 6,
        "importPath": "lab.lab09.editor.lists",
        "description": "lab.lab09.editor.lists",
        "peekOfCode": "class SetCdr(BuiltIn):\n        def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n            verify_exact_callable_length(self, 2, len(operands))\n            if log.logger.fragile:\n                raise IrreversibleOperationError()\n            pair, val = operands\n            if not isinstance(pair, Pair):\n                raise OperandDeduceError(f\"set-cdr! expected a Pair, received {pair}.\")\n            if not isinstance(val, (Pair, Promise, NilType)):\n                raise OperandDeduceError(f\"Unable to assign {val} to cdr, expected a Pair, Nil, or Promise.\")",
        "detail": "lab.lab09.editor.lists",
        "documentation": {}
    },
    {
        "label": "Handler",
        "kind": 6,
        "importPath": "lab.lab09.editor.local_server",
        "description": "lab.lab09.editor.local_server",
        "peekOfCode": "class Handler(server.BaseHTTPRequestHandler):\n    cancellation_event = threading.Event()  # Shared across all instances, because the threading mixin creates a new instance every time...\n    def do_POST(self):\n        content_length = int(self.headers['Content-Length'])\n        raw_data = self.rfile.read(content_length)\n        data = urllib.parse.parse_qs(raw_data.decode(\"ascii\"))\n        path = urllib.parse.unquote(self.path)\n        result = self.handle_post_thread(data, path)\n        return result\n    def handle_post_thread(self, data, path):",
        "detail": "lab.lab09.editor.local_server",
        "documentation": {}
    },
    {
        "label": "ThreadedHTTPServer",
        "kind": 6,
        "importPath": "lab.lab09.editor.local_server",
        "description": "lab.lab09.editor.local_server",
        "peekOfCode": "class ThreadedHTTPServer(socketserver.ThreadingMixIn, server.HTTPServer):\n    daemon_threads = True\ndef start(file_args, port, open_browser):\n    global main_files\n    main_files = file_args\n    global PORT\n    PORT = port\n    socketserver.TCPServer.allow_reuse_address = True\n    e = None\n    for port in range(PORT, PORT + 10):",
        "detail": "lab.lab09.editor.local_server",
        "documentation": {}
    },
    {
        "label": "merge",
        "kind": 2,
        "importPath": "lab.lab09.editor.local_server",
        "description": "lab.lab09.editor.local_server",
        "peekOfCode": "def merge(states, new_states):\n    for i, new_state in enumerate(new_states):\n        if i == len(states):\n            states.append(new_state)\n        else:\n            for key, val in new_state.items():\n                states[i][key] = val\ndef cancelable_subprocess_call(cancellation_event, *args, **kwargs):\n    buffered = io.BytesIO()\n    with subprocess.Popen(*args, **kwargs) as proc:",
        "detail": "lab.lab09.editor.local_server",
        "documentation": {}
    },
    {
        "label": "cancelable_subprocess_call",
        "kind": 2,
        "importPath": "lab.lab09.editor.local_server",
        "description": "lab.lab09.editor.local_server",
        "peekOfCode": "def cancelable_subprocess_call(cancellation_event, *args, **kwargs):\n    buffered = io.BytesIO()\n    with subprocess.Popen(*args, **kwargs) as proc:\n        proc.stdin.close()\n        def pipeline(source, *sinks):  # We need this extra thread because there's no cross-platform way to poll a process's stdout\n            while True:\n                s = source.readline()\n                if not s: break\n                for sink in sinks:\n                    sink.write(s)",
        "detail": "lab.lab09.editor.local_server",
        "documentation": {}
    },
    {
        "label": "handle",
        "kind": 2,
        "importPath": "lab.lab09.editor.local_server",
        "description": "lab.lab09.editor.local_server",
        "peekOfCode": "def handle(code, curr_i, curr_f, global_frame_id, visualize_tail_calls, cancellation_event):\n    try:\n        global_frame = log.logger.frame_lookup.get(global_frame_id, None)\n        log.logger.new_query(global_frame, curr_i, curr_f)\n        scheme_limiter(cancellation_event,\n                       execution.string_exec,\n                       code, log.logger.out,\n                       visualize_tail_calls,\n                       global_frame.base if global_frame_id != -1 else None)\n    except OperationCanceledException:",
        "detail": "lab.lab09.editor.local_server",
        "documentation": {}
    },
    {
        "label": "instant",
        "kind": 2,
        "importPath": "lab.lab09.editor.local_server",
        "description": "lab.lab09.editor.local_server",
        "peekOfCode": "def instant(code, global_frame_id):\n    global_frame = log.logger.frame_lookup[global_frame_id]\n    log.logger.new_query(global_frame)\n    try:\n        log.logger.preview_mode(True)\n        scheme_limiter(0.3, execution.string_exec, code, log.logger.out, False, global_frame.base)\n    except (SchemeError, ZeroDivisionError) as e:\n        log.logger.out(e)\n    except TimeLimitException:\n        pass",
        "detail": "lab.lab09.editor.local_server",
        "documentation": {}
    },
    {
        "label": "supports_color",
        "kind": 2,
        "importPath": "lab.lab09.editor.local_server",
        "description": "lab.lab09.editor.local_server",
        "peekOfCode": "def supports_color():\n    \"\"\"\n    Returns True if the running system's terminal supports color, and False\n    otherwise.\n    \"\"\"\n    plat = sys.platform\n    supported_platform = plat != 'Pocket PC' and (plat != 'win32' or\n                                                  'ANSICON' in os.environ)\n    # isatty is not always implemented, #6223.\n    is_a_tty = hasattr(sys.stdout, 'isatty') and sys.stdout.isatty()",
        "detail": "lab.lab09.editor.local_server",
        "documentation": {}
    },
    {
        "label": "start",
        "kind": 2,
        "importPath": "lab.lab09.editor.local_server",
        "description": "lab.lab09.editor.local_server",
        "peekOfCode": "def start(file_args, port, open_browser):\n    global main_files\n    main_files = file_args\n    global PORT\n    PORT = port\n    socketserver.TCPServer.allow_reuse_address = True\n    e = None\n    for port in range(PORT, PORT + 10):\n        request = Request(f\"http://127.0.0.1:{port}/kill\", method='POST')\n        try:",
        "detail": "lab.lab09.editor.local_server",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": "lab.lab09.editor.local_server",
        "description": "lab.lab09.editor.local_server",
        "peekOfCode": "PORT = 8012\nmain_files = []\nstate = {}\nclass Handler(server.BaseHTTPRequestHandler):\n    cancellation_event = threading.Event()  # Shared across all instances, because the threading mixin creates a new instance every time...\n    def do_POST(self):\n        content_length = int(self.headers['Content-Length'])\n        raw_data = self.rfile.read(content_length)\n        data = urllib.parse.parse_qs(raw_data.decode(\"ascii\"))\n        path = urllib.parse.unquote(self.path)",
        "detail": "lab.lab09.editor.local_server",
        "documentation": {}
    },
    {
        "label": "main_files",
        "kind": 5,
        "importPath": "lab.lab09.editor.local_server",
        "description": "lab.lab09.editor.local_server",
        "peekOfCode": "main_files = []\nstate = {}\nclass Handler(server.BaseHTTPRequestHandler):\n    cancellation_event = threading.Event()  # Shared across all instances, because the threading mixin creates a new instance every time...\n    def do_POST(self):\n        content_length = int(self.headers['Content-Length'])\n        raw_data = self.rfile.read(content_length)\n        data = urllib.parse.parse_qs(raw_data.decode(\"ascii\"))\n        path = urllib.parse.unquote(self.path)\n        result = self.handle_post_thread(data, path)",
        "detail": "lab.lab09.editor.local_server",
        "documentation": {}
    },
    {
        "label": "state",
        "kind": 5,
        "importPath": "lab.lab09.editor.local_server",
        "description": "lab.lab09.editor.local_server",
        "peekOfCode": "state = {}\nclass Handler(server.BaseHTTPRequestHandler):\n    cancellation_event = threading.Event()  # Shared across all instances, because the threading mixin creates a new instance every time...\n    def do_POST(self):\n        content_length = int(self.headers['Content-Length'])\n        raw_data = self.rfile.read(content_length)\n        data = urllib.parse.parse_qs(raw_data.decode(\"ascii\"))\n        path = urllib.parse.unquote(self.path)\n        result = self.handle_post_thread(data, path)\n        return result",
        "detail": "lab.lab09.editor.local_server",
        "documentation": {}
    },
    {
        "label": "HolderState",
        "kind": 6,
        "importPath": "lab.lab09.editor.log",
        "description": "lab.lab09.editor.log",
        "peekOfCode": "class HolderState(Enum):\n    UNEVALUATED = 1\n    EVALUATING = 2\n    EVALUATED = 3\n    APPLYING = 4\nclass FakeObj:\n    def __getattr__(self, item):\n        return fake_obj\n    def __getitem__(self, item):\n        return fake_obj",
        "detail": "lab.lab09.editor.log",
        "documentation": {}
    },
    {
        "label": "FakeObj",
        "kind": 6,
        "importPath": "lab.lab09.editor.log",
        "description": "lab.lab09.editor.log",
        "peekOfCode": "class FakeObj:\n    def __getattr__(self, item):\n        return fake_obj\n    def __getitem__(self, item):\n        return fake_obj\n    def __call__(self, *args, **kwargs):\n        return fake_obj\nfake_obj = FakeObj()\nclass VisualExpression:\n    def __init__(self, base_expr: Expression = None, true_base_expr: Expression = None):",
        "detail": "lab.lab09.editor.log",
        "documentation": {}
    },
    {
        "label": "VisualExpression",
        "kind": 6,
        "importPath": "lab.lab09.editor.log",
        "description": "lab.lab09.editor.log",
        "peekOfCode": "class VisualExpression:\n    def __init__(self, base_expr: Expression = None, true_base_expr: Expression = None):\n        self.display_value = base_expr\n        self.base_expr = base_expr if true_base_expr is None else true_base_expr\n        self.value: Expression = None\n        self.children: List[Holder] = []\n        self.id = get_id()\n        if logger.op_count >= OP_LIMIT:\n            self.children = fake_obj\n            return",
        "detail": "lab.lab09.editor.log",
        "documentation": {}
    },
    {
        "label": "Holder",
        "kind": 6,
        "importPath": "lab.lab09.editor.log",
        "description": "lab.lab09.editor.log",
        "peekOfCode": "class Holder:\n    def __init__(self, expr: Expression, parent: VisualExpression):\n        self.expression: VisualExpression = VisualExpression(expr) if isinstance(expr, Expression) else expr\n        self.state = HolderState.UNEVALUATED\n        self.parent = parent\n    def evaluate(self):\n        self.state = HolderState.EVALUATING\n        announce(\"Evaluating\", self, Root.root)\n    def apply(self):\n        self.state = HolderState.APPLYING",
        "detail": "lab.lab09.editor.log",
        "documentation": {}
    },
    {
        "label": "Root",
        "kind": 6,
        "importPath": "lab.lab09.editor.log",
        "description": "lab.lab09.editor.log",
        "peekOfCode": "class Root:\n    root: Holder\n    set: bool = False\n    @classmethod\n    def setroot(cls, root: Holder):\n        cls.root = root\ndef limited(f):\n    def g(*args, **kwargs):\n        if not logger.log_op() and not kwargs.get(\"force\", False):\n            return",
        "detail": "lab.lab09.editor.log",
        "documentation": {}
    },
    {
        "label": "Logger",
        "kind": 6,
        "importPath": "lab.lab09.editor.log",
        "description": "lab.lab09.editor.log",
        "peekOfCode": "class Logger:\n    def __init__(self):\n        self._out = [[]]  # text printed to console\n        self.i = 0  # number of \"steps\" in the substitution tree\n        self.start = 0  # the step of the current expr\n        self.f_delta = 0  # the index of the first frame to generate\n        self.frame_lookup: Dict[int, StoredFrame] = {}  # lookup of all previous frames TODO: use weakrefs or something\n        self.active_frames: List[StoredFrame] = []  # new frames to be added to the js frame store\n        self.frame_updates = []  # when the env diagram is updated\n        self.global_frame: StoredFrame = None",
        "detail": "lab.lab09.editor.log",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "lab.lab09.editor.log",
        "description": "lab.lab09.editor.log",
        "peekOfCode": "class Node:\n    def __init__(self, expr: VisualExpression, transition_type: HolderState):\n        self.transitions = []\n        self.str = []\n        self.base_str = []\n        self.children = []\n        self.id = expr.id\n        self.modify(expr, transition_type)\n    @limited\n    def modify(self, expr: VisualExpression, transition_type: HolderState):",
        "detail": "lab.lab09.editor.log",
        "documentation": {}
    },
    {
        "label": "StoredFrame",
        "kind": 6,
        "importPath": "lab.lab09.editor.log",
        "description": "lab.lab09.editor.log",
        "peekOfCode": "class StoredFrame:\n    def __init__(self, i, base: 'evaluate_apply.Frame'):\n        i += logger.f_delta\n        if i == -1:\n            name = \"Builtins\"\n        elif i == 0:\n            name = \"Global\"\n        else:\n            name = f\"f{i}\"\n        self.name = name",
        "detail": "lab.lab09.editor.log",
        "documentation": {}
    },
    {
        "label": "Heap",
        "kind": 6,
        "importPath": "lab.lab09.editor.log",
        "description": "lab.lab09.editor.log",
        "peekOfCode": "class Heap:\n    HeapKey = Tuple[bool, Union[int, str]]  # the bool means that I'm NOT a pointer!\n    HeapObject = Union[List['HeapObject'], HeapKey]\n    def __init__(self):\n        self.prev: Dict[str, Heap.HeapObject] = {}\n        self.curr: Dict[str, Heap.HeapObject] = {}\n    def export(self):\n        out = self.curr\n        self.prev.update(self.curr)\n        self.curr = {}",
        "detail": "lab.lab09.editor.log",
        "documentation": {}
    },
    {
        "label": "limited",
        "kind": 2,
        "importPath": "lab.lab09.editor.log",
        "description": "lab.lab09.editor.log",
        "peekOfCode": "def limited(f):\n    def g(*args, **kwargs):\n        if not logger.log_op() and not kwargs.get(\"force\", False):\n            return\n        if \"force\" in kwargs:\n            del kwargs[\"force\"]\n        return f(*args, **kwargs)\n    return g\nclass Logger:\n    def __init__(self):",
        "detail": "lab.lab09.editor.log",
        "documentation": {}
    },
    {
        "label": "OP_LIMIT",
        "kind": 5,
        "importPath": "lab.lab09.editor.log",
        "description": "lab.lab09.editor.log",
        "peekOfCode": "OP_LIMIT = 25000\nclass HolderState(Enum):\n    UNEVALUATED = 1\n    EVALUATING = 2\n    EVALUATED = 3\n    APPLYING = 4\nclass FakeObj:\n    def __getattr__(self, item):\n        return fake_obj\n    def __getitem__(self, item):",
        "detail": "lab.lab09.editor.log",
        "documentation": {}
    },
    {
        "label": "fake_obj",
        "kind": 5,
        "importPath": "lab.lab09.editor.log",
        "description": "lab.lab09.editor.log",
        "peekOfCode": "fake_obj = FakeObj()\nclass VisualExpression:\n    def __init__(self, base_expr: Expression = None, true_base_expr: Expression = None):\n        self.display_value = base_expr\n        self.base_expr = base_expr if true_base_expr is None else true_base_expr\n        self.value: Expression = None\n        self.children: List[Holder] = []\n        self.id = get_id()\n        if logger.op_count >= OP_LIMIT:\n            self.children = fake_obj",
        "detail": "lab.lab09.editor.log",
        "documentation": {}
    },
    {
        "label": "return_symbol",
        "kind": 5,
        "importPath": "lab.lab09.editor.log",
        "description": "lab.lab09.editor.log",
        "peekOfCode": "return_symbol = Symbol(\"Return Value\")\nlogger = Logger()\nannounce = logger.log",
        "detail": "lab.lab09.editor.log",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lab.lab09.editor.log",
        "description": "lab.lab09.editor.log",
        "peekOfCode": "logger = Logger()\nannounce = logger.log",
        "detail": "lab.lab09.editor.log",
        "documentation": {}
    },
    {
        "label": "announce",
        "kind": 5,
        "importPath": "lab.lab09.editor.log",
        "description": "lab.lab09.editor.log",
        "peekOfCode": "announce = logger.log",
        "detail": "lab.lab09.editor.log",
        "documentation": {}
    },
    {
        "label": "get_id",
        "kind": 2,
        "importPath": "lab.lab09.editor.log_utils",
        "description": "lab.lab09.editor.log_utils",
        "peekOfCode": "def get_id():\n    global counter\n    counter += 1\n    return str(counter)",
        "detail": "lab.lab09.editor.log_utils",
        "documentation": {}
    },
    {
        "label": "counter",
        "kind": 5,
        "importPath": "lab.lab09.editor.log_utils",
        "description": "lab.lab09.editor.log_utils",
        "peekOfCode": "counter = 0\ndef get_id():\n    global counter\n    counter += 1\n    return str(counter)",
        "detail": "lab.lab09.editor.log_utils",
        "documentation": {}
    },
    {
        "label": "PrintCapture",
        "kind": 6,
        "importPath": "lab.lab09.editor.ok_interface",
        "description": "lab.lab09.editor.ok_interface",
        "peekOfCode": "class PrintCapture:\n    def __init__(self, old_stdout):\n        self.log = []\n        self.old_stdout = old_stdout\n    def write(self, message):\n        self.log.append(message)\n        self.old_stdout.write(message)\n    def flush(self):\n        sys.__stdout__.flush()\ndef capture_output(console, lines):",
        "detail": "lab.lab09.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "PromptOutput",
        "kind": 6,
        "importPath": "lab.lab09.editor.ok_interface",
        "description": "lab.lab09.editor.ok_interface",
        "peekOfCode": "class PromptOutput(metaclass=ABCMeta):\n    @abstractmethod\n    def representation(self):\n        pass\n    @abstractmethod\n    def success(self):\n        pass\nclass AreDifferent(PromptOutput, namedtuple('AreDifferent', ['prompt', 'expected', 'actual'])):\n    def representation(self):\n        return \"{expected}\\n{actual}\\n{prompt}\".format(",
        "detail": "lab.lab09.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "AreDifferent",
        "kind": 6,
        "importPath": "lab.lab09.editor.ok_interface",
        "description": "lab.lab09.editor.ok_interface",
        "peekOfCode": "class AreDifferent(PromptOutput, namedtuple('AreDifferent', ['prompt', 'expected', 'actual'])):\n    def representation(self):\n        return \"{expected}\\n{actual}\\n{prompt}\".format(\n            prompt=self.prompt,\n            expected=pad(\"; Expected: \", \";\", self.expected),\n            actual=pad(\"; Actual  : \", \";\", self.actual)\n        )\n    def success(self):\n        return False\nclass Error(PromptOutput, namedtuple('PromptOutput', ['prompt', 'error'])):",
        "detail": "lab.lab09.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "Error",
        "kind": 6,
        "importPath": "lab.lab09.editor.ok_interface",
        "description": "lab.lab09.editor.ok_interface",
        "peekOfCode": "class Error(PromptOutput, namedtuple('PromptOutput', ['prompt', 'error'])):\n    def representation(self):\n        return \"{error}\\n{prompt}\".format(\n            error=pad(\"; Error: \", \";\", self.error),\n            prompt=self.prompt\n        )\n    def success(self):\n        return False\nclass Same(PromptOutput, namedtuple('Same', ['prompt', 'output'])):\n    def representation(self):",
        "detail": "lab.lab09.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "Same",
        "kind": 6,
        "importPath": "lab.lab09.editor.ok_interface",
        "description": "lab.lab09.editor.ok_interface",
        "peekOfCode": "class Same(PromptOutput, namedtuple('Same', ['prompt', 'output'])):\n    def representation(self):\n        return \"{output}\\n{prompt}\".format(\n            prompt=self.prompt,\n            output=pad(\"; Success: \", \";\", self.output)\n        )\n    def success(self):\n        return True\nclass Locked(PromptOutput, namedtuple('Locked', [])):\n    def representation(self):",
        "detail": "lab.lab09.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "Locked",
        "kind": 6,
        "importPath": "lab.lab09.editor.ok_interface",
        "description": "lab.lab09.editor.ok_interface",
        "peekOfCode": "class Locked(PromptOutput, namedtuple('Locked', [])):\n    def representation(self):\n        return \"; Run python ok -u to unlock test case. \\n (error \\\"Test case locked!\\\")\"\n    def success(self):\n        return False\nclass TestCaseResult(namedtuple('TestCaseResult', ['cases_passed', 'cases_out', 'setup_out'])):\n    @property\n    def success(self):\n        return self.cases_passed\n    @property",
        "detail": "lab.lab09.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "TestCaseResult",
        "kind": 6,
        "importPath": "lab.lab09.editor.ok_interface",
        "description": "lab.lab09.editor.ok_interface",
        "peekOfCode": "class TestCaseResult(namedtuple('TestCaseResult', ['cases_passed', 'cases_out', 'setup_out'])):\n    @property\n    def success(self):\n        return self.cases_passed\n    @property\n    def output(self):\n        result = \"\"\n        if self.setup_out.success():\n            result += self.setup_out.prompt\n        else:",
        "detail": "lab.lab09.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "capture_output",
        "kind": 2,
        "importPath": "lab.lab09.editor.ok_interface",
        "description": "lab.lab09.editor.ok_interface",
        "peekOfCode": "def capture_output(console, lines):\n    old_stdout = sys.stdout\n    sys.stdout = out = PrintCapture(old_stdout)\n    result = console._interpret_lines(lines)\n    sys.stdout = old_stdout\n    if str(TerminatedError()) in \"\".join(out.log):\n        raise TerminatedError\n    return result, out.log\nclass PromptOutput(metaclass=ABCMeta):\n    @abstractmethod",
        "detail": "lab.lab09.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "chunked_input",
        "kind": 2,
        "importPath": "lab.lab09.editor.ok_interface",
        "description": "lab.lab09.editor.ok_interface",
        "peekOfCode": "def chunked_input(lines):\n    chunk = []\n    for line in lines:\n        chunk.append(line)\n        if not isinstance(line, str):\n            yield chunk\n            chunk = []\ndef remove_comments_and_combine(lines):\n    result = []\n    for line in lines:",
        "detail": "lab.lab09.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "remove_comments_and_combine",
        "kind": 2,
        "importPath": "lab.lab09.editor.ok_interface",
        "description": "lab.lab09.editor.ok_interface",
        "peekOfCode": "def remove_comments_and_combine(lines):\n    result = []\n    for line in lines:\n        if not line:\n            continue\n        if line[0] == \"#\":\n            line = line[1:]\n        line = line.strip()\n        result.append(line)\n    return \"\\n\".join(result)",
        "detail": "lab.lab09.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "pad",
        "kind": 2,
        "importPath": "lab.lab09.editor.ok_interface",
        "description": "lab.lab09.editor.ok_interface",
        "peekOfCode": "def pad(first_header, later_header, string):\n    assert len(later_header) <= len(first_header)\n    later_header += \" \" * (len(first_header) - len(later_header))\n    lines = string.split(\"\\n\")\n    lines[0] = first_header + lines[0]\n    for i in range(1, len(lines)):\n        lines[i] = later_header + lines[i]\n    return \"\\n\".join(lines)\ndef process(output, success):\n    prompt = []",
        "detail": "lab.lab09.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "process",
        "kind": 2,
        "importPath": "lab.lab09.editor.ok_interface",
        "description": "lab.lab09.editor.ok_interface",
        "peekOfCode": "def process(output, success):\n    prompt = []\n    lines = \"\".join(output).split(\"\\n\")\n    start_idx = len(lines)\n    for idx, line in enumerate(lines):\n        line = line.strip()\n        if not line:\n            continue\n        if line.startswith(\"scm> \") or line.startswith(\".... \"):\n            prompt.append(line[5:])",
        "detail": "lab.lab09.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "process_case",
        "kind": 2,
        "importPath": "lab.lab09.editor.ok_interface",
        "description": "lab.lab09.editor.ok_interface",
        "peekOfCode": "def process_case(case):\n    setup_success, setup_out = capture_output(case.console, case.setup.splitlines())\n    setup_out = \"\".join(setup_out)\n    if not setup_success:\n        return TestCaseResult(setup_success, [], process(setup_out, True))\n    interpret_success_overall = True\n    interpret_out_overall = []\n    for chunk in chunked_input(case.lines + case.teardown.splitlines()):\n        interpret_success, interpret_out = capture_output(case.console, chunk)\n        interpret_success_overall = interpret_success_overall and interpret_success",
        "detail": "lab.lab09.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "reload_tests",
        "kind": 2,
        "importPath": "lab.lab09.editor.ok_interface",
        "description": "lab.lab09.editor.ok_interface",
        "peekOfCode": "def reload_tests():\n    for testname in filter(lambda x: x.lower().endswith(\".py\"), os.listdir(os.curdir + \"/tests\")):\n        testname = \"tests.\" + testname[:-3]\n        if testname in sys.modules:\n            del sys.modules[testname]\n@contextmanager\ndef redirect_descriptor(from_, to):  # https://stackoverflow.com/a/22434262\n    fd = from_.fileno()\n    with os.fdopen(os.dup(fd), 'wb') as copied:\n        from_.flush()",
        "detail": "lab.lab09.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "redirect_descriptor",
        "kind": 2,
        "importPath": "lab.lab09.editor.ok_interface",
        "description": "lab.lab09.editor.ok_interface",
        "peekOfCode": "def redirect_descriptor(from_, to):  # https://stackoverflow.com/a/22434262\n    fd = from_.fileno()\n    with os.fdopen(os.dup(fd), 'wb') as copied:\n        from_.flush()\n        os.dup2(to.fileno(), fd)\n        try: yield from_\n        finally:\n            from_.flush()\n            os.dup2(copied.fileno(), fd)\ndef run_tests():",
        "detail": "lab.lab09.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "run_tests",
        "kind": 2,
        "importPath": "lab.lab09.editor.ok_interface",
        "description": "lab.lab09.editor.ok_interface",
        "peekOfCode": "def run_tests():\n    reload_tests()\n    # noinspection PyUnresolvedReferences\n    from client.api import assignment\n    import logging\n    LOGGING_FORMAT = '%(levelname)s  | %(filename)s:%(lineno)d | %(message)s'\n    logging.basicConfig(format=LOGGING_FORMAT)\n    log = logging.getLogger('client')  # Get top-level logger\n    # noinspection PyUnresolvedReferences\n    from client.cli.ok import parse_input",
        "detail": "lab.lab09.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "FAILURE_SETUP_HEADER",
        "kind": 5,
        "importPath": "lab.lab09.editor.ok_interface",
        "description": "lab.lab09.editor.ok_interface",
        "peekOfCode": "FAILURE_SETUP_HEADER = '''; There was an error in running the setup code (probably in loading your file)\n; Raw ok output follows'''\nFAILURE_SETUP_FOOTER = \"; Raw ok output over\"\nBEGIN_OUTPUT = b\"sdfghjkjhgfdfghjklkjhgfdxcfghj\"\nclass PrintCapture:\n    def __init__(self, old_stdout):\n        self.log = []\n        self.old_stdout = old_stdout\n    def write(self, message):\n        self.log.append(message)",
        "detail": "lab.lab09.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "FAILURE_SETUP_FOOTER",
        "kind": 5,
        "importPath": "lab.lab09.editor.ok_interface",
        "description": "lab.lab09.editor.ok_interface",
        "peekOfCode": "FAILURE_SETUP_FOOTER = \"; Raw ok output over\"\nBEGIN_OUTPUT = b\"sdfghjkjhgfdfghjklkjhgfdxcfghj\"\nclass PrintCapture:\n    def __init__(self, old_stdout):\n        self.log = []\n        self.old_stdout = old_stdout\n    def write(self, message):\n        self.log.append(message)\n        self.old_stdout.write(message)\n    def flush(self):",
        "detail": "lab.lab09.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "BEGIN_OUTPUT",
        "kind": 5,
        "importPath": "lab.lab09.editor.ok_interface",
        "description": "lab.lab09.editor.ok_interface",
        "peekOfCode": "BEGIN_OUTPUT = b\"sdfghjkjhgfdfghjklkjhgfdxcfghj\"\nclass PrintCapture:\n    def __init__(self, old_stdout):\n        self.log = []\n        self.old_stdout = old_stdout\n    def write(self, message):\n        self.log.append(message)\n        self.old_stdout.write(message)\n    def flush(self):\n        sys.__stdout__.flush()",
        "detail": "lab.lab09.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "save_config",
        "kind": 2,
        "importPath": "lab.lab09.editor.persistence",
        "description": "lab.lab09.editor.persistence",
        "peekOfCode": "def save_config(key, content):\n    os.makedirs(config_path, exist_ok=True)\n    with open(config_path + \"/\" + key + \".config\", \"w+\") as f:\n        f.write(json.dumps(content))\ndef load_config(key):\n    with open(config_path + \"/\" + key + \".config\", \"r\") as f:\n        return json.loads(f.read())",
        "detail": "lab.lab09.editor.persistence",
        "documentation": {}
    },
    {
        "label": "load_config",
        "kind": 2,
        "importPath": "lab.lab09.editor.persistence",
        "description": "lab.lab09.editor.persistence",
        "peekOfCode": "def load_config(key):\n    with open(config_path + \"/\" + key + \".config\", \"r\") as f:\n        return json.loads(f.read())",
        "detail": "lab.lab09.editor.persistence",
        "documentation": {}
    },
    {
        "label": "home",
        "kind": 5,
        "importPath": "lab.lab09.editor.persistence",
        "description": "lab.lab09.editor.persistence",
        "peekOfCode": "home = str(Path.home())\nconfig_path = home + \"/.scheme_editor\"\ndef save_config(key, content):\n    os.makedirs(config_path, exist_ok=True)\n    with open(config_path + \"/\" + key + \".config\", \"w+\") as f:\n        f.write(json.dumps(content))\ndef load_config(key):\n    with open(config_path + \"/\" + key + \".config\", \"r\") as f:\n        return json.loads(f.read())",
        "detail": "lab.lab09.editor.persistence",
        "documentation": {}
    },
    {
        "label": "config_path",
        "kind": 5,
        "importPath": "lab.lab09.editor.persistence",
        "description": "lab.lab09.editor.persistence",
        "peekOfCode": "config_path = home + \"/.scheme_editor\"\ndef save_config(key, content):\n    os.makedirs(config_path, exist_ok=True)\n    with open(config_path + \"/\" + key + \".config\", \"w+\") as f:\n        f.write(json.dumps(content))\ndef load_config(key):\n    with open(config_path + \"/\" + key + \".config\", \"r\") as f:\n        return json.loads(f.read())",
        "detail": "lab.lab09.editor.persistence",
        "documentation": {}
    },
    {
        "label": "BuiltIn",
        "kind": 6,
        "importPath": "lab.lab09.editor.primitives",
        "description": "lab.lab09.editor.primitives",
        "peekOfCode": "class BuiltIn(Applicable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder, eval_operands=True) -> Expression:\n        if eval_operands:\n            operands = evaluate_all(operands, frame, gui_holder.expression.children[1:])\n        gui_holder.expression.set_entries([])\n        gui_holder.apply()\n        return self.execute_evaluated(operands, frame)\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        raise NotImplementedError()\nclass SingleOperandPrimitive(BuiltIn):",
        "detail": "lab.lab09.editor.primitives",
        "documentation": {}
    },
    {
        "label": "SingleOperandPrimitive",
        "kind": 6,
        "importPath": "lab.lab09.editor.primitives",
        "description": "lab.lab09.editor.primitives",
        "peekOfCode": "class SingleOperandPrimitive(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 1, len(operands))\n        operand = operands[0]\n        return self.execute_simple(operand)\n    def execute_simple(self, operand: Expression) -> Expression:\n        raise NotImplementedError()\ndef load_primitives():\n    __import__(\"arithmetic\")\n    __import__(\"lists\")",
        "detail": "lab.lab09.editor.primitives",
        "documentation": {}
    },
    {
        "label": "load_primitives",
        "kind": 2,
        "importPath": "lab.lab09.editor.primitives",
        "description": "lab.lab09.editor.primitives",
        "peekOfCode": "def load_primitives():\n    __import__(\"arithmetic\")\n    __import__(\"lists\")\n    __import__(\"type_checking\")\n    __import__(\"console\")\n    __import__(\"graphics\")\n    __import__(\"visualizing\")",
        "detail": "lab.lab09.editor.primitives",
        "documentation": {}
    },
    {
        "label": "OperationCanceledException",
        "kind": 6,
        "importPath": "lab.lab09.editor.runtime_limiter",
        "description": "lab.lab09.editor.runtime_limiter",
        "peekOfCode": "class OperationCanceledException(Exception):\n    pass\nclass TimeLimitException(Exception):\n    pass\ndef limiter(raise_exception, lim, func, *args):\n    is_event = isinstance(lim, threading.Event)\n    lim_is_set = lim.is_set if is_event else None  # For performance\n    gettime = time.time  # For performance\n    end = (gettime() + lim) if not is_event else None\n    def tracer(*args):",
        "detail": "lab.lab09.editor.runtime_limiter",
        "documentation": {}
    },
    {
        "label": "TimeLimitException",
        "kind": 6,
        "importPath": "lab.lab09.editor.runtime_limiter",
        "description": "lab.lab09.editor.runtime_limiter",
        "peekOfCode": "class TimeLimitException(Exception):\n    pass\ndef limiter(raise_exception, lim, func, *args):\n    is_event = isinstance(lim, threading.Event)\n    lim_is_set = lim.is_set if is_event else None  # For performance\n    gettime = time.time  # For performance\n    end = (gettime() + lim) if not is_event else None\n    def tracer(*args):\n        if lim_is_set() if is_event else gettime() > end:\n            raise_exception(OperationCanceledException() if is_event else TimeLimitException())",
        "detail": "lab.lab09.editor.runtime_limiter",
        "documentation": {}
    },
    {
        "label": "limiter",
        "kind": 2,
        "importPath": "lab.lab09.editor.runtime_limiter",
        "description": "lab.lab09.editor.runtime_limiter",
        "peekOfCode": "def limiter(raise_exception, lim, func, *args):\n    is_event = isinstance(lim, threading.Event)\n    lim_is_set = lim.is_set if is_event else None  # For performance\n    gettime = time.time  # For performance\n    end = (gettime() + lim) if not is_event else None\n    def tracer(*args):\n        if lim_is_set() if is_event else gettime() > end:\n            raise_exception(OperationCanceledException() if is_event else TimeLimitException())\n        return tracer\n    sys_tracer = sys.gettrace()",
        "detail": "lab.lab09.editor.runtime_limiter",
        "documentation": {}
    },
    {
        "label": "scheme_limiter",
        "kind": 2,
        "importPath": "lab.lab09.editor.runtime_limiter",
        "description": "lab.lab09.editor.runtime_limiter",
        "peekOfCode": "def scheme_limiter(*args, **kwargs):\n    def raise_(e):  # Translate to scheme exception and throw\n        if isinstance(e, OperationCanceledException):\n            e = TerminatedError\n        raise e\n    return limiter(raise_, *args, **kwargs)",
        "detail": "lab.lab09.editor.runtime_limiter",
        "documentation": {}
    },
    {
        "label": "SchemeError",
        "kind": 6,
        "importPath": "lab.lab09.editor.scheme_exceptions",
        "description": "lab.lab09.editor.scheme_exceptions",
        "peekOfCode": "class SchemeError(Exception):\n    def __repr__(self):\n        return str(self)\nclass TerminatedError(SchemeError):\n    def __init__(self):\n        super().__init__(\"Error: program manually terminated\")\nclass ParseError(SchemeError):\n    pass\nclass SymbolLookupError(SchemeError):\n    pass",
        "detail": "lab.lab09.editor.scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "TerminatedError",
        "kind": 6,
        "importPath": "lab.lab09.editor.scheme_exceptions",
        "description": "lab.lab09.editor.scheme_exceptions",
        "peekOfCode": "class TerminatedError(SchemeError):\n    def __init__(self):\n        super().__init__(\"Error: program manually terminated\")\nclass ParseError(SchemeError):\n    pass\nclass SymbolLookupError(SchemeError):\n    pass\nclass OperandDeduceError(SchemeError):\n    pass\nclass TurtleDrawingError(SchemeError):",
        "detail": "lab.lab09.editor.scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "ParseError",
        "kind": 6,
        "importPath": "lab.lab09.editor.scheme_exceptions",
        "description": "lab.lab09.editor.scheme_exceptions",
        "peekOfCode": "class ParseError(SchemeError):\n    pass\nclass SymbolLookupError(SchemeError):\n    pass\nclass OperandDeduceError(SchemeError):\n    pass\nclass TurtleDrawingError(SchemeError):\n    pass\nclass CallableResolutionError(SchemeError):\n    pass",
        "detail": "lab.lab09.editor.scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "SymbolLookupError",
        "kind": 6,
        "importPath": "lab.lab09.editor.scheme_exceptions",
        "description": "lab.lab09.editor.scheme_exceptions",
        "peekOfCode": "class SymbolLookupError(SchemeError):\n    pass\nclass OperandDeduceError(SchemeError):\n    pass\nclass TurtleDrawingError(SchemeError):\n    pass\nclass CallableResolutionError(SchemeError):\n    pass\nclass MathError(SchemeError):\n    pass",
        "detail": "lab.lab09.editor.scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "OperandDeduceError",
        "kind": 6,
        "importPath": "lab.lab09.editor.scheme_exceptions",
        "description": "lab.lab09.editor.scheme_exceptions",
        "peekOfCode": "class OperandDeduceError(SchemeError):\n    pass\nclass TurtleDrawingError(SchemeError):\n    pass\nclass CallableResolutionError(SchemeError):\n    pass\nclass MathError(SchemeError):\n    pass\nclass ComparisonError(SchemeError):\n    pass",
        "detail": "lab.lab09.editor.scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "TurtleDrawingError",
        "kind": 6,
        "importPath": "lab.lab09.editor.scheme_exceptions",
        "description": "lab.lab09.editor.scheme_exceptions",
        "peekOfCode": "class TurtleDrawingError(SchemeError):\n    pass\nclass CallableResolutionError(SchemeError):\n    pass\nclass MathError(SchemeError):\n    pass\nclass ComparisonError(SchemeError):\n    pass\nclass TypeMismatchError(SchemeError):\n    pass",
        "detail": "lab.lab09.editor.scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "CallableResolutionError",
        "kind": 6,
        "importPath": "lab.lab09.editor.scheme_exceptions",
        "description": "lab.lab09.editor.scheme_exceptions",
        "peekOfCode": "class CallableResolutionError(SchemeError):\n    pass\nclass MathError(SchemeError):\n    pass\nclass ComparisonError(SchemeError):\n    pass\nclass TypeMismatchError(SchemeError):\n    pass\nclass IrreversibleOperationError(SchemeError):\n    pass",
        "detail": "lab.lab09.editor.scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "MathError",
        "kind": 6,
        "importPath": "lab.lab09.editor.scheme_exceptions",
        "description": "lab.lab09.editor.scheme_exceptions",
        "peekOfCode": "class MathError(SchemeError):\n    pass\nclass ComparisonError(SchemeError):\n    pass\nclass TypeMismatchError(SchemeError):\n    pass\nclass IrreversibleOperationError(SchemeError):\n    pass\nclass FormatError(SchemeError):\n    pass",
        "detail": "lab.lab09.editor.scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "ComparisonError",
        "kind": 6,
        "importPath": "lab.lab09.editor.scheme_exceptions",
        "description": "lab.lab09.editor.scheme_exceptions",
        "peekOfCode": "class ComparisonError(SchemeError):\n    pass\nclass TypeMismatchError(SchemeError):\n    pass\nclass IrreversibleOperationError(SchemeError):\n    pass\nclass FormatError(SchemeError):\n    pass\nclass LoadError(SchemeError):\n    pass",
        "detail": "lab.lab09.editor.scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "TypeMismatchError",
        "kind": 6,
        "importPath": "lab.lab09.editor.scheme_exceptions",
        "description": "lab.lab09.editor.scheme_exceptions",
        "peekOfCode": "class TypeMismatchError(SchemeError):\n    pass\nclass IrreversibleOperationError(SchemeError):\n    pass\nclass FormatError(SchemeError):\n    pass\nclass LoadError(SchemeError):\n    pass\nclass OutOfMemoryError(SchemeError):\n    pass",
        "detail": "lab.lab09.editor.scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "IrreversibleOperationError",
        "kind": 6,
        "importPath": "lab.lab09.editor.scheme_exceptions",
        "description": "lab.lab09.editor.scheme_exceptions",
        "peekOfCode": "class IrreversibleOperationError(SchemeError):\n    pass\nclass FormatError(SchemeError):\n    pass\nclass LoadError(SchemeError):\n    pass\nclass OutOfMemoryError(SchemeError):\n    pass",
        "detail": "lab.lab09.editor.scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "FormatError",
        "kind": 6,
        "importPath": "lab.lab09.editor.scheme_exceptions",
        "description": "lab.lab09.editor.scheme_exceptions",
        "peekOfCode": "class FormatError(SchemeError):\n    pass\nclass LoadError(SchemeError):\n    pass\nclass OutOfMemoryError(SchemeError):\n    pass",
        "detail": "lab.lab09.editor.scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "LoadError",
        "kind": 6,
        "importPath": "lab.lab09.editor.scheme_exceptions",
        "description": "lab.lab09.editor.scheme_exceptions",
        "peekOfCode": "class LoadError(SchemeError):\n    pass\nclass OutOfMemoryError(SchemeError):\n    pass",
        "detail": "lab.lab09.editor.scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "OutOfMemoryError",
        "kind": 6,
        "importPath": "lab.lab09.editor.scheme_exceptions",
        "description": "lab.lab09.editor.scheme_exceptions",
        "peekOfCode": "class OutOfMemoryError(SchemeError):\n    pass",
        "detail": "lab.lab09.editor.scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "ProcedureObject",
        "kind": 6,
        "importPath": "lab.lab09.editor.special_forms",
        "description": "lab.lab09.editor.special_forms",
        "peekOfCode": "class ProcedureObject(Callable):\n    evaluates_operands: bool\n    lexically_scoped: bool\n    name: str\n    def __init__(self,\n                 params: List[Symbol],\n                 var_param: Optional[Symbol],\n                 body: List[Expression],\n                 frame: Frame,\n                 name: str=None):",
        "detail": "lab.lab09.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "LambdaObject",
        "kind": 6,
        "importPath": "lab.lab09.editor.special_forms",
        "description": "lab.lab09.editor.special_forms",
        "peekOfCode": "class LambdaObject(ProcedureObject, Applicable):\n    evaluates_operands = True\n    lexically_scoped = True\n    name = \"lambda\"\nclass MuObject(ProcedureObject, Applicable):\n    evaluates_operands = True\n    lexically_scoped = False\n    name = \"mu\"\nclass MacroObject(ProcedureObject, Callable):\n    evaluates_operands = False",
        "detail": "lab.lab09.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "MuObject",
        "kind": 6,
        "importPath": "lab.lab09.editor.special_forms",
        "description": "lab.lab09.editor.special_forms",
        "peekOfCode": "class MuObject(ProcedureObject, Applicable):\n    evaluates_operands = True\n    lexically_scoped = False\n    name = \"mu\"\nclass MacroObject(ProcedureObject, Callable):\n    evaluates_operands = False\n    lexically_scoped = True\n    name = \"macro\"\nclass ProcedureBuilder(Callable):\n    procedure: Type[ProcedureObject]",
        "detail": "lab.lab09.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "MacroObject",
        "kind": 6,
        "importPath": "lab.lab09.editor.special_forms",
        "description": "lab.lab09.editor.special_forms",
        "peekOfCode": "class MacroObject(ProcedureObject, Callable):\n    evaluates_operands = False\n    lexically_scoped = True\n    name = \"macro\"\nclass ProcedureBuilder(Callable):\n    procedure: Type[ProcedureObject]\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder, name: str = \"lambda\"):\n        verify_min_callable_length(self, 2, len(operands))\n        params = operands[0]\n        if not logger.dotted and not isinstance(params, (Pair, NilType)):",
        "detail": "lab.lab09.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "ProcedureBuilder",
        "kind": 6,
        "importPath": "lab.lab09.editor.special_forms",
        "description": "lab.lab09.editor.special_forms",
        "peekOfCode": "class ProcedureBuilder(Callable):\n    procedure: Type[ProcedureObject]\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder, name: str = \"lambda\"):\n        verify_min_callable_length(self, 2, len(operands))\n        params = operands[0]\n        if not logger.dotted and not isinstance(params, (Pair, NilType)):\n            raise OperandDeduceError(f\"Expected Pair as parameter list, received {params}.\")\n        params, var_param = dotted_pair_to_list(params)\n        for i, param in enumerate(params):\n            if (logger.dotted or i != len(params) - 1) and not isinstance(param, Symbol):",
        "detail": "lab.lab09.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Lambda",
        "kind": 6,
        "importPath": "lab.lab09.editor.special_forms",
        "description": "lab.lab09.editor.special_forms",
        "peekOfCode": "class Lambda(ProcedureBuilder):\n    procedure = LambdaObject\n@special_form(\"mu\")\nclass Mu(ProcedureBuilder):\n    procedure = MuObject\nclass Macro(ProcedureBuilder):\n    procedure = MacroObject\n@special_form(\"define-macro\")\nclass DefineMacro(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):",
        "detail": "lab.lab09.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Mu",
        "kind": 6,
        "importPath": "lab.lab09.editor.special_forms",
        "description": "lab.lab09.editor.special_forms",
        "peekOfCode": "class Mu(ProcedureBuilder):\n    procedure = MuObject\nclass Macro(ProcedureBuilder):\n    procedure = MacroObject\n@special_form(\"define-macro\")\nclass DefineMacro(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        verify_min_callable_length(self, 2, len(operands))\n        params = operands[0]\n        if not isinstance(params, Pair):",
        "detail": "lab.lab09.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Macro",
        "kind": 6,
        "importPath": "lab.lab09.editor.special_forms",
        "description": "lab.lab09.editor.special_forms",
        "peekOfCode": "class Macro(ProcedureBuilder):\n    procedure = MacroObject\n@special_form(\"define-macro\")\nclass DefineMacro(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        verify_min_callable_length(self, 2, len(operands))\n        params = operands[0]\n        if not isinstance(params, Pair):\n            raise OperandDeduceError(f\"Expected a Pair, not {params}, as the first operand of define-macro.\")\n        name = params.first",
        "detail": "lab.lab09.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "DefineMacro",
        "kind": 6,
        "importPath": "lab.lab09.editor.special_forms",
        "description": "lab.lab09.editor.special_forms",
        "peekOfCode": "class DefineMacro(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        verify_min_callable_length(self, 2, len(operands))\n        params = operands[0]\n        if not isinstance(params, Pair):\n            raise OperandDeduceError(f\"Expected a Pair, not {params}, as the first operand of define-macro.\")\n        name = params.first\n        operands[0] = params.rest\n        if not isinstance(name, Symbol):\n            raise OperandDeduceError(f\"Expected a Symbol, not {name}.\")",
        "detail": "lab.lab09.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Define",
        "kind": 6,
        "importPath": "lab.lab09.editor.special_forms",
        "description": "lab.lab09.editor.special_forms",
        "peekOfCode": "class Define(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        verify_min_callable_length(self, 2, len(operands))\n        params = operands[0]\n        if isinstance(params, Symbol):\n            verify_exact_callable_length(self, 2, len(operands))\n            frame.assign(params, evaluate(operands[1], frame, gui_holder.expression.children[2]))\n            return params\n        elif isinstance(params, Pair):\n            name = params.first",
        "detail": "lab.lab09.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Set",
        "kind": 6,
        "importPath": "lab.lab09.editor.special_forms",
        "description": "lab.lab09.editor.special_forms",
        "peekOfCode": "class Set(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        verify_exact_callable_length(self, 2, len(operands))\n        name = operands[0]\n        if not isinstance(name, Symbol):\n            raise OperandDeduceError(f\"Expected a Symbol, not {name}, as the first operand of set!\")\n        frame.mutate(name, evaluate(operands[1], frame, gui_holder.expression.children[2]))\n        return Undefined\n@special_form(\"begin\")\nclass Begin(Callable):",
        "detail": "lab.lab09.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Begin",
        "kind": 6,
        "importPath": "lab.lab09.editor.special_forms",
        "description": "lab.lab09.editor.special_forms",
        "peekOfCode": "class Begin(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        verify_min_callable_length(self, 1, len(operands))\n        out = None\n        for i, (operand, holder) in enumerate(zip(operands, gui_holder.expression.children[1:])):\n            out = evaluate(operand, frame, holder, i == len(operands) - 1)\n        return out\n@special_form(\"if\")\nclass If(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):",
        "detail": "lab.lab09.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "If",
        "kind": 6,
        "importPath": "lab.lab09.editor.special_forms",
        "description": "lab.lab09.editor.special_forms",
        "peekOfCode": "class If(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        verify_min_callable_length(self, 2, len(operands))\n        if len(operands) > 3:\n            verify_exact_callable_length(self, 3, len(operands))\n        if evaluate(operands[0], frame, gui_holder.expression.children[1]) is SingletonFalse:\n            if len(operands) == 2:\n                return Undefined\n            else:\n                return evaluate(operands[2], frame, gui_holder.expression.children[3], True)",
        "detail": "lab.lab09.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Quote",
        "kind": 6,
        "importPath": "lab.lab09.editor.special_forms",
        "description": "lab.lab09.editor.special_forms",
        "peekOfCode": "class Quote(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        verify_exact_callable_length(self, 1, len(operands))\n        return operands[0]\n@global_attr(\"eval\")\nclass Eval(Applicable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder, eval_operands=True):\n        verify_exact_callable_length(self, 1, len(operands))\n        if eval_operands:\n            operand = evaluate(operands[0], frame, gui_holder.expression.children[1])",
        "detail": "lab.lab09.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Eval",
        "kind": 6,
        "importPath": "lab.lab09.editor.special_forms",
        "description": "lab.lab09.editor.special_forms",
        "peekOfCode": "class Eval(Applicable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder, eval_operands=True):\n        verify_exact_callable_length(self, 1, len(operands))\n        if eval_operands:\n            operand = evaluate(operands[0], frame, gui_holder.expression.children[1])\n        else:\n            operand = operands[0]\n        gui_holder.expression.set_entries([VisualExpression(operand, gui_holder.expression.display_value)])\n        gui_holder.apply()\n        return evaluate(operand, frame, gui_holder.expression.children[0], True)",
        "detail": "lab.lab09.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Apply",
        "kind": 6,
        "importPath": "lab.lab09.editor.special_forms",
        "description": "lab.lab09.editor.special_forms",
        "peekOfCode": "class Apply(Applicable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder, eval_operands=True):\n        verify_exact_callable_length(self, 2, len(operands))\n        if eval_operands:\n            operands = evaluate_all(operands, frame, gui_holder.expression.children[1:])\n        func, args = operands\n        if not isinstance(func, Applicable):\n            raise OperandDeduceError(f\"Unable to apply {func}.\")\n        gui_holder.expression.set_entries([VisualExpression(Pair(func, args), gui_holder.expression.display_value)])\n        gui_holder.expression.children[0].expression.children = []",
        "detail": "lab.lab09.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Cond",
        "kind": 6,
        "importPath": "lab.lab09.editor.special_forms",
        "description": "lab.lab09.editor.special_forms",
        "peekOfCode": "class Cond(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        verify_min_callable_length(self, 1, len(operands))\n        for cond_i, cond in enumerate(operands):\n            if not isinstance(cond, Pair):\n                raise OperandDeduceError(f\"Unable to evaluate clause of cond, as {cond} is not a Pair.\")\n            expanded = pair_to_list(cond)\n            cond_holder = gui_holder.expression.children[cond_i + 1]\n            eval_condition = SingletonTrue\n            if not isinstance(expanded[0], Symbol) or expanded[0].value != \"else\":",
        "detail": "lab.lab09.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "And",
        "kind": 6,
        "importPath": "lab.lab09.editor.special_forms",
        "description": "lab.lab09.editor.special_forms",
        "peekOfCode": "class And(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        value = None\n        for i, expr in enumerate(operands):\n            value = evaluate(expr, frame, gui_holder.expression.children[i + 1], i == len(operands) - 1)\n            if value is SingletonFalse:\n                return SingletonFalse\n        return value if operands else SingletonTrue\n@special_form(\"or\")\nclass Or(Callable):",
        "detail": "lab.lab09.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Or",
        "kind": 6,
        "importPath": "lab.lab09.editor.special_forms",
        "description": "lab.lab09.editor.special_forms",
        "peekOfCode": "class Or(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        for i, expr in enumerate(operands):\n            value = evaluate(expr, frame, gui_holder.expression.children[i + 1], i == len(operands) - 1)\n            if value is not SingletonFalse:\n                return value\n        return SingletonFalse\n@special_form(\"let\")\nclass Let(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):",
        "detail": "lab.lab09.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Let",
        "kind": 6,
        "importPath": "lab.lab09.editor.special_forms",
        "description": "lab.lab09.editor.special_forms",
        "peekOfCode": "class Let(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        verify_min_callable_length(self, 2, len(operands))\n        bindings = operands[0]\n        if not isinstance(bindings, Pair) and bindings is not Nil:\n            raise OperandDeduceError(f\"Expected first argument of let to be a Pair, not {bindings}.\")\n        new_frame = Frame(\"anonymous let\", frame)\n        bindings_holder = gui_holder.expression.children[1]\n        bindings = pair_to_list(bindings)\n        for i, binding in enumerate(bindings):",
        "detail": "lab.lab09.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Variadic",
        "kind": 6,
        "importPath": "lab.lab09.editor.special_forms",
        "description": "lab.lab09.editor.special_forms",
        "peekOfCode": "class Variadic(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        raise CallableResolutionError(\"Variadic type parameter must be within a parameter list.\")\n@special_form(\"unquote\")\nclass Unquote(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        raise CallableResolutionError(\"Cannot evaluate unquote outside quasiquote.\")\n@special_form(\"unquote-splicing\")\nclass UnquoteSplicing(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):",
        "detail": "lab.lab09.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Unquote",
        "kind": 6,
        "importPath": "lab.lab09.editor.special_forms",
        "description": "lab.lab09.editor.special_forms",
        "peekOfCode": "class Unquote(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        raise CallableResolutionError(\"Cannot evaluate unquote outside quasiquote.\")\n@special_form(\"unquote-splicing\")\nclass UnquoteSplicing(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        raise CallableResolutionError(\"Cannot evaluate unquote-splicing outside quasiquote.\")\n@special_form(\"quasiquote\")\nclass Quasiquote(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):",
        "detail": "lab.lab09.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "UnquoteSplicing",
        "kind": 6,
        "importPath": "lab.lab09.editor.special_forms",
        "description": "lab.lab09.editor.special_forms",
        "peekOfCode": "class UnquoteSplicing(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        raise CallableResolutionError(\"Cannot evaluate unquote-splicing outside quasiquote.\")\n@special_form(\"quasiquote\")\nclass Quasiquote(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        verify_exact_callable_length(self, 1, len(operands))\n        return Quasiquote.quasiquote_evaluate(operands[0], frame, gui_holder.expression.children[1])\n    @classmethod\n    def quasiquote_evaluate(cls, expr: Expression, frame: Frame, gui_holder: Holder, splicing=False):",
        "detail": "lab.lab09.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Quasiquote",
        "kind": 6,
        "importPath": "lab.lab09.editor.special_forms",
        "description": "lab.lab09.editor.special_forms",
        "peekOfCode": "class Quasiquote(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        verify_exact_callable_length(self, 1, len(operands))\n        return Quasiquote.quasiquote_evaluate(operands[0], frame, gui_holder.expression.children[1])\n    @classmethod\n    def quasiquote_evaluate(cls, expr: Expression, frame: Frame, gui_holder: Holder, splicing=False):\n        is_well_formed = False\n        if isinstance(expr, Pair):\n            try:\n                lst = pair_to_list(expr)",
        "detail": "lab.lab09.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Load",
        "kind": 6,
        "importPath": "lab.lab09.editor.special_forms",
        "description": "lab.lab09.editor.special_forms",
        "peekOfCode": "class Load(Applicable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder, eval_operands=True):\n        verify_exact_callable_length(self, 1, len(operands))\n        if eval_operands:\n            operands = evaluate_all(operands, frame, gui_holder.expression.children[1:])\n        if not isinstance(operands[0], Symbol):\n            raise OperandDeduceError(f\"Load expected a Symbol, received {operands[0]}.\")\n        if logger.fragile:\n            raise IrreversibleOperationError()\n        try:",
        "detail": "lab.lab09.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "LoadAll",
        "kind": 6,
        "importPath": "lab.lab09.editor.special_forms",
        "description": "lab.lab09.editor.special_forms",
        "peekOfCode": "class LoadAll(Applicable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder, eval_operands=True):\n        verify_exact_callable_length(self, 1, len(operands))\n        if eval_operands:\n            operands = evaluate_all(operands, frame, gui_holder.expression.children[1:])\n        if not isinstance(operands[0], String):\n            raise OperandDeduceError(f\"Load expected a String, received {operands[0]}.\")\n        if logger.fragile:\n            raise IrreversibleOperationError()\n        from os import listdir",
        "detail": "lab.lab09.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "BeginNoExcept",
        "kind": 6,
        "importPath": "lab.lab09.editor.special_forms",
        "description": "lab.lab09.editor.special_forms",
        "peekOfCode": "class BeginNoExcept(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        out = Undefined\n        for i, (operand, holder) in enumerate(zip(operands, gui_holder.expression.children[1:])):\n            try:\n                out = evaluate(operand, frame, holder, i == len(operands) - 1)\n            except (SchemeError, RecursionError, ValueError, ZeroDivisionError) as e:\n                logger.raw_out(\"LoadError: \" + str(e) + \"\\n\")\n        return out\n@special_form(\"delay\")",
        "detail": "lab.lab09.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Delay",
        "kind": 6,
        "importPath": "lab.lab09.editor.special_forms",
        "description": "lab.lab09.editor.special_forms",
        "peekOfCode": "class Delay(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        verify_exact_callable_length(self, 1, len(operands))\n        return Promise(operands[0], frame)\n@global_attr(\"force\")\nclass Force(Applicable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder, eval_operands=True):\n        verify_exact_callable_length(self, 1, len(operands))\n        operand = operands[0]\n        if eval_operands:",
        "detail": "lab.lab09.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Force",
        "kind": 6,
        "importPath": "lab.lab09.editor.special_forms",
        "description": "lab.lab09.editor.special_forms",
        "peekOfCode": "class Force(Applicable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder, eval_operands=True):\n        verify_exact_callable_length(self, 1, len(operands))\n        operand = operands[0]\n        if eval_operands:\n            operand = evaluate_all(operands, frame, gui_holder.expression.children[1:])[0]\n        if not isinstance(operand, Promise):\n            raise OperandDeduceError(f\"Force expected a Promise, received {operand}\")\n        if operand.forced:\n            return operand.expr",
        "detail": "lab.lab09.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "ConsStream",
        "kind": 6,
        "importPath": "lab.lab09.editor.special_forms",
        "description": "lab.lab09.editor.special_forms",
        "peekOfCode": "class ConsStream(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        verify_exact_callable_length(self, 2, len(operands))\n        operands[0] = evaluate(operands[0], frame, gui_holder.expression.children[1])\n        return Pair(operands[0], Promise(operands[1], frame))\n@special_form(\"expect\")\nclass Expect(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        verify_exact_callable_length(self, 2, len(operands))\n        case = operands[0]",
        "detail": "lab.lab09.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Expect",
        "kind": 6,
        "importPath": "lab.lab09.editor.special_forms",
        "description": "lab.lab09.editor.special_forms",
        "peekOfCode": "class Expect(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        verify_exact_callable_length(self, 2, len(operands))\n        case = operands[0]\n        operands[0] = evaluate(operands[0], frame, gui_holder.expression.children[1])\n        if not IsEqual().execute_evaluated(operands, frame).value:\n            log.logger.raw_out(f\"Evaluated {case}, expected {operands[1]}, got {operands[0]}.\\n\")\n        else:\n            log.logger.raw_out(f\"Evaluated {case}, got {operands[0]}, as expected.\\n\")\n        return Undefined",
        "detail": "lab.lab09.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Error",
        "kind": 6,
        "importPath": "lab.lab09.editor.special_forms",
        "description": "lab.lab09.editor.special_forms",
        "peekOfCode": "class Error(Applicable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder, eval_operands=True):\n        verify_exact_callable_length(self, 1, len(operands))\n        if eval_operands:\n            operands = evaluate_all(operands, frame, gui_holder.expression.children[1:])\n        raise SchemeError(operands[0])",
        "detail": "lab.lab09.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "IsAtom",
        "kind": 6,
        "importPath": "lab.lab09.editor.type_checking",
        "description": "lab.lab09.editor.type_checking",
        "peekOfCode": "class IsAtom(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression):\n        return bools[isinstance(operand, Boolean) or isinstance(operand, Number)\n                     or isinstance(operand, Symbol) or operand is Nil]\n@global_attr(\"boolean?\")\nclass IsBoolean(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression):\n        return bools[isinstance(operand, Boolean)]\n@global_attr(\"integer?\")\nclass IsInteger(SingleOperandPrimitive):",
        "detail": "lab.lab09.editor.type_checking",
        "documentation": {}
    },
    {
        "label": "IsBoolean",
        "kind": 6,
        "importPath": "lab.lab09.editor.type_checking",
        "description": "lab.lab09.editor.type_checking",
        "peekOfCode": "class IsBoolean(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression):\n        return bools[isinstance(operand, Boolean)]\n@global_attr(\"integer?\")\nclass IsInteger(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression):\n        return bools[isinstance(operand, Number) and isinstance(operand.value, int)]\n@global_attr(\"list?\")\nclass IsList(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression):",
        "detail": "lab.lab09.editor.type_checking",
        "documentation": {}
    },
    {
        "label": "IsInteger",
        "kind": 6,
        "importPath": "lab.lab09.editor.type_checking",
        "description": "lab.lab09.editor.type_checking",
        "peekOfCode": "class IsInteger(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression):\n        return bools[isinstance(operand, Number) and isinstance(operand.value, int)]\n@global_attr(\"list?\")\nclass IsList(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression):\n        if isinstance(operand, Pair):\n            try:\n                pair_to_list(operand)\n                return SingletonTrue",
        "detail": "lab.lab09.editor.type_checking",
        "documentation": {}
    },
    {
        "label": "IsList",
        "kind": 6,
        "importPath": "lab.lab09.editor.type_checking",
        "description": "lab.lab09.editor.type_checking",
        "peekOfCode": "class IsList(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression):\n        if isinstance(operand, Pair):\n            try:\n                pair_to_list(operand)\n                return SingletonTrue\n            except OperandDeduceError:\n                return SingletonFalse\n        else:\n            return SingletonFalse",
        "detail": "lab.lab09.editor.type_checking",
        "documentation": {}
    },
    {
        "label": "IsNumber",
        "kind": 6,
        "importPath": "lab.lab09.editor.type_checking",
        "description": "lab.lab09.editor.type_checking",
        "peekOfCode": "class IsNumber(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        return bools[isinstance(operand, Number)]\n@global_attr(\"null?\")\nclass IsNull(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if operand is Nil:\n            return SingletonTrue\n        else:\n            return SingletonFalse",
        "detail": "lab.lab09.editor.type_checking",
        "documentation": {}
    },
    {
        "label": "IsNull",
        "kind": 6,
        "importPath": "lab.lab09.editor.type_checking",
        "description": "lab.lab09.editor.type_checking",
        "peekOfCode": "class IsNull(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if operand is Nil:\n            return SingletonTrue\n        else:\n            return SingletonFalse\n@global_attr(\"pair?\")\nclass IsPair(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        return bools[isinstance(operand, Pair)]",
        "detail": "lab.lab09.editor.type_checking",
        "documentation": {}
    },
    {
        "label": "IsPair",
        "kind": 6,
        "importPath": "lab.lab09.editor.type_checking",
        "description": "lab.lab09.editor.type_checking",
        "peekOfCode": "class IsPair(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        return bools[isinstance(operand, Pair)]\n@global_attr(\"procedure?\")\nclass IsProcedure(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression):\n        return bools[isinstance(operand, LambdaObject) or\n                     isinstance(operand, MuObject) or\n                     isinstance(operand, MacroObject)]\n@global_attr(\"string?\")",
        "detail": "lab.lab09.editor.type_checking",
        "documentation": {}
    },
    {
        "label": "IsProcedure",
        "kind": 6,
        "importPath": "lab.lab09.editor.type_checking",
        "description": "lab.lab09.editor.type_checking",
        "peekOfCode": "class IsProcedure(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression):\n        return bools[isinstance(operand, LambdaObject) or\n                     isinstance(operand, MuObject) or\n                     isinstance(operand, MacroObject)]\n@global_attr(\"string?\")\nclass IsString(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        return bools[isinstance(operand, String)]\n@global_attr(\"symbol?\")",
        "detail": "lab.lab09.editor.type_checking",
        "documentation": {}
    },
    {
        "label": "IsString",
        "kind": 6,
        "importPath": "lab.lab09.editor.type_checking",
        "description": "lab.lab09.editor.type_checking",
        "peekOfCode": "class IsString(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        return bools[isinstance(operand, String)]\n@global_attr(\"symbol?\")\nclass IsSymbol(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        return bools[isinstance(operand, Symbol)]",
        "detail": "lab.lab09.editor.type_checking",
        "documentation": {}
    },
    {
        "label": "IsSymbol",
        "kind": 6,
        "importPath": "lab.lab09.editor.type_checking",
        "description": "lab.lab09.editor.type_checking",
        "peekOfCode": "class IsSymbol(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        return bools[isinstance(operand, Symbol)]",
        "detail": "lab.lab09.editor.type_checking",
        "documentation": {}
    },
    {
        "label": "AutoDraw",
        "kind": 6,
        "importPath": "lab.lab09.editor.visualizing",
        "description": "lab.lab09.editor.visualizing",
        "peekOfCode": "class AutoDraw(BuiltIn):\n        def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n            verify_exact_callable_length(self, 0, len(operands))\n            if log.logger.fragile:\n                raise IrreversibleOperationError()\n            log.logger.raw_out(\"Disable autodraw with (disable-autodraw).\\n\")\n            log.logger.raw_out(\"ENABLE_AUTODRAW[]\\n\")\n            return Undefined\n@global_attr(\"disable-autodraw\")\nclass DisableAutoDraw(BuiltIn):",
        "detail": "lab.lab09.editor.visualizing",
        "documentation": {}
    },
    {
        "label": "DisableAutoDraw",
        "kind": 6,
        "importPath": "lab.lab09.editor.visualizing",
        "description": "lab.lab09.editor.visualizing",
        "peekOfCode": "class DisableAutoDraw(BuiltIn):\n        def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n            verify_exact_callable_length(self, 0, len(operands))\n            if log.logger.fragile:\n                raise IrreversibleOperationError()\n            log.logger.raw_out(\"DISABLE_AUTODRAW[]\\n\")\n            return Undefined\n@global_attr(\"draw\")\nclass Draw(SingleOperandPrimitive):\n        def execute_simple(self, operand: Expression) -> Expression:",
        "detail": "lab.lab09.editor.visualizing",
        "documentation": {}
    },
    {
        "label": "Draw",
        "kind": 6,
        "importPath": "lab.lab09.editor.visualizing",
        "description": "lab.lab09.editor.visualizing",
        "peekOfCode": "class Draw(SingleOperandPrimitive):\n        def execute_simple(self, operand: Expression) -> Expression:\n            if log.logger.fragile:\n                raise IrreversibleOperationError()\n            log.logger.raw_out(\"DRAW\" +\n                               json.dumps([log.logger.i, log.logger.heap.record(operand)]) + \"\\n\")\n            return Undefined",
        "detail": "lab.lab09.editor.visualizing",
        "documentation": {}
    },
    {
        "label": "index",
        "kind": 2,
        "importPath": "lab.lab09.editor.web_server",
        "description": "lab.lab09.editor.web_server",
        "peekOfCode": "def index():\n    return render_template(\"index.html\", start_data=json.dumps({}))\n@app.route(\"/<code>\")\ndef lookup(code):\n    val = database.load(code)\n    if val is None:\n        return index()\n    return render_template(\"index.html\",\n                           start_data=repr(json.dumps({\"code\": eval(val[0]),\n                                                       \"skip_tree\": bool(val[1]),",
        "detail": "lab.lab09.editor.web_server",
        "documentation": {}
    },
    {
        "label": "lookup",
        "kind": 2,
        "importPath": "lab.lab09.editor.web_server",
        "description": "lab.lab09.editor.web_server",
        "peekOfCode": "def lookup(code):\n    val = database.load(code)\n    if val is None:\n        return index()\n    return render_template(\"index.html\",\n                           start_data=repr(json.dumps({\"code\": eval(val[0]),\n                                                       \"skip_tree\": bool(val[1]),\n                                                       \"hide_return_frames\": bool(val[2])})))\n@app.route(\"/process2\", methods=[\"POST\"])\ndef receive():",
        "detail": "lab.lab09.editor.web_server",
        "documentation": {}
    },
    {
        "label": "receive",
        "kind": 2,
        "importPath": "lab.lab09.editor.web_server",
        "description": "lab.lab09.editor.web_server",
        "peekOfCode": "def receive():\n    code = request.form.getlist(\"code[]\")\n    skip_tree = request.form.get(\"skip_tree\") == \"true\"\n    skip_envs = request.form.get(\"skip_envs\") == \"true\"\n    hide_return_frames = request.form.get(\"hide_return_frames\") == \"true\"\n    return handle(code, skip_tree, skip_envs, hide_return_frames)\ndef handle(code, skip_tree, skip_envs, hide_return_frames):\n    log.logger.setID(database.save(code, skip_tree, hide_return_frames))\n    log.logger.new_query(skip_tree, skip_envs, hide_return_frames)\n    try:",
        "detail": "lab.lab09.editor.web_server",
        "documentation": {}
    },
    {
        "label": "handle",
        "kind": 2,
        "importPath": "lab.lab09.editor.web_server",
        "description": "lab.lab09.editor.web_server",
        "peekOfCode": "def handle(code, skip_tree, skip_envs, hide_return_frames):\n    log.logger.setID(database.save(code, skip_tree, hide_return_frames))\n    log.logger.new_query(skip_tree, skip_envs, hide_return_frames)\n    try:\n        # execution.string_exec(code, gui.logger.out)\n        scheme_limiter(3, execution.string_exec, code, log.logger.out)\n    except SchemeError as e:\n        log.logger.out(e)\n    except TimeLimitException:\n        log.logger.out(\"Time limit exceeded. Try disabling the substitution visualizer (top checkbox) for increased \"",
        "detail": "lab.lab09.editor.web_server",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "lab.lab09.editor.web_server",
        "description": "lab.lab09.editor.web_server",
        "peekOfCode": "app = Flask(__name__)\n@app.route('/')\ndef index():\n    return render_template(\"index.html\", start_data=json.dumps({}))\n@app.route(\"/<code>\")\ndef lookup(code):\n    val = database.load(code)\n    if val is None:\n        return index()\n    return render_template(\"index.html\",",
        "detail": "lab.lab09.editor.web_server",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "lab.lab09.tests.combinations",
        "description": "lab.lab09.tests.combinations",
        "peekOfCode": "test = {\n  'name': 'What Would Scheme Display?',\n  'points': 0,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          scm> (- 10 4)\n          aae76aca9259a704209b44193fad5f6a",
        "detail": "lab.lab09.tests.combinations",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "lab.lab09.tests.composed",
        "description": "lab.lab09.tests.composed",
        "peekOfCode": "test = {\n  'name': 'composed',\n  'points': 1,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          scm> (add-then-mul 2)\n          6",
        "detail": "lab.lab09.tests.composed",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "lab.lab09.tests.gcd",
        "description": "lab.lab09.tests.gcd",
        "peekOfCode": "test = {\n  'name': 'gcd',\n  'points': 1,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          scm> (gcd 24 60)\n          12",
        "detail": "lab.lab09.tests.gcd",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "lab.lab09.tests.make_adder",
        "description": "lab.lab09.tests.make_adder",
        "peekOfCode": "test = {\n  'name': 'make-adder',\n  'points': 1,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          scm> (add-two 2)\n          4",
        "detail": "lab.lab09.tests.make_adder",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "lab.lab09.tests.over_or_under",
        "description": "lab.lab09.tests.over_or_under",
        "peekOfCode": "test = {\n  'name': 'over-or-under',\n  'points': 1,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          scm> (over-or-under 5 5)\n          0",
        "detail": "lab.lab09.tests.over_or_under",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "lab.lab09.tests.repeat",
        "description": "lab.lab09.tests.repeat",
        "peekOfCode": "test = {\n  'name': 'repeat',\n  'points': 1,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          scm> (define (square x) (* x x))\n          square",
        "detail": "lab.lab09.tests.repeat",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "lab.lab10.tests.using_pair",
        "description": "lab.lab10.tests.using_pair",
        "peekOfCode": "test = {\n  'name': 'using-pair',\n  'points': 0,\n  'suites': [\n    {\n      'cases': [\n        {\n          'answer': '444b726568312f6761d05afbc3ef8701',\n          'choices': [\n            \"Pair('+', Pair('-', Pair(2, Pair(4, Pair(6, Pair(8, nil))))))\",",
        "detail": "lab.lab10.tests.using_pair",
        "documentation": {}
    },
    {
        "label": "Pair",
        "kind": 6,
        "importPath": "lab.lab10.lab10",
        "description": "lab.lab10.lab10",
        "peekOfCode": "class Pair:\n    \"\"\"A pair has two instance attributes: first and rest. rest must be a Pair or nil\n    >>> s = Pair(1, Pair(2, nil))\n    >>> s\n    Pair(1, Pair(2, nil))\n    >>> print(s)\n    (1 2)\n    >>> print(s.map(lambda x: x+4))\n    (5 6)\n    \"\"\"",
        "detail": "lab.lab10.lab10",
        "documentation": {}
    },
    {
        "label": "nil",
        "kind": 6,
        "importPath": "lab.lab10.lab10",
        "description": "lab.lab10.lab10",
        "peekOfCode": "class nil:\n    \"\"\"The empty list\"\"\"\n    def __repr__(self):\n        return 'nil'\n    def __str__(self):\n        return '()'\n    def __len__(self):\n        return 0\n    def map(self, fn):\n        return self",
        "detail": "lab.lab10.lab10",
        "documentation": {}
    },
    {
        "label": "calc_eval",
        "kind": 2,
        "importPath": "lab.lab10.lab10",
        "description": "lab.lab10.lab10",
        "peekOfCode": "def calc_eval(exp):\n    \"\"\"\n    >>> calc_eval(Pair(\"define\", Pair(\"a\", Pair(1, nil))))\n    'a'\n    >>> calc_eval(\"a\")\n    1\n    >>> calc_eval(Pair(\"+\", Pair(1, Pair(2, nil))))\n    3\n    \"\"\"\n    if isinstance(exp, Pair):",
        "detail": "lab.lab10.lab10",
        "documentation": {}
    },
    {
        "label": "calc_apply",
        "kind": 2,
        "importPath": "lab.lab10.lab10",
        "description": "lab.lab10.lab10",
        "peekOfCode": "def calc_apply(op, args):\n    return op(args)\ndef floor_div(args):\n    \"\"\"\n    >>> floor_div(Pair(100, Pair(10, nil)))\n    10\n    >>> floor_div(Pair(5, Pair(3, nil)))\n    1\n    >>> floor_div(Pair(1, Pair(1, nil)))\n    1",
        "detail": "lab.lab10.lab10",
        "documentation": {}
    },
    {
        "label": "floor_div",
        "kind": 2,
        "importPath": "lab.lab10.lab10",
        "description": "lab.lab10.lab10",
        "peekOfCode": "def floor_div(args):\n    \"\"\"\n    >>> floor_div(Pair(100, Pair(10, nil)))\n    10\n    >>> floor_div(Pair(5, Pair(3, nil)))\n    1\n    >>> floor_div(Pair(1, Pair(1, nil)))\n    1\n    >>> floor_div(Pair(5, Pair(2, nil)))\n    2",
        "detail": "lab.lab10.lab10",
        "documentation": {}
    },
    {
        "label": "eval_and",
        "kind": 2,
        "importPath": "lab.lab10.lab10",
        "description": "lab.lab10.lab10",
        "peekOfCode": "def eval_and(expressions):\n    \"\"\"\n    >>> calc_eval(Pair(\"and\", Pair(1, nil)))\n    1\n    >>> calc_eval(Pair(\"and\", Pair(False, Pair(\"1\", nil))))\n    False\n    >>> calc_eval(Pair(\"and\", Pair(1, Pair(Pair(\"//\", Pair(5, Pair(2, nil))), nil))))\n    2\n    >>> calc_eval(Pair(\"and\", Pair(Pair('+', Pair(1, Pair(1, nil))), Pair(3, nil))))\n    3",
        "detail": "lab.lab10.lab10",
        "documentation": {}
    },
    {
        "label": "eval_define",
        "kind": 2,
        "importPath": "lab.lab10.lab10",
        "description": "lab.lab10.lab10",
        "peekOfCode": "def eval_define(expressions):\n    \"\"\"\n    >>> eval_define(Pair(\"a\", Pair(1, nil)))\n    'a'\n    >>> eval_define(Pair(\"b\", Pair(3, nil)))\n    'b'\n    >>> eval_define(Pair(\"c\", Pair(\"a\", nil)))\n    'c'\n    >>> calc_eval(\"c\")\n    1",
        "detail": "lab.lab10.lab10",
        "documentation": {}
    },
    {
        "label": "ob",
        "kind": 5,
        "importPath": "lab.lab10.lab10",
        "description": "lab.lab10.lab10",
        "peekOfCode": "ob = \"CmRlZiBhZGRpdGlvbihleHByKToKICAgIGRpdmlkZW5kID0gZXhwci5maXJzdAogICAgZXhwciA9IGV4cHIucmVzdAogICAgd2hpbGUgZXhwciAhPSBuaWw6CiAgICAgICAgZGl2aXNvciA9IGV4cHIuZmlyc3QKICAgICAgICBkaXZpZGVuZCArPSBkaXZpc29yCiAgICAgICAgZXhwciA9IGV4cHIucmVzdAogICAgcmV0dXJuIGRpdmlkZW5kCgpkZWYgc3VidHJhY3Rpb24oZXhwcik6CiAgICBkaXZpZGVuZCA9IGV4cHIuZmlyc3QKICAgIGV4cHIgPSBleHByLnJlc3QKICAgIHdoaWxlIGV4cHIgIT0gbmlsOgogICAgICAgIGRpdmlzb3IgPSBleHByLmZpcnN0CiAgICAgICAgZGl2aWRlbmQgLT0gZGl2aXNvcgogICAgICAgIGV4cHIgPSBleHByLnJlc3QKICAgIHJldHVybiBkaXZpZGVuZAoKZGVmIG11bHRpcGxpY2F0aW9uKGV4cHIpOgogICAgZGl2aWRlbmQgPSBleHByLmZpcnN0CiAgICBleHByID0gZXhwci5yZXN0CiAgICB3aGlsZSBleHByICE9IG5pbDoKICAgICAgICBkaXZpc29yID0gZXhwci5maXJzdAogICAgICAgIGRpdmlkZW5kICo9IGRpdmlzb3IKICAgICAgICBleHByID0gZXhwci5yZXN0CiAgICByZXR1cm4gZGl2aWRlbmQKCmRlZiBkaXZpc2lvbihleHByKToKICAgIGRpdmlkZW5kID0gZXhwci5maXJzdAogICAgZXhwciA9IGV4cHIucmVzdAogICAgd2hpbGUgZXhwciAhPSBuaWw6CiAgICAgICAgZGl2aXNvciA9IGV4cHIuZmlyc3QKICAgICAgICBkaXZpZGVuZCAvPSBkaXZpc29yCiAgICAgICAgZXhwciA9IGV4cHIucmVzdAogICAgcmV0dXJuIGRpdmlkZW5kCg==\"\nexec(base64.b64decode(ob.encode(\"ascii\")).decode(\"ascii\"))\n##############\ndef calc_eval(exp):\n    \"\"\"\n    >>> calc_eval(Pair(\"define\", Pair(\"a\", Pair(1, nil))))\n    'a'\n    >>> calc_eval(\"a\")\n    1\n    >>> calc_eval(Pair(\"+\", Pair(1, Pair(2, nil))))",
        "detail": "lab.lab10.lab10",
        "documentation": {}
    },
    {
        "label": "scheme_t",
        "kind": 5,
        "importPath": "lab.lab10.lab10",
        "description": "lab.lab10.lab10",
        "peekOfCode": "scheme_t = True   # Scheme's #t\nscheme_f = False  # Scheme's #f\ndef eval_and(expressions):\n    \"\"\"\n    >>> calc_eval(Pair(\"and\", Pair(1, nil)))\n    1\n    >>> calc_eval(Pair(\"and\", Pair(False, Pair(\"1\", nil))))\n    False\n    >>> calc_eval(Pair(\"and\", Pair(1, Pair(Pair(\"//\", Pair(5, Pair(2, nil))), nil))))\n    2",
        "detail": "lab.lab10.lab10",
        "documentation": {}
    },
    {
        "label": "scheme_f",
        "kind": 5,
        "importPath": "lab.lab10.lab10",
        "description": "lab.lab10.lab10",
        "peekOfCode": "scheme_f = False  # Scheme's #f\ndef eval_and(expressions):\n    \"\"\"\n    >>> calc_eval(Pair(\"and\", Pair(1, nil)))\n    1\n    >>> calc_eval(Pair(\"and\", Pair(False, Pair(\"1\", nil))))\n    False\n    >>> calc_eval(Pair(\"and\", Pair(1, Pair(Pair(\"//\", Pair(5, Pair(2, nil))), nil))))\n    2\n    >>> calc_eval(Pair(\"and\", Pair(Pair('+', Pair(1, Pair(1, nil))), Pair(3, nil))))",
        "detail": "lab.lab10.lab10",
        "documentation": {}
    },
    {
        "label": "bindings",
        "kind": 5,
        "importPath": "lab.lab10.lab10",
        "description": "lab.lab10.lab10",
        "peekOfCode": "bindings = {}\ndef eval_define(expressions):\n    \"\"\"\n    >>> eval_define(Pair(\"a\", Pair(1, nil)))\n    'a'\n    >>> eval_define(Pair(\"b\", Pair(3, nil)))\n    'b'\n    >>> eval_define(Pair(\"c\", Pair(\"a\", nil)))\n    'c'\n    >>> calc_eval(\"c\")",
        "detail": "lab.lab10.lab10",
        "documentation": {}
    },
    {
        "label": "OPERATORS",
        "kind": 5,
        "importPath": "lab.lab10.lab10",
        "description": "lab.lab10.lab10",
        "peekOfCode": "OPERATORS = { \"//\": floor_div, \"+\": addition, \"-\": subtraction, \"*\": multiplication, \"/\": division }\nclass Pair:\n    \"\"\"A pair has two instance attributes: first and rest. rest must be a Pair or nil\n    >>> s = Pair(1, Pair(2, nil))\n    >>> s\n    Pair(1, Pair(2, nil))\n    >>> print(s)\n    (1 2)\n    >>> print(s.map(lambda x: x+4))\n    (5 6)",
        "detail": "lab.lab10.lab10",
        "documentation": {}
    },
    {
        "label": "nil",
        "kind": 5,
        "importPath": "lab.lab10.lab10",
        "description": "lab.lab10.lab10",
        "peekOfCode": "nil = nil() # Assignment hides the nil class; there is only one instance",
        "detail": "lab.lab10.lab10",
        "documentation": {}
    },
    {
        "label": "BlockGrammar",
        "kind": 6,
        "importPath": "lab.lab11.editor.libraries.mistune",
        "description": "lab.lab11.editor.libraries.mistune",
        "peekOfCode": "class BlockGrammar(object):\n    \"\"\"Grammars for block level tokens.\"\"\"\n    def_links = re.compile(\n        r'^ *\\[([^^\\]]+)\\]: *'  # [key]:\n        r'<?([^\\s>]+)>?'  # <link> or link\n        r'(?: +[\"(]([^\\n]+)[\")])? *(?:\\n+|$)'\n    )\n    def_footnotes = re.compile(\n        r'^\\[\\^([^\\]]+)\\]: *('\n        r'[^\\n]*(?:\\n+|$)'  # [^key]:",
        "detail": "lab.lab11.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "BlockLexer",
        "kind": 6,
        "importPath": "lab.lab11.editor.libraries.mistune",
        "description": "lab.lab11.editor.libraries.mistune",
        "peekOfCode": "class BlockLexer(object):\n    \"\"\"Block level lexer for block grammars.\"\"\"\n    grammar_class = BlockGrammar\n    default_rules = [\n        'newline', 'hrule', 'block_code', 'fences', 'heading',\n        'nptable', 'lheading', 'block_quote',\n        'list_block', 'block_html', 'def_links',\n        'def_footnotes', 'table', 'paragraph', 'text'\n    ]\n    list_rules = (",
        "detail": "lab.lab11.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "InlineGrammar",
        "kind": 6,
        "importPath": "lab.lab11.editor.libraries.mistune",
        "description": "lab.lab11.editor.libraries.mistune",
        "peekOfCode": "class InlineGrammar(object):\n    \"\"\"Grammars for inline level tokens.\"\"\"\n    escape = re.compile(r'^\\\\([\\\\`*{}\\[\\]()#+\\-.!_>~|])')  # \\* \\+ \\! ....\n    inline_html = re.compile(\n        r'^(?:%s|%s|%s)' % (\n            r'<!--[\\s\\S]*?-->',\n            r'<(\\w+%s)((?:%s)*?)\\s*>([\\s\\S]*?)<\\/\\1>' % (\n                _valid_end, _valid_attr),\n            r'<\\w+%s(?:%s)*?\\s*\\/?>' % (_valid_end, _valid_attr),\n        )",
        "detail": "lab.lab11.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "InlineLexer",
        "kind": 6,
        "importPath": "lab.lab11.editor.libraries.mistune",
        "description": "lab.lab11.editor.libraries.mistune",
        "peekOfCode": "class InlineLexer(object):\n    \"\"\"Inline level lexer for inline grammars.\"\"\"\n    grammar_class = InlineGrammar\n    default_rules = [\n        'escape', 'inline_html', 'autolink', 'url',\n        'footnote', 'link', 'reflink', 'nolink',\n        'double_emphasis', 'emphasis', 'code',\n        'linebreak', 'strikethrough', 'text',\n    ]\n    inline_html_rules = [",
        "detail": "lab.lab11.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "Renderer",
        "kind": 6,
        "importPath": "lab.lab11.editor.libraries.mistune",
        "description": "lab.lab11.editor.libraries.mistune",
        "peekOfCode": "class Renderer(object):\n    \"\"\"The default HTML renderer for rendering Markdown.\n    \"\"\"\n    def __init__(self, **kwargs):\n        self.options = kwargs\n    def placeholder(self):\n        \"\"\"Returns the default, empty output value for the renderer.\n        All renderer methods use the '+=' operator to append to this value.\n        Default is a string so rendering HTML can build up a result string with\n        the rendered Markdown.",
        "detail": "lab.lab11.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "Markdown",
        "kind": 6,
        "importPath": "lab.lab11.editor.libraries.mistune",
        "description": "lab.lab11.editor.libraries.mistune",
        "peekOfCode": "class Markdown(object):\n    \"\"\"The Markdown parser.\n    :param renderer: An instance of ``Renderer``.\n    :param inline: An inline lexer class or instance.\n    :param block: A block lexer class or instance.\n    \"\"\"\n    def __init__(self, renderer=None, inline=None, block=None, **kwargs):\n        if not renderer:\n            renderer = Renderer(**kwargs)\n        else:",
        "detail": "lab.lab11.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "escape",
        "kind": 2,
        "importPath": "lab.lab11.editor.libraries.mistune",
        "description": "lab.lab11.editor.libraries.mistune",
        "peekOfCode": "def escape(text, quote=False, smart_amp=True):\n    \"\"\"Replace special characters \"&\", \"<\" and \">\" to HTML-safe sequences.\n    The original cgi.escape will always escape \"&\", but you can control\n    this one for a smart escape amp.\n    :param quote: if set to True, \" and ' will be escaped.\n    :param smart_amp: if set to False, & will always be escaped.\n    \"\"\"\n    if smart_amp:\n        text = _escape_pattern.sub('&amp;', text)\n    else:",
        "detail": "lab.lab11.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "escape_link",
        "kind": 2,
        "importPath": "lab.lab11.editor.libraries.mistune",
        "description": "lab.lab11.editor.libraries.mistune",
        "peekOfCode": "def escape_link(url):\n    \"\"\"Remove dangerous URL schemes like javascript: and escape afterwards.\"\"\"\n    lower_url = url.lower().strip('\\x00\\x1a \\n\\r\\t')\n    for scheme in _scheme_blacklist:\n        if re.sub(r'[^A-Za-z0-9\\/:]+', '', lower_url).startswith(scheme):\n            return ''\n    return escape(url, quote=True, smart_amp=False)\ndef preprocessing(text, tab=4):\n    text = _newline_pattern.sub('\\n', text)\n    text = text.expandtabs(tab)",
        "detail": "lab.lab11.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "preprocessing",
        "kind": 2,
        "importPath": "lab.lab11.editor.libraries.mistune",
        "description": "lab.lab11.editor.libraries.mistune",
        "peekOfCode": "def preprocessing(text, tab=4):\n    text = _newline_pattern.sub('\\n', text)\n    text = text.expandtabs(tab)\n    text = text.replace('\\u2424', '\\n')\n    pattern = re.compile(r'^ +$', re.M)\n    return pattern.sub('', text)\nclass BlockGrammar(object):\n    \"\"\"Grammars for block level tokens.\"\"\"\n    def_links = re.compile(\n        r'^ *\\[([^^\\]]+)\\]: *'  # [key]:",
        "detail": "lab.lab11.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "markdown",
        "kind": 2,
        "importPath": "lab.lab11.editor.libraries.mistune",
        "description": "lab.lab11.editor.libraries.mistune",
        "peekOfCode": "def markdown(text, escape=True, **kwargs):\n    \"\"\"Render markdown formatted text to html.\n    :param text: markdown formatted text content.\n    :param escape: if set to False, all html tags will not be escaped.\n    :param use_xhtml: output with xhtml tags.\n    :param hard_wrap: if set to True, it will use the GFM line breaks feature.\n    :param parse_block_html: parse text only in block level html.\n    :param parse_inline_html: parse text only in inline level html.\n    \"\"\"\n    return Markdown(escape=escape, **kwargs)(text)",
        "detail": "lab.lab11.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "lab.lab11.editor.libraries.mistune",
        "description": "lab.lab11.editor.libraries.mistune",
        "peekOfCode": "__version__ = '0.8.4'\n__author__ = 'Hsiaoming Yang <me@lepture.com>'\n__all__ = [\n    'BlockGrammar', 'BlockLexer',\n    'InlineGrammar', 'InlineLexer',\n    'Renderer', 'Markdown',\n    'markdown', 'escape',\n]\n_key_pattern = re.compile(r'\\s+')\n_nonalpha_pattern = re.compile(r'\\W')",
        "detail": "lab.lab11.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "__author__",
        "kind": 5,
        "importPath": "lab.lab11.editor.libraries.mistune",
        "description": "lab.lab11.editor.libraries.mistune",
        "peekOfCode": "__author__ = 'Hsiaoming Yang <me@lepture.com>'\n__all__ = [\n    'BlockGrammar', 'BlockLexer',\n    'InlineGrammar', 'InlineLexer',\n    'Renderer', 'Markdown',\n    'markdown', 'escape',\n]\n_key_pattern = re.compile(r'\\s+')\n_nonalpha_pattern = re.compile(r'\\W')\n_escape_pattern = re.compile(r'&(?!#?\\w+;)')",
        "detail": "lab.lab11.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "lab.lab11.editor.libraries.mistune",
        "description": "lab.lab11.editor.libraries.mistune",
        "peekOfCode": "__all__ = [\n    'BlockGrammar', 'BlockLexer',\n    'InlineGrammar', 'InlineLexer',\n    'Renderer', 'Markdown',\n    'markdown', 'escape',\n]\n_key_pattern = re.compile(r'\\s+')\n_nonalpha_pattern = re.compile(r'\\W')\n_escape_pattern = re.compile(r'&(?!#?\\w+;)')\n_newline_pattern = re.compile(r'\\r\\n|\\r')",
        "detail": "lab.lab11.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "_key_pattern",
        "kind": 5,
        "importPath": "lab.lab11.editor.libraries.mistune",
        "description": "lab.lab11.editor.libraries.mistune",
        "peekOfCode": "_key_pattern = re.compile(r'\\s+')\n_nonalpha_pattern = re.compile(r'\\W')\n_escape_pattern = re.compile(r'&(?!#?\\w+;)')\n_newline_pattern = re.compile(r'\\r\\n|\\r')\n_block_quote_leading_pattern = re.compile(r'^ *> ?', flags=re.M)\n_block_code_leading_pattern = re.compile(r'^ {4}', re.M)\n_inline_tags = [\n    'a', 'em', 'strong', 'small', 's', 'cite', 'q', 'dfn', 'abbr', 'data',\n    'time', 'code', 'var', 'samp', 'kbd', 'sub', 'sup', 'i', 'b', 'u', 'mark',\n    'ruby', 'rt', 'rp', 'bdi', 'bdo', 'span', 'br', 'wbr', 'ins', 'del',",
        "detail": "lab.lab11.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "_nonalpha_pattern",
        "kind": 5,
        "importPath": "lab.lab11.editor.libraries.mistune",
        "description": "lab.lab11.editor.libraries.mistune",
        "peekOfCode": "_nonalpha_pattern = re.compile(r'\\W')\n_escape_pattern = re.compile(r'&(?!#?\\w+;)')\n_newline_pattern = re.compile(r'\\r\\n|\\r')\n_block_quote_leading_pattern = re.compile(r'^ *> ?', flags=re.M)\n_block_code_leading_pattern = re.compile(r'^ {4}', re.M)\n_inline_tags = [\n    'a', 'em', 'strong', 'small', 's', 'cite', 'q', 'dfn', 'abbr', 'data',\n    'time', 'code', 'var', 'samp', 'kbd', 'sub', 'sup', 'i', 'b', 'u', 'mark',\n    'ruby', 'rt', 'rp', 'bdi', 'bdo', 'span', 'br', 'wbr', 'ins', 'del',\n    'img', 'font',",
        "detail": "lab.lab11.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "_escape_pattern",
        "kind": 5,
        "importPath": "lab.lab11.editor.libraries.mistune",
        "description": "lab.lab11.editor.libraries.mistune",
        "peekOfCode": "_escape_pattern = re.compile(r'&(?!#?\\w+;)')\n_newline_pattern = re.compile(r'\\r\\n|\\r')\n_block_quote_leading_pattern = re.compile(r'^ *> ?', flags=re.M)\n_block_code_leading_pattern = re.compile(r'^ {4}', re.M)\n_inline_tags = [\n    'a', 'em', 'strong', 'small', 's', 'cite', 'q', 'dfn', 'abbr', 'data',\n    'time', 'code', 'var', 'samp', 'kbd', 'sub', 'sup', 'i', 'b', 'u', 'mark',\n    'ruby', 'rt', 'rp', 'bdi', 'bdo', 'span', 'br', 'wbr', 'ins', 'del',\n    'img', 'font',\n]",
        "detail": "lab.lab11.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "_newline_pattern",
        "kind": 5,
        "importPath": "lab.lab11.editor.libraries.mistune",
        "description": "lab.lab11.editor.libraries.mistune",
        "peekOfCode": "_newline_pattern = re.compile(r'\\r\\n|\\r')\n_block_quote_leading_pattern = re.compile(r'^ *> ?', flags=re.M)\n_block_code_leading_pattern = re.compile(r'^ {4}', re.M)\n_inline_tags = [\n    'a', 'em', 'strong', 'small', 's', 'cite', 'q', 'dfn', 'abbr', 'data',\n    'time', 'code', 'var', 'samp', 'kbd', 'sub', 'sup', 'i', 'b', 'u', 'mark',\n    'ruby', 'rt', 'rp', 'bdi', 'bdo', 'span', 'br', 'wbr', 'ins', 'del',\n    'img', 'font',\n]\n_pre_tags = ['pre', 'script', 'style']",
        "detail": "lab.lab11.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "_block_quote_leading_pattern",
        "kind": 5,
        "importPath": "lab.lab11.editor.libraries.mistune",
        "description": "lab.lab11.editor.libraries.mistune",
        "peekOfCode": "_block_quote_leading_pattern = re.compile(r'^ *> ?', flags=re.M)\n_block_code_leading_pattern = re.compile(r'^ {4}', re.M)\n_inline_tags = [\n    'a', 'em', 'strong', 'small', 's', 'cite', 'q', 'dfn', 'abbr', 'data',\n    'time', 'code', 'var', 'samp', 'kbd', 'sub', 'sup', 'i', 'b', 'u', 'mark',\n    'ruby', 'rt', 'rp', 'bdi', 'bdo', 'span', 'br', 'wbr', 'ins', 'del',\n    'img', 'font',\n]\n_pre_tags = ['pre', 'script', 'style']\n_valid_end = r'(?!:/|[^\\w\\s@]*@)\\b'",
        "detail": "lab.lab11.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "_block_code_leading_pattern",
        "kind": 5,
        "importPath": "lab.lab11.editor.libraries.mistune",
        "description": "lab.lab11.editor.libraries.mistune",
        "peekOfCode": "_block_code_leading_pattern = re.compile(r'^ {4}', re.M)\n_inline_tags = [\n    'a', 'em', 'strong', 'small', 's', 'cite', 'q', 'dfn', 'abbr', 'data',\n    'time', 'code', 'var', 'samp', 'kbd', 'sub', 'sup', 'i', 'b', 'u', 'mark',\n    'ruby', 'rt', 'rp', 'bdi', 'bdo', 'span', 'br', 'wbr', 'ins', 'del',\n    'img', 'font',\n]\n_pre_tags = ['pre', 'script', 'style']\n_valid_end = r'(?!:/|[^\\w\\s@]*@)\\b'\n_valid_attr = r'''\\s*[a-zA-Z\\-](?:\\s*\\=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">]+))?'''",
        "detail": "lab.lab11.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "_inline_tags",
        "kind": 5,
        "importPath": "lab.lab11.editor.libraries.mistune",
        "description": "lab.lab11.editor.libraries.mistune",
        "peekOfCode": "_inline_tags = [\n    'a', 'em', 'strong', 'small', 's', 'cite', 'q', 'dfn', 'abbr', 'data',\n    'time', 'code', 'var', 'samp', 'kbd', 'sub', 'sup', 'i', 'b', 'u', 'mark',\n    'ruby', 'rt', 'rp', 'bdi', 'bdo', 'span', 'br', 'wbr', 'ins', 'del',\n    'img', 'font',\n]\n_pre_tags = ['pre', 'script', 'style']\n_valid_end = r'(?!:/|[^\\w\\s@]*@)\\b'\n_valid_attr = r'''\\s*[a-zA-Z\\-](?:\\s*\\=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">]+))?'''\n_block_tag = r'(?!(?:%s)\\b)\\w+%s' % ('|'.join(_inline_tags), _valid_end)",
        "detail": "lab.lab11.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "_pre_tags",
        "kind": 5,
        "importPath": "lab.lab11.editor.libraries.mistune",
        "description": "lab.lab11.editor.libraries.mistune",
        "peekOfCode": "_pre_tags = ['pre', 'script', 'style']\n_valid_end = r'(?!:/|[^\\w\\s@]*@)\\b'\n_valid_attr = r'''\\s*[a-zA-Z\\-](?:\\s*\\=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">]+))?'''\n_block_tag = r'(?!(?:%s)\\b)\\w+%s' % ('|'.join(_inline_tags), _valid_end)\n_scheme_blacklist = ('javascript:', 'vbscript:')\ndef _pure_pattern(regex):\n    pattern = regex.pattern\n    if pattern.startswith('^'):\n        pattern = pattern[1:]\n    return pattern",
        "detail": "lab.lab11.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "_valid_end",
        "kind": 5,
        "importPath": "lab.lab11.editor.libraries.mistune",
        "description": "lab.lab11.editor.libraries.mistune",
        "peekOfCode": "_valid_end = r'(?!:/|[^\\w\\s@]*@)\\b'\n_valid_attr = r'''\\s*[a-zA-Z\\-](?:\\s*\\=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">]+))?'''\n_block_tag = r'(?!(?:%s)\\b)\\w+%s' % ('|'.join(_inline_tags), _valid_end)\n_scheme_blacklist = ('javascript:', 'vbscript:')\ndef _pure_pattern(regex):\n    pattern = regex.pattern\n    if pattern.startswith('^'):\n        pattern = pattern[1:]\n    return pattern\ndef _keyify(key):",
        "detail": "lab.lab11.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "_valid_attr",
        "kind": 5,
        "importPath": "lab.lab11.editor.libraries.mistune",
        "description": "lab.lab11.editor.libraries.mistune",
        "peekOfCode": "_valid_attr = r'''\\s*[a-zA-Z\\-](?:\\s*\\=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">]+))?'''\n_block_tag = r'(?!(?:%s)\\b)\\w+%s' % ('|'.join(_inline_tags), _valid_end)\n_scheme_blacklist = ('javascript:', 'vbscript:')\ndef _pure_pattern(regex):\n    pattern = regex.pattern\n    if pattern.startswith('^'):\n        pattern = pattern[1:]\n    return pattern\ndef _keyify(key):\n    key = escape(key.lower(), quote=True)",
        "detail": "lab.lab11.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "_block_tag",
        "kind": 5,
        "importPath": "lab.lab11.editor.libraries.mistune",
        "description": "lab.lab11.editor.libraries.mistune",
        "peekOfCode": "_block_tag = r'(?!(?:%s)\\b)\\w+%s' % ('|'.join(_inline_tags), _valid_end)\n_scheme_blacklist = ('javascript:', 'vbscript:')\ndef _pure_pattern(regex):\n    pattern = regex.pattern\n    if pattern.startswith('^'):\n        pattern = pattern[1:]\n    return pattern\ndef _keyify(key):\n    key = escape(key.lower(), quote=True)\n    return _key_pattern.sub(' ', key)",
        "detail": "lab.lab11.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "_scheme_blacklist",
        "kind": 5,
        "importPath": "lab.lab11.editor.libraries.mistune",
        "description": "lab.lab11.editor.libraries.mistune",
        "peekOfCode": "_scheme_blacklist = ('javascript:', 'vbscript:')\ndef _pure_pattern(regex):\n    pattern = regex.pattern\n    if pattern.startswith('^'):\n        pattern = pattern[1:]\n    return pattern\ndef _keyify(key):\n    key = escape(key.lower(), quote=True)\n    return _key_pattern.sub(' ', key)\ndef escape(text, quote=False, smart_amp=True):",
        "detail": "lab.lab11.editor.libraries.mistune",
        "documentation": {}
    },
    {
        "label": "Add",
        "kind": 6,
        "importPath": "lab.lab11.editor.arithmetic",
        "description": "lab.lab11.editor.arithmetic",
        "peekOfCode": "class Add(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame):\n        assert_all_numbers(operands)\n        return Number(sum(operand.value for operand in operands))\n@global_attr(\"-\")\nclass Subtract(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame):\n        verify_min_callable_length(self, 1, len(operands))\n        assert_all_numbers(operands)\n        if len(operands) == 1:",
        "detail": "lab.lab11.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "Subtract",
        "kind": 6,
        "importPath": "lab.lab11.editor.arithmetic",
        "description": "lab.lab11.editor.arithmetic",
        "peekOfCode": "class Subtract(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame):\n        verify_min_callable_length(self, 1, len(operands))\n        assert_all_numbers(operands)\n        if len(operands) == 1:\n            return Number(-operands[0].value)\n        return Number(operands[0].value - sum(operand.value for operand in operands[1:]))\n@global_attr(\"*\")\nclass Multiply(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame):",
        "detail": "lab.lab11.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "Multiply",
        "kind": 6,
        "importPath": "lab.lab11.editor.arithmetic",
        "description": "lab.lab11.editor.arithmetic",
        "peekOfCode": "class Multiply(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame):\n        assert_all_numbers(operands)\n        out = 1\n        for operand in operands:\n            out *= operand.value\n        return Number(out)\n@global_attr(\"/\")\nclass Divide(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:",
        "detail": "lab.lab11.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "Divide",
        "kind": 6,
        "importPath": "lab.lab11.editor.arithmetic",
        "description": "lab.lab11.editor.arithmetic",
        "peekOfCode": "class Divide(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_min_callable_length(self, 1, len(operands))\n        assert_all_numbers(operands)\n        if len(operands) == 1:\n            return Number(1 / operands[0].value)\n        out = operands[0].value\n        for operand in operands[1:]:\n            out /= operand.value\n        return Number(out)",
        "detail": "lab.lab11.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "Abs",
        "kind": 6,
        "importPath": "lab.lab11.editor.arithmetic",
        "description": "lab.lab11.editor.arithmetic",
        "peekOfCode": "class Abs(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        assert_all_numbers([operand])\n        return Number(abs(operand.value))\n@global_attr(\"expt\")\nclass Expt(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        assert_all_numbers(operands)\n        return Number(operands[0].value ** operands[1].value)",
        "detail": "lab.lab11.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "Expt",
        "kind": 6,
        "importPath": "lab.lab11.editor.arithmetic",
        "description": "lab.lab11.editor.arithmetic",
        "peekOfCode": "class Expt(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        assert_all_numbers(operands)\n        return Number(operands[0].value ** operands[1].value)\n@global_attr(\"modulo\")\nclass Modulo(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        assert_all_numbers(operands)",
        "detail": "lab.lab11.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "Modulo",
        "kind": 6,
        "importPath": "lab.lab11.editor.arithmetic",
        "description": "lab.lab11.editor.arithmetic",
        "peekOfCode": "class Modulo(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        assert_all_numbers(operands)\n        return Number(operands[0].value % abs(operands[1].value))\n@global_attr(\"quotient\")\nclass Quotient(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        assert_all_numbers(operands)",
        "detail": "lab.lab11.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "Quotient",
        "kind": 6,
        "importPath": "lab.lab11.editor.arithmetic",
        "description": "lab.lab11.editor.arithmetic",
        "peekOfCode": "class Quotient(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        assert_all_numbers(operands)\n        negate = (operands[0].value < 0) != (operands[1].value < 0)\n        negate = -1 if negate else 1\n        return Number(negate * operands[0].value // operands[1].value)\n@global_attr(\"remainder\")\nclass Remainder(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:",
        "detail": "lab.lab11.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "Remainder",
        "kind": 6,
        "importPath": "lab.lab11.editor.arithmetic",
        "description": "lab.lab11.editor.arithmetic",
        "peekOfCode": "class Remainder(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        assert_all_numbers(operands)\n        negate = (operands[0].value < 0)\n        negate = -1 if negate else 1\n        return Number(negate * (abs(operands[0].value) % abs(operands[1].value)))\n@global_attr(\"=\")\nclass NumEq(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:",
        "detail": "lab.lab11.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "NumEq",
        "kind": 6,
        "importPath": "lab.lab11.editor.arithmetic",
        "description": "lab.lab11.editor.arithmetic",
        "peekOfCode": "class NumEq(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        assert_all_numbers(operands)\n        return bools[operands[0].value == operands[1].value]\n@global_attr(\"<\")\nclass Less(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        assert_all_numbers(operands)",
        "detail": "lab.lab11.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "Less",
        "kind": 6,
        "importPath": "lab.lab11.editor.arithmetic",
        "description": "lab.lab11.editor.arithmetic",
        "peekOfCode": "class Less(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        assert_all_numbers(operands)\n        return bools[operands[0].value < operands[1].value]\n@global_attr(\"<=\")\nclass LessOrEq(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        assert_all_numbers(operands)",
        "detail": "lab.lab11.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "LessOrEq",
        "kind": 6,
        "importPath": "lab.lab11.editor.arithmetic",
        "description": "lab.lab11.editor.arithmetic",
        "peekOfCode": "class LessOrEq(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        assert_all_numbers(operands)\n        return bools[operands[0].value <= operands[1].value]\n@global_attr(\">\")\nclass Greater(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        assert_all_numbers(operands)",
        "detail": "lab.lab11.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "Greater",
        "kind": 6,
        "importPath": "lab.lab11.editor.arithmetic",
        "description": "lab.lab11.editor.arithmetic",
        "peekOfCode": "class Greater(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        assert_all_numbers(operands)\n        return bools[operands[0].value > operands[1].value]\n@global_attr(\">=\")\nclass GreaterOrEq(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        assert_all_numbers(operands)",
        "detail": "lab.lab11.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "GreaterOrEq",
        "kind": 6,
        "importPath": "lab.lab11.editor.arithmetic",
        "description": "lab.lab11.editor.arithmetic",
        "peekOfCode": "class GreaterOrEq(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        assert_all_numbers(operands)\n        return bools[operands[0].value >= operands[1].value]\n@global_attr(\"even?\")\nclass IsEven(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        assert_all_numbers([operand])\n        return bools[not operand.value % 2]",
        "detail": "lab.lab11.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "IsEven",
        "kind": 6,
        "importPath": "lab.lab11.editor.arithmetic",
        "description": "lab.lab11.editor.arithmetic",
        "peekOfCode": "class IsEven(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        assert_all_numbers([operand])\n        return bools[not operand.value % 2]\n@global_attr(\"odd?\")\nclass IsOdd(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        assert_all_numbers([operand])\n        return bools[operand.value % 2]\n@global_attr(\"zero?\")",
        "detail": "lab.lab11.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "IsOdd",
        "kind": 6,
        "importPath": "lab.lab11.editor.arithmetic",
        "description": "lab.lab11.editor.arithmetic",
        "peekOfCode": "class IsOdd(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        assert_all_numbers([operand])\n        return bools[operand.value % 2]\n@global_attr(\"zero?\")\nclass IsZero(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        assert_all_numbers([operand])\n        return bools[operand.value == 0]\n@global_attr(\"not\")",
        "detail": "lab.lab11.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "IsZero",
        "kind": 6,
        "importPath": "lab.lab11.editor.arithmetic",
        "description": "lab.lab11.editor.arithmetic",
        "peekOfCode": "class IsZero(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        assert_all_numbers([operand])\n        return bools[operand.value == 0]\n@global_attr(\"not\")\nclass Not(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        return bools[operand is SingletonFalse]\n@global_attr(\"eqv?\")\nclass IsEqv(BuiltIn):",
        "detail": "lab.lab11.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "Not",
        "kind": 6,
        "importPath": "lab.lab11.editor.arithmetic",
        "description": "lab.lab11.editor.arithmetic",
        "peekOfCode": "class Not(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        return bools[operand is SingletonFalse]\n@global_attr(\"eqv?\")\nclass IsEqv(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame):\n        verify_exact_callable_length(self, 2, len(operands))\n        if all(isinstance(x, ValueHolder) for x in operands):\n            return bools[operands[0].value == operands[1].value]\n        return bools[operands[0] is operands[1]]",
        "detail": "lab.lab11.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "IsEqv",
        "kind": 6,
        "importPath": "lab.lab11.editor.arithmetic",
        "description": "lab.lab11.editor.arithmetic",
        "peekOfCode": "class IsEqv(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame):\n        verify_exact_callable_length(self, 2, len(operands))\n        if all(isinstance(x, ValueHolder) for x in operands):\n            return bools[operands[0].value == operands[1].value]\n        return bools[operands[0] is operands[1]]\n@global_attr(\"eq?\")\nclass IsEq(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame):\n        verify_exact_callable_length(self, 2, len(operands))",
        "detail": "lab.lab11.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "IsEq",
        "kind": 6,
        "importPath": "lab.lab11.editor.arithmetic",
        "description": "lab.lab11.editor.arithmetic",
        "peekOfCode": "class IsEq(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame):\n        verify_exact_callable_length(self, 2, len(operands))\n        if all(isinstance(x, ValueHolder) for x in operands):\n            if isinstance(operands[0], Number):\n                return bools[operands[0] is operands[1]]\n            else:\n                return bools[operands[0].value == operands[1].value]\n        return bools[operands[0] is operands[1]]\n@global_attr(\"equal?\")",
        "detail": "lab.lab11.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "IsEqual",
        "kind": 6,
        "importPath": "lab.lab11.editor.arithmetic",
        "description": "lab.lab11.editor.arithmetic",
        "peekOfCode": "class IsEqual(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame):\n        verify_exact_callable_length(self, 2, len(operands))\n        if all(isinstance(x, ValueHolder) for x in operands):\n            return bools[operands[0].value == operands[1].value]\n        elif all(isinstance(x, Pair) for x in operands):\n            return bools[IsEqual().execute_evaluated([operands[0].first, operands[1].first], frame) is SingletonTrue and \\\n                         IsEqual().execute_evaluated([operands[0].rest, operands[1].rest], frame) is SingletonTrue]\n        else:\n            return IsEqv().execute_evaluated(operands, frame)",
        "detail": "lab.lab11.editor.arithmetic",
        "documentation": {}
    },
    {
        "label": "Print",
        "kind": 6,
        "importPath": "lab.lab11.editor.console",
        "description": "lab.lab11.editor.console",
        "peekOfCode": "class Print(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        log.logger.out(operand)\n        return Undefined\n@global_attr(\"display\")\nclass Display(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if isinstance(operand, String):\n            log.logger.raw_out(operand.value)\n        else:",
        "detail": "lab.lab11.editor.console",
        "documentation": {}
    },
    {
        "label": "Display",
        "kind": 6,
        "importPath": "lab.lab11.editor.console",
        "description": "lab.lab11.editor.console",
        "peekOfCode": "class Display(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if isinstance(operand, String):\n            log.logger.raw_out(operand.value)\n        else:\n            log.logger.out(operand, end=\"\")\n        return Undefined\n@global_attr(\"newline\")\nclass Newline(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:",
        "detail": "lab.lab11.editor.console",
        "documentation": {}
    },
    {
        "label": "Newline",
        "kind": 6,
        "importPath": "lab.lab11.editor.console",
        "description": "lab.lab11.editor.console",
        "peekOfCode": "class Newline(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 0, len(operands))\n        log.logger.raw_out(\"\\n\")\n        return Undefined",
        "detail": "lab.lab11.editor.console",
        "documentation": {}
    },
    {
        "label": "COLORS",
        "kind": 5,
        "importPath": "lab.lab11.editor.css_colors",
        "description": "lab.lab11.editor.css_colors",
        "peekOfCode": "COLORS = {\n  \"aliceblue\": \"#f0f8ff\",\n  \"antiquewhite\": \"#faebd7\",\n  \"aqua\": \"#00ffff\",\n  \"aquamarine\": \"#7fffd4\",\n  \"azure\": \"#f0ffff\",\n  \"beige\": \"#f5f5dc\",\n  \"bisque\": \"#ffe4c4\",\n  \"black\": \"#000000\",\n  \"blanchedalmond\": \"#ffebcd\",",
        "detail": "lab.lab11.editor.css_colors",
        "documentation": {}
    },
    {
        "label": "get_word",
        "kind": 2,
        "importPath": "lab.lab11.editor.database",
        "description": "lab.lab11.editor.database",
        "peekOfCode": "def get_word() -> str:\n    with open(\"src/words.txt\") as file:\n        word = next(file)\n        for i, trial in enumerate(file):\n            if randrange(i + 2) != 0:\n                continue\n            word = trial\n        return word\ndef generate_id(n=3):\n    return \"\".join(get_word().lower().capitalize().strip() for _ in range(3))",
        "detail": "lab.lab11.editor.database",
        "documentation": {}
    },
    {
        "label": "generate_id",
        "kind": 2,
        "importPath": "lab.lab11.editor.database",
        "description": "lab.lab11.editor.database",
        "peekOfCode": "def generate_id(n=3):\n    return \"\".join(get_word().lower().capitalize().strip() for _ in range(3))\ndef save(code_lines, skip_envs, hide_return_frames):\n    conn = sqlite3.connect(\"saved\")\n    to_store = repr(code_lines)\n    lookup = generate_id()\n    conn.execute(\"INSERT INTO stored_lines VALUES(?, ?, ?, ?)\",\n                 (lookup, to_store, skip_envs, hide_return_frames))\n    conn.commit()\n    conn.close()",
        "detail": "lab.lab11.editor.database",
        "documentation": {}
    },
    {
        "label": "save",
        "kind": 2,
        "importPath": "lab.lab11.editor.database",
        "description": "lab.lab11.editor.database",
        "peekOfCode": "def save(code_lines, skip_envs, hide_return_frames):\n    conn = sqlite3.connect(\"saved\")\n    to_store = repr(code_lines)\n    lookup = generate_id()\n    conn.execute(\"INSERT INTO stored_lines VALUES(?, ?, ?, ?)\",\n                 (lookup, to_store, skip_envs, hide_return_frames))\n    conn.commit()\n    conn.close()\n    return lookup\ndef load(lookup) -> Union[Tuple, None]:",
        "detail": "lab.lab11.editor.database",
        "documentation": {}
    },
    {
        "label": "load",
        "kind": 2,
        "importPath": "lab.lab11.editor.database",
        "description": "lab.lab11.editor.database",
        "peekOfCode": "def load(lookup) -> Union[Tuple, None]:\n    conn = sqlite3.connect(\"saved\")\n    for row in conn.execute('SELECT * FROM stored_lines WHERE code=?', (lookup,)):\n        return row[1:]\n    conn.close()",
        "detail": "lab.lab11.editor.database",
        "documentation": {}
    },
    {
        "label": "Expression",
        "kind": 6,
        "importPath": "lab.lab11.editor.datamodel",
        "description": "lab.lab11.editor.datamodel",
        "peekOfCode": "class Expression:\n    def __init__(self):\n        self.id = None\nclass ValueHolder(Expression):\n    def __init__(self, value):\n        super().__init__()\n        self.value = value\n    def __repr__(self):\n        return str(self.value)\nclass Symbol(ValueHolder):",
        "detail": "lab.lab11.editor.datamodel",
        "documentation": {}
    },
    {
        "label": "ValueHolder",
        "kind": 6,
        "importPath": "lab.lab11.editor.datamodel",
        "description": "lab.lab11.editor.datamodel",
        "peekOfCode": "class ValueHolder(Expression):\n    def __init__(self, value):\n        super().__init__()\n        self.value = value\n    def __repr__(self):\n        return str(self.value)\nclass Symbol(ValueHolder):\n    pass\nclass Number(ValueHolder):\n    def __init__(self, value, *, force_float=False):",
        "detail": "lab.lab11.editor.datamodel",
        "documentation": {}
    },
    {
        "label": "Symbol",
        "kind": 6,
        "importPath": "lab.lab11.editor.datamodel",
        "description": "lab.lab11.editor.datamodel",
        "peekOfCode": "class Symbol(ValueHolder):\n    pass\nclass Number(ValueHolder):\n    def __init__(self, value, *, force_float=False):\n        super().__init__(value)\n        if value == round(value) and not force_float:\n            self.value = round(value)\n        else:\n            self.value = value\n    def __repr__(self):",
        "detail": "lab.lab11.editor.datamodel",
        "documentation": {}
    },
    {
        "label": "Number",
        "kind": 6,
        "importPath": "lab.lab11.editor.datamodel",
        "description": "lab.lab11.editor.datamodel",
        "peekOfCode": "class Number(ValueHolder):\n    def __init__(self, value, *, force_float=False):\n        super().__init__(value)\n        if value == round(value) and not force_float:\n            self.value = round(value)\n        else:\n            self.value = value\n    def __repr__(self):\n        return super().__repr__()\nclass Pair(Expression):",
        "detail": "lab.lab11.editor.datamodel",
        "documentation": {}
    },
    {
        "label": "Pair",
        "kind": 6,
        "importPath": "lab.lab11.editor.datamodel",
        "description": "lab.lab11.editor.datamodel",
        "peekOfCode": "class Pair(Expression):\n    def __init__(self, first: Expression, rest: Expression):\n        import log\n        super().__init__()\n        self.first = first\n        if not log.logger.dotted and not isinstance(rest, (Pair, NilType, Promise)):\n            raise TypeMismatchError(\n                f\"Unable to construct a Pair with a cdr of {rest}, expected a Pair, Nil, or Promise.\")\n        self.rest = rest\n    def __repr__(self):",
        "detail": "lab.lab11.editor.datamodel",
        "documentation": {}
    },
    {
        "label": "NilType",
        "kind": 6,
        "importPath": "lab.lab11.editor.datamodel",
        "description": "lab.lab11.editor.datamodel",
        "peekOfCode": "class NilType(Expression):\n    def __repr__(self):\n        return \"()\"\nclass UndefinedType(Expression):\n    def __repr__(self):\n        from log import logger\n        if logger.strict_mode:\n            return \"\"\n        return \"undefined\"\nclass Boolean(ValueHolder):",
        "detail": "lab.lab11.editor.datamodel",
        "documentation": {}
    },
    {
        "label": "UndefinedType",
        "kind": 6,
        "importPath": "lab.lab11.editor.datamodel",
        "description": "lab.lab11.editor.datamodel",
        "peekOfCode": "class UndefinedType(Expression):\n    def __repr__(self):\n        from log import logger\n        if logger.strict_mode:\n            return \"\"\n        return \"undefined\"\nclass Boolean(ValueHolder):\n    def __repr__(self):\n        if self.value:\n            return \"#t\"",
        "detail": "lab.lab11.editor.datamodel",
        "documentation": {}
    },
    {
        "label": "Boolean",
        "kind": 6,
        "importPath": "lab.lab11.editor.datamodel",
        "description": "lab.lab11.editor.datamodel",
        "peekOfCode": "class Boolean(ValueHolder):\n    def __repr__(self):\n        if self.value:\n            return \"#t\"\n        else:\n            return \"#f\"\nclass String(ValueHolder):\n    def __init__(self, value):\n        super().__init__(value)\n    def __repr__(self):",
        "detail": "lab.lab11.editor.datamodel",
        "documentation": {}
    },
    {
        "label": "String",
        "kind": 6,
        "importPath": "lab.lab11.editor.datamodel",
        "description": "lab.lab11.editor.datamodel",
        "peekOfCode": "class String(ValueHolder):\n    def __init__(self, value):\n        super().__init__(value)\n    def __repr__(self):\n        return \"\\\"\" + self.value.replace(\"\\n\", \"\\\\n\").replace(\"\\\"\", \"\\\\\\\"\").replace(\"\\'\", \"'\") + \"\\\"\"\nclass Promise(Expression):\n    def __init__(self, expr: Expression, frame: 'Frame'):\n        super().__init__()\n        self.forced = False\n        self.force_i = None",
        "detail": "lab.lab11.editor.datamodel",
        "documentation": {}
    },
    {
        "label": "Promise",
        "kind": 6,
        "importPath": "lab.lab11.editor.datamodel",
        "description": "lab.lab11.editor.datamodel",
        "peekOfCode": "class Promise(Expression):\n    def __init__(self, expr: Expression, frame: 'Frame'):\n        super().__init__()\n        self.forced = False\n        self.force_i = None\n        self.expr = expr\n        self.frame = frame\n        self.targets = []\n        self.id = get_id()\n    def __repr__(self):",
        "detail": "lab.lab11.editor.datamodel",
        "documentation": {}
    },
    {
        "label": "SingletonTrue",
        "kind": 5,
        "importPath": "lab.lab11.editor.datamodel",
        "description": "lab.lab11.editor.datamodel",
        "peekOfCode": "SingletonTrue = Boolean(True)\nSingletonFalse = Boolean(False)\nbools = [SingletonFalse, SingletonTrue]\nNil = NilType()\nUndefined = UndefinedType()",
        "detail": "lab.lab11.editor.datamodel",
        "documentation": {}
    },
    {
        "label": "SingletonFalse",
        "kind": 5,
        "importPath": "lab.lab11.editor.datamodel",
        "description": "lab.lab11.editor.datamodel",
        "peekOfCode": "SingletonFalse = Boolean(False)\nbools = [SingletonFalse, SingletonTrue]\nNil = NilType()\nUndefined = UndefinedType()",
        "detail": "lab.lab11.editor.datamodel",
        "documentation": {}
    },
    {
        "label": "bools",
        "kind": 5,
        "importPath": "lab.lab11.editor.datamodel",
        "description": "lab.lab11.editor.datamodel",
        "peekOfCode": "bools = [SingletonFalse, SingletonTrue]\nNil = NilType()\nUndefined = UndefinedType()",
        "detail": "lab.lab11.editor.datamodel",
        "documentation": {}
    },
    {
        "label": "Nil",
        "kind": 5,
        "importPath": "lab.lab11.editor.datamodel",
        "description": "lab.lab11.editor.datamodel",
        "peekOfCode": "Nil = NilType()\nUndefined = UndefinedType()",
        "detail": "lab.lab11.editor.datamodel",
        "documentation": {}
    },
    {
        "label": "Undefined",
        "kind": 5,
        "importPath": "lab.lab11.editor.datamodel",
        "description": "lab.lab11.editor.datamodel",
        "peekOfCode": "Undefined = UndefinedType()",
        "detail": "lab.lab11.editor.datamodel",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 2,
        "importPath": "lab.lab11.editor.documentation",
        "description": "lab.lab11.editor.documentation",
        "peekOfCode": "def rank(query):\n    def fraction(source):\n        return source.count(query) / len(source)\n    def quality(elem):\n        return 20 * fraction(elem.split(\"\\n\")[0]) + fraction(elem)\n    return quality\ndef search(query):\n    with open(\"editor/scheme_documentation.md\") as f:\n        query = query.strip().lower()\n        contents = str(f.read())",
        "detail": "lab.lab11.editor.documentation",
        "documentation": {}
    },
    {
        "label": "search",
        "kind": 2,
        "importPath": "lab.lab11.editor.documentation",
        "description": "lab.lab11.editor.documentation",
        "peekOfCode": "def search(query):\n    with open(\"editor/scheme_documentation.md\") as f:\n        query = query.strip().lower()\n        contents = str(f.read())\n        contents = re.sub(r\"<a class='builtin-header' id='.*?'>\\*\\*(.*?)\\*\\*</a>\", r\"### **\\1**\", contents)\n        divider = \"##\"\n        elements = [divider + elem for elem in contents.split(divider)]\n        elements = [elem for elem in elements if \"\\n\" in elem.strip()]\n        relevant_elems = []\n        for elem in elements:",
        "detail": "lab.lab11.editor.documentation",
        "documentation": {}
    },
    {
        "label": "MathProcedure",
        "kind": 6,
        "importPath": "lab.lab11.editor.environment",
        "description": "lab.lab11.editor.environment",
        "peekOfCode": "class MathProcedure(BuiltIn):\n    def __init__(self, func, name):\n        super().__init__()\n        self.func = func\n        self.name = name\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        for operand in operands:\n            if not isinstance(operand, Number):\n                raise MathError()\n        try:",
        "detail": "lab.lab11.editor.environment",
        "documentation": {}
    },
    {
        "label": "make_frame_decorator",
        "kind": 2,
        "importPath": "lab.lab11.editor.environment",
        "description": "lab.lab11.editor.environment",
        "peekOfCode": "def make_frame_decorator(defdict):\n    def global_builtin(name):\n        def decorator(cls):\n            cls.__repr__ = lambda self: f\"#[{name}]\"\n            defdict[name] = cls\n            return cls\n        return decorator\n    return global_builtin\ndefdict = {}\nglobal_attr = make_frame_decorator(defdict)",
        "detail": "lab.lab11.editor.environment",
        "documentation": {}
    },
    {
        "label": "get_special_form",
        "kind": 2,
        "importPath": "lab.lab11.editor.environment",
        "description": "lab.lab11.editor.environment",
        "peekOfCode": "def get_special_form(name: str):\n    if name in special_forms:\n        return special_forms[name]()\n    else:\n        return None\ndef build_global_frame():\n    import primitives\n    primitives.load_primitives()\n    frame = Frame(\"builtins\")\n    for k, v in defdict.items():",
        "detail": "lab.lab11.editor.environment",
        "documentation": {}
    },
    {
        "label": "build_global_frame",
        "kind": 2,
        "importPath": "lab.lab11.editor.environment",
        "description": "lab.lab11.editor.environment",
        "peekOfCode": "def build_global_frame():\n    import primitives\n    primitives.load_primitives()\n    frame = Frame(\"builtins\")\n    for k, v in defdict.items():\n        frame.assign(Symbol(k), v())\n    # moved to the parser\n    # frame.assign(Symbol(\"nil\"), Nil)\n    # frame.assign(Symbol(\"#t\"), SingletonTrue)\n    # frame.assign(Symbol(\"#f\"), SingletonFalse)",
        "detail": "lab.lab11.editor.environment",
        "documentation": {}
    },
    {
        "label": "defdict",
        "kind": 5,
        "importPath": "lab.lab11.editor.environment",
        "description": "lab.lab11.editor.environment",
        "peekOfCode": "defdict = {}\nglobal_attr = make_frame_decorator(defdict)\nspecial_forms = {}\nspecial_form = make_frame_decorator(special_forms)\nclass MathProcedure(BuiltIn):\n    def __init__(self, func, name):\n        super().__init__()\n        self.func = func\n        self.name = name\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:",
        "detail": "lab.lab11.editor.environment",
        "documentation": {}
    },
    {
        "label": "global_attr",
        "kind": 5,
        "importPath": "lab.lab11.editor.environment",
        "description": "lab.lab11.editor.environment",
        "peekOfCode": "global_attr = make_frame_decorator(defdict)\nspecial_forms = {}\nspecial_form = make_frame_decorator(special_forms)\nclass MathProcedure(BuiltIn):\n    def __init__(self, func, name):\n        super().__init__()\n        self.func = func\n        self.name = name\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        for operand in operands:",
        "detail": "lab.lab11.editor.environment",
        "documentation": {}
    },
    {
        "label": "special_forms",
        "kind": 5,
        "importPath": "lab.lab11.editor.environment",
        "description": "lab.lab11.editor.environment",
        "peekOfCode": "special_forms = {}\nspecial_form = make_frame_decorator(special_forms)\nclass MathProcedure(BuiltIn):\n    def __init__(self, func, name):\n        super().__init__()\n        self.func = func\n        self.name = name\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        for operand in operands:\n            if not isinstance(operand, Number):",
        "detail": "lab.lab11.editor.environment",
        "documentation": {}
    },
    {
        "label": "special_form",
        "kind": 5,
        "importPath": "lab.lab11.editor.environment",
        "description": "lab.lab11.editor.environment",
        "peekOfCode": "special_form = make_frame_decorator(special_forms)\nclass MathProcedure(BuiltIn):\n    def __init__(self, func, name):\n        super().__init__()\n        self.func = func\n        self.name = name\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        for operand in operands:\n            if not isinstance(operand, Number):\n                raise MathError()",
        "detail": "lab.lab11.editor.environment",
        "documentation": {}
    },
    {
        "label": "Frame",
        "kind": 6,
        "importPath": "lab.lab11.editor.evaluate_apply",
        "description": "lab.lab11.editor.evaluate_apply",
        "peekOfCode": "class Frame:\n    def __init__(self, name: str, parent: 'Frame' = None):\n        self.parent = parent\n        self.name = name\n        self.vars: Dict[str, Expression] = {}\n        self.id = \"unknown\"\n        self.temp = log.logger.fragile\n        log.logger.frame_create(self)\n    def assign(self, varname: Symbol, varval: Expression):\n        if log.logger.fragile and not self.temp:",
        "detail": "lab.lab11.editor.evaluate_apply",
        "documentation": {}
    },
    {
        "label": "Thunk",
        "kind": 6,
        "importPath": "lab.lab11.editor.evaluate_apply",
        "description": "lab.lab11.editor.evaluate_apply",
        "peekOfCode": "class Thunk:\n    def __init__(self, expr: Expression, frame: Frame, gui_holder: log.Holder, log_stack: bool):\n        self.expr = expr\n        self.frame = frame\n        self.log_stack = log_stack\n        self.gui_holder = gui_holder\n        self.return_frame: Optional[Frame] = None\n    def __repr__(self):\n        return \"thunk\"\n    def evaluate(self, expr: Expression):",
        "detail": "lab.lab11.editor.evaluate_apply",
        "documentation": {}
    },
    {
        "label": "Callable",
        "kind": 6,
        "importPath": "lab.lab11.editor.evaluate_apply",
        "description": "lab.lab11.editor.evaluate_apply",
        "peekOfCode": "class Callable(Expression):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: log.Holder):\n        raise NotImplementedError()\nclass Applicable(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: log.Holder, eval_operands=True):\n        raise NotImplementedError()\ndef evaluate_all(operands: List[Expression], frame: Frame, operand_holders: List[log.Holder]) -> List[Expression]:\n    return [evaluate(operand, frame, holder) for operand, holder in zip(operands, operand_holders)]",
        "detail": "lab.lab11.editor.evaluate_apply",
        "documentation": {}
    },
    {
        "label": "Applicable",
        "kind": 6,
        "importPath": "lab.lab11.editor.evaluate_apply",
        "description": "lab.lab11.editor.evaluate_apply",
        "peekOfCode": "class Applicable(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: log.Holder, eval_operands=True):\n        raise NotImplementedError()\ndef evaluate_all(operands: List[Expression], frame: Frame, operand_holders: List[log.Holder]) -> List[Expression]:\n    return [evaluate(operand, frame, holder) for operand, holder in zip(operands, operand_holders)]",
        "detail": "lab.lab11.editor.evaluate_apply",
        "documentation": {}
    },
    {
        "label": "evaluate",
        "kind": 2,
        "importPath": "lab.lab11.editor.evaluate_apply",
        "description": "lab.lab11.editor.evaluate_apply",
        "peekOfCode": "def evaluate(expr: Expression, frame: Frame, gui_holder: log.Holder,\n             tail_context: bool = False, *, log_stack: bool=True) -> Union[Expression, Thunk]:\n    depth = 0\n    thunks = []\n    holders = []\n    while True:\n        if depth > RECURSION_LIMIT:\n            raise OutOfMemoryError(\"Debugger ran out of memory due to excessively deep recursion.\")\n        visual_expression = gui_holder.expression\n        if log_stack:",
        "detail": "lab.lab11.editor.evaluate_apply",
        "documentation": {}
    },
    {
        "label": "apply",
        "kind": 2,
        "importPath": "lab.lab11.editor.evaluate_apply",
        "description": "lab.lab11.editor.evaluate_apply",
        "peekOfCode": "def apply(operator: Expression, operands: List[Expression], frame: Frame, gui_holder: log.Holder):\n    if isinstance(operator, Callable):\n        return operator.execute(operands, frame, gui_holder)\n    elif isinstance(operator, Symbol):\n        raise CallableResolutionError(f\"Unable to pass parameters into the Symbol '{operator}'\")\n    else:\n        raise CallableResolutionError(f\"Unable to pass parameters into: '{operator}'\")\nclass Callable(Expression):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: log.Holder):\n        raise NotImplementedError()",
        "detail": "lab.lab11.editor.evaluate_apply",
        "documentation": {}
    },
    {
        "label": "evaluate_all",
        "kind": 2,
        "importPath": "lab.lab11.editor.evaluate_apply",
        "description": "lab.lab11.editor.evaluate_apply",
        "peekOfCode": "def evaluate_all(operands: List[Expression], frame: Frame, operand_holders: List[log.Holder]) -> List[Expression]:\n    return [evaluate(operand, frame, holder) for operand, holder in zip(operands, operand_holders)]",
        "detail": "lab.lab11.editor.evaluate_apply",
        "documentation": {}
    },
    {
        "label": "RECURSION_LIMIT",
        "kind": 5,
        "importPath": "lab.lab11.editor.evaluate_apply",
        "description": "lab.lab11.editor.evaluate_apply",
        "peekOfCode": "RECURSION_LIMIT = 100000\nclass Frame:\n    def __init__(self, name: str, parent: 'Frame' = None):\n        self.parent = parent\n        self.name = name\n        self.vars: Dict[str, Expression] = {}\n        self.id = \"unknown\"\n        self.temp = log.logger.fragile\n        log.logger.frame_create(self)\n    def assign(self, varname: Symbol, varval: Expression):",
        "detail": "lab.lab11.editor.evaluate_apply",
        "documentation": {}
    },
    {
        "label": "string_exec",
        "kind": 2,
        "importPath": "lab.lab11.editor.execution",
        "description": "lab.lab11.editor.execution",
        "peekOfCode": "def string_exec(strings, out, visualize_tail_calls, global_frame=None):\n    import log\n    empty = False\n    if global_frame is None:\n        empty = True\n        from environment import build_global_frame\n        log.logger.f_delta -= 1\n        global_frame = build_global_frame()\n        log.logger.active_frames.pop(0)  # clear builtin frame\n        log.logger.f_delta += 1",
        "detail": "lab.lab11.editor.execution",
        "documentation": {}
    },
    {
        "label": "MAX_TRACEBACK_LENGTH",
        "kind": 5,
        "importPath": "lab.lab11.editor.execution",
        "description": "lab.lab11.editor.execution",
        "peekOfCode": "MAX_TRACEBACK_LENGTH = 20\nMAX_AUTODRAW_LENGTH = 50\ndef string_exec(strings, out, visualize_tail_calls, global_frame=None):\n    import log\n    empty = False\n    if global_frame is None:\n        empty = True\n        from environment import build_global_frame\n        log.logger.f_delta -= 1\n        global_frame = build_global_frame()",
        "detail": "lab.lab11.editor.execution",
        "documentation": {}
    },
    {
        "label": "MAX_AUTODRAW_LENGTH",
        "kind": 5,
        "importPath": "lab.lab11.editor.execution",
        "description": "lab.lab11.editor.execution",
        "peekOfCode": "MAX_AUTODRAW_LENGTH = 50\ndef string_exec(strings, out, visualize_tail_calls, global_frame=None):\n    import log\n    empty = False\n    if global_frame is None:\n        empty = True\n        from environment import build_global_frame\n        log.logger.f_delta -= 1\n        global_frame = build_global_frame()\n        log.logger.active_frames.pop(0)  # clear builtin frame",
        "detail": "lab.lab11.editor.execution",
        "documentation": {}
    },
    {
        "label": "strip_comments",
        "kind": 2,
        "importPath": "lab.lab11.editor.execution_parser",
        "description": "lab.lab11.editor.execution_parser",
        "peekOfCode": "def strip_comments(code):\n    try:\n        out = \"\"\n        for string in code:\n            if not string.strip():\n                continue\n            buff = TokenBuffer([string])\n            while not buff.done:\n                out += str(get_expression(buff))\n        return out",
        "detail": "lab.lab11.editor.execution_parser",
        "documentation": {}
    },
    {
        "label": "tokenize",
        "kind": 2,
        "importPath": "lab.lab11.editor.execution_parser",
        "description": "lab.lab11.editor.execution_parser",
        "peekOfCode": "def tokenize(buffer: TokenBuffer):\n    \"\"\"\n    >>> buff = TokenBuffer([\"(1 (2 cat) (cat+dog-2 (5 6)  ) )\"])\n    >>> tokenize(buff)\n    [(1 (2 cat) (cat+dog-2 (5 6)))]\n    >>> buff = TokenBuffer([\"(1 . 2)\"])\n    >>> tokenize(buff)\n    [(1 . 2)]\n    >>> buff = TokenBuffer([\"(1 2 . 3)\"])\n    >>> tokenize(buff)",
        "detail": "lab.lab11.editor.execution_parser",
        "documentation": {}
    },
    {
        "label": "get_expression",
        "kind": 2,
        "importPath": "lab.lab11.editor.execution_parser",
        "description": "lab.lab11.editor.execution_parser",
        "peekOfCode": "def get_expression(buffer: TokenBuffer) -> Union[Expression, None]:\n    token = buffer.pop_next_token()\n    if token is None:\n        return None\n    elif token in (\"(\", \"[\"):\n        return get_rest_of_list(buffer, \")\" if token == \"(\" else \"]\")\n    elif token == \"'\":\n        return make_list([Symbol(\"quote\"), get_expression(buffer)])\n    elif token == \",\":\n        if buffer.get_next_token() == \"@\":",
        "detail": "lab.lab11.editor.execution_parser",
        "documentation": {}
    },
    {
        "label": "get_string",
        "kind": 2,
        "importPath": "lab.lab11.editor.execution_parser",
        "description": "lab.lab11.editor.execution_parser",
        "peekOfCode": "def get_string(buffer: TokenBuffer) -> String:\n    out = []\n    string = buffer.pop_next_token()\n    escaping = False\n    for char in string.value:\n        if escaping:\n            if char == \"n\":\n                out.append(\"\\n\")\n            else:\n                out.append(char)",
        "detail": "lab.lab11.editor.execution_parser",
        "documentation": {}
    },
    {
        "label": "get_rest_of_list",
        "kind": 2,
        "importPath": "lab.lab11.editor.execution_parser",
        "description": "lab.lab11.editor.execution_parser",
        "peekOfCode": "def get_rest_of_list(buffer: TokenBuffer, end_paren: str) -> Expression:\n    out = []\n    last = Nil\n    while True:\n        next = buffer.get_next_token()\n        if next == end_paren:\n            buffer.pop_next_token()\n            break\n        elif logger.dotted and next == \".\":\n            buffer.pop_next_token()",
        "detail": "lab.lab11.editor.execution_parser",
        "documentation": {}
    },
    {
        "label": "is_number",
        "kind": 2,
        "importPath": "lab.lab11.editor.execution_parser",
        "description": "lab.lab11.editor.execution_parser",
        "peekOfCode": "def is_number(token: str) -> bool:\n    try:\n        float(token)\n        return True\n    except ValueError:\n        return False\ndef is_str(token: str) -> bool:\n    return True",
        "detail": "lab.lab11.editor.execution_parser",
        "documentation": {}
    },
    {
        "label": "is_str",
        "kind": 2,
        "importPath": "lab.lab11.editor.execution_parser",
        "description": "lab.lab11.editor.execution_parser",
        "peekOfCode": "def is_str(token: str) -> bool:\n    return True",
        "detail": "lab.lab11.editor.execution_parser",
        "documentation": {}
    },
    {
        "label": "get_scm_files",
        "kind": 2,
        "importPath": "lab.lab11.editor.file_manager",
        "description": "lab.lab11.editor.file_manager",
        "peekOfCode": "def get_scm_files():\n    files = filter(lambda x: x.lower().endswith(\".scm\"), os.listdir(os.curdir))\n    return sorted(files)\ndef save(code, filename):\n    with open(filename, \"w+\") as file:\n        file.truncate(0)\n        file.seek(0)\n        file.write(\"\\n\".join(code))\n        file.flush()\ndef read_file(filename):",
        "detail": "lab.lab11.editor.file_manager",
        "documentation": {}
    },
    {
        "label": "save",
        "kind": 2,
        "importPath": "lab.lab11.editor.file_manager",
        "description": "lab.lab11.editor.file_manager",
        "peekOfCode": "def save(code, filename):\n    with open(filename, \"w+\") as file:\n        file.truncate(0)\n        file.seek(0)\n        file.write(\"\\n\".join(code))\n        file.flush()\ndef read_file(filename):\n    with open(filename, \"r\") as file:\n        return \"\".join([x for x in file])\ndef new_file(filename):",
        "detail": "lab.lab11.editor.file_manager",
        "documentation": {}
    },
    {
        "label": "read_file",
        "kind": 2,
        "importPath": "lab.lab11.editor.file_manager",
        "description": "lab.lab11.editor.file_manager",
        "peekOfCode": "def read_file(filename):\n    with open(filename, \"r\") as file:\n        return \"\".join([x for x in file])\ndef new_file(filename):\n    if filename + \".scm\" in get_scm_files():\n        return False\n    open(filename + \".scm\", \"w\")\n    return True",
        "detail": "lab.lab11.editor.file_manager",
        "documentation": {}
    },
    {
        "label": "new_file",
        "kind": 2,
        "importPath": "lab.lab11.editor.file_manager",
        "description": "lab.lab11.editor.file_manager",
        "peekOfCode": "def new_file(filename):\n    if filename + \".scm\" in get_scm_files():\n        return False\n    open(filename + \".scm\", \"w\")\n    return True",
        "detail": "lab.lab11.editor.file_manager",
        "documentation": {}
    },
    {
        "label": "OptimalFormattingReached",
        "kind": 6,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "class OptimalFormattingReached(Exception):\n    pass\nclass MatchFailure(Exception):\n    pass\nclass WeakMatchFailure(MatchFailure):\n    pass\nclass StrongMatchFailure(MatchFailure):\n    ...\nclass FormatSeq:\n    def __init__(self):",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "MatchFailure",
        "kind": 6,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "class MatchFailure(Exception):\n    pass\nclass WeakMatchFailure(MatchFailure):\n    pass\nclass StrongMatchFailure(MatchFailure):\n    ...\nclass FormatSeq:\n    def __init__(self):\n        self.left: FormatOp = None\n        self.right: FormatOp = None",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "WeakMatchFailure",
        "kind": 6,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "class WeakMatchFailure(MatchFailure):\n    pass\nclass StrongMatchFailure(MatchFailure):\n    ...\nclass FormatSeq:\n    def __init__(self):\n        self.left: FormatOp = None\n        self.right: FormatOp = None\n        self.active = True\n        self.line_lengths = [0]",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "StrongMatchFailure",
        "kind": 6,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "class StrongMatchFailure(MatchFailure):\n    ...\nclass FormatSeq:\n    def __init__(self):\n        self.left: FormatOp = None\n        self.right: FormatOp = None\n        self.active = True\n        self.line_lengths = [0]\n        self.max_line_len = 0\n        self.cost = 0",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "FormatSeq",
        "kind": 6,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "class FormatSeq:\n    def __init__(self):\n        self.left: FormatOp = None\n        self.right: FormatOp = None\n        self.active = True\n        self.line_lengths = [0]\n        self.max_line_len = 0\n        self.cost = 0\n    def __add__(self, other):\n        if other is None:",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "FormatOp",
        "kind": 6,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "class FormatOp:\n    def __init__(self):\n        self.next = None\nclass _Token(FormatOp):\n    def __init__(self, value):\n        super().__init__()\n        assert isinstance(value, str)\n        self.value = value\nclass Token(FormatSeq):\n    def __init__(self, value):",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "_Token",
        "kind": 6,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "class _Token(FormatOp):\n    def __init__(self, value):\n        super().__init__()\n        assert isinstance(value, str)\n        self.value = value\nclass Token(FormatSeq):\n    def __init__(self, value):\n        super().__init__()\n        self.left = self.right = _Token(value)\n        self.max_line_len = self.line_lengths[0] = len(value)",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "Token",
        "kind": 6,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "class Token(FormatSeq):\n    def __init__(self, value):\n        super().__init__()\n        self.left = self.right = _Token(value)\n        self.max_line_len = self.line_lengths[0] = len(value)\nclass _ChangeIndent(FormatOp):\n    def __init__(self, level):\n        super().__init__()\n        self.level = level\nclass ChangeIndent(FormatSeq):",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "_ChangeIndent",
        "kind": 6,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "class _ChangeIndent(FormatOp):\n    def __init__(self, level):\n        super().__init__()\n        self.level = level\nclass ChangeIndent(FormatSeq):\n    def __init__(self, level):\n        super().__init__()\n        self.left = self.right = _ChangeIndent(level)\nclass Newline(Token):\n    def __init__(self):",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "ChangeIndent",
        "kind": 6,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "class ChangeIndent(FormatSeq):\n    def __init__(self, level):\n        super().__init__()\n        self.left = self.right = _ChangeIndent(level)\nclass Newline(Token):\n    def __init__(self):\n        super().__init__(\"\\n\")\n        self.max_line_len = self.line_lengths[0] = 0\n        self.line_lengths.append(0)\nclass Space(Token):",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "Newline",
        "kind": 6,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "class Newline(Token):\n    def __init__(self):\n        super().__init__(\"\\n\")\n        self.max_line_len = self.line_lengths[0] = 0\n        self.line_lengths.append(0)\nclass Space(Token):\n    def __init__(self):\n        super().__init__(\" \")\nclass Formatter(ABC):\n    javastyle = False",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "Space",
        "kind": 6,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "class Space(Token):\n    def __init__(self):\n        super().__init__(\" \")\nclass Formatter(ABC):\n    javastyle = False\n    @staticmethod\n    def format(expr: Formatted, remaining: int) -> FormatSeq:\n        raise NotImplementedError()\n    @staticmethod\n    def set_javastyle(javastyle: bool):",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "Formatter",
        "kind": 6,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "class Formatter(ABC):\n    javastyle = False\n    @staticmethod\n    def format(expr: Formatted, remaining: int) -> FormatSeq:\n        raise NotImplementedError()\n    @staticmethod\n    def set_javastyle(javastyle: bool):\n        Formatter.javastyle = javastyle\nclass SpecialFormFormatter(Formatter, ABC):\n    @classmethod",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "SpecialFormFormatter",
        "kind": 6,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "class SpecialFormFormatter(Formatter, ABC):\n    @classmethod\n    def assert_form(cls, expr: Formatted, form: Union[str, List[str]]):\n        if isinstance(form, list):\n            for elem in form:\n                try:\n                    cls.assert_form(expr, elem)\n                except WeakMatchFailure:\n                    continue\n                else:",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "AlignedCondFormatter",
        "kind": 6,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "class AlignedCondFormatter(SpecialFormFormatter):\n    class Clause(Formatter):\n        @staticmethod\n        def format(expr: Formatted, remaining: int, max_pred_len: int = 0) -> FormatSeq:\n            if isinstance(expr, FormatComment):\n                return CommentFormatter.format(expr)\n            else:\n                out = Token(expr.prefix) + Token(expr.open_paren)\n                inlined_pred = InlineFormatter.format(expr.contents[0])\n                pred_len = len(expr.prefix) + inlined_pred.max_line_len",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "MultilineCondFormatter",
        "kind": 6,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "class MultilineCondFormatter(SpecialFormFormatter):\n    class Clause(Formatter):\n        @staticmethod\n        def format(expr: Formatted, remaining: int) -> FormatSeq:\n            if isinstance(expr, FormatList):\n                return NoHangingListFormatter.format(expr, remaining)\n            else:\n                return ExpressionFormatter.format(expr, remaining)\n    @classmethod\n    def format(cls, expr: Formatted, remaining) -> FormatSeq:",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "LetFormatter",
        "kind": 6,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "class LetFormatter(SpecialFormFormatter):\n    class LetHandler(Formatter):\n        def __init__(self):\n            self.bindings_next = True\n        def format(self, expr: Formatted, remaining: int) -> FormatSeq:\n            if isinstance(expr, FormatList) and self.bindings_next:\n                self.bindings_next = False\n                out = NoHangingListFormatter.format(expr, remaining)\n                out += ChangeIndent(-3)\n                return out",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "ProcedureFormatter",
        "kind": 6,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "class ProcedureFormatter(SpecialFormFormatter):\n    class ProcedureHandler(Formatter):\n        def __init__(self, indent_level):\n            self.formals_next = True\n            self.indent_level = indent_level\n        def format(self, expr: Formatted, remaining: int) -> FormatSeq:\n            out = ExpressionFormatter.format(expr, remaining)\n            if isinstance(expr, FormatList) and self.formals_next:\n                self.formals_next = False\n                out += ChangeIndent(2 - self.indent_level)",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "AtomFormatter",
        "kind": 6,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "class AtomFormatter(Formatter):\n    @staticmethod\n    def format(expr: Formatted, remaining: int = None) -> FormatSeq:\n        if not isinstance(expr, FormatAtom):\n            raise WeakMatchFailure(\"expr is not atomic\")\n        return Token(expr.prefix + expr.value)\nclass InlineFormatter(Formatter):\n    @staticmethod\n    def format(expr: Formatted, remaining: int = None) -> FormatSeq:\n        if isinstance(expr, FormatComment):",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "InlineFormatter",
        "kind": 6,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "class InlineFormatter(Formatter):\n    @staticmethod\n    def format(expr: Formatted, remaining: int = None) -> FormatSeq:\n        if isinstance(expr, FormatComment):\n            raise WeakMatchFailure(\"Cannot inline-format a comment\")\n        if isinstance(expr, FormatAtom):\n            return AtomFormatter.format(expr, remaining)\n        if SpecialFormFormatter.is_multiline(expr):\n            raise WeakMatchFailure(\"Cannot inline-format a multiline expr\")\n        formatted_exprs = [InlineFormatter.format(elem) for elem in expr.contents]",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "ListFormatter",
        "kind": 6,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "class ListFormatter(Formatter):\n    @staticmethod\n    def format(expr: Formatted, remaining: int) -> FormatSeq:\n        if not isinstance(expr, FormatList):\n            raise WeakMatchFailure(\"expr is not a list\")\n        return find_best(expr, [InlineFormatter, PrefixedListFormatter, CallExprFormatter, NoHangingListFormatter],\n                         remaining)\nclass CallExprFormatter(Formatter):\n    @staticmethod\n    def format(expr: FormatList, remaining: int) -> FormatSeq:",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "CallExprFormatter",
        "kind": 6,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "class CallExprFormatter(Formatter):\n    @staticmethod\n    def format(expr: FormatList, remaining: int) -> FormatSeq:\n        assert isinstance(expr, FormatList)\n        if len(expr.contents) <= 1:\n            raise WeakMatchFailure(\"Call expr must have at least 2 arguments, otherwise handle using DataListFormatter\")\n        if expr.prefix:\n            raise WeakMatchFailure(\"Call expr cannot be prefixed\")\n        if not isinstance(expr.contents[0], FormatAtom):\n            raise WeakMatchFailure(\"Unable to inline first two arguments, fallback to DataListFormatter\")",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "PrefixedListFormatter",
        "kind": 6,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "class PrefixedListFormatter(Formatter):\n    @staticmethod\n    def format(expr: FormatList, remaining: int):\n        assert isinstance(expr, FormatList)\n        if not expr.prefix:\n            raise WeakMatchFailure(\"Expr is not prefixed\")\n        with expr.hold_prefix() as prefix:\n            if prefix == \"`\":\n                ret = ListFormatter.format(expr, remaining - 1)\n            else:",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "DefaultCallExprFormatter",
        "kind": 6,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "class DefaultCallExprFormatter(Formatter):\n    @staticmethod\n    def format(expr: FormatList, remaining: int) -> FormatSeq:\n        operator = expr.contents[0]\n        assert isinstance(operator, FormatAtom)\n        indent_level = len(operator.value) + 2\n        out = Token(expr.open_paren)\n        out += AtomFormatter.format(operator)\n        out += ChangeIndent(indent_level) + Space()\n        out += rest_format(expr.contents[1:], remaining - indent_level,",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "DataFormatter",
        "kind": 6,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "class DataFormatter(Formatter):\n    @staticmethod\n    def format(expr: Formatted, remaining: int) -> FormatSeq:\n        if isinstance(expr, FormatComment):\n            return CommentFormatter.format(expr)\n        elif isinstance(expr, FormatAtom):\n            return AtomFormatter.format(expr)\n        else:\n            return NoHangingListFormatter.format(expr, remaining, DataFormatter)\nclass NoHangingListFormatter(Formatter):",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "NoHangingListFormatter",
        "kind": 6,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "class NoHangingListFormatter(Formatter):\n    @staticmethod\n    def format(expr: Formatted, remaining: int, callback: Type[Formatter] = None) -> FormatSeq:\n        if callback is None:\n            callback = ExpressionFormatter\n        if expr.prefix:\n            raise WeakMatchFailure(\"Cannot format prefixed datalist\")\n        out = Token(expr.open_paren) + ChangeIndent(1)\n        out += rest_format(expr.contents, remaining - 1,\n                           formatter=callback, indent_level=1, close_paren=expr.close_paren)",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "CommentFormatter",
        "kind": 6,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "class CommentFormatter(Formatter):\n    @staticmethod\n    def format(expr: Formatted, remaining: int = None) -> FormatSeq:\n        if not isinstance(expr, FormatComment):\n            raise WeakMatchFailure(\"Expr is not a comment\")\n        leading_space = \"\" if expr.value.startswith(\" \") else \" \"\n        return Token(expr.prefix + \";\" + leading_space + expr.value)\nclass ExpressionFormatter(Formatter):\n    @staticmethod\n    def format(expr: Formatted, remaining: int) -> FormatSeq:",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "ExpressionFormatter",
        "kind": 6,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "class ExpressionFormatter(Formatter):\n    @staticmethod\n    def format(expr: Formatted, remaining: int) -> FormatSeq:\n        candidates = [AtomFormatter, ListFormatter, CommentFormatter]\n        return find_best(expr, candidates, remaining)\nclass Best:\n    def __init__(self, remaining):\n        self.curr_best = None\n        self.curr_cost = None\n        self.remaining = remaining",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "Best",
        "kind": 6,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "class Best:\n    def __init__(self, remaining):\n        self.curr_best = None\n        self.curr_cost = None\n        self.remaining = remaining\n    def heuristic(self, chain: FormatSeq) -> int:\n        return max(0, chain.max_line_len - 50) + chain.cost\n    def add(self, formatted: FormatSeq):\n        cost = self.heuristic(formatted)\n        if self.curr_cost is None or cost < self.curr_cost:",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "prettify",
        "kind": 2,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "def prettify(strings: List[str], javastyle: bool = False) -> str:\n    out = []\n    for i, string in enumerate(strings):\n        if not string.strip():\n            continue\n        out.extend(prettify_single(string, javastyle))\n    raw_out = []\n    for expr in out:\n        if expr.startswith(\";\"):\n            raw_out.append(expr)",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "prettify_single",
        "kind": 2,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "def prettify_single(string: str, javastyle: bool) -> List[str]:\n    Formatter.set_javastyle(javastyle)\n    out = []\n    buff = lexer.TokenBuffer([string], True)\n    while not buff.done:\n        expr = get_expression(buff)\n        out.append(ExpressionFormatter.format(expr, LINE_LENGTH).stringify())\n    return out\nclass OptimalFormattingReached(Exception):\n    pass",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "find_best",
        "kind": 2,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "def find_best(raw: Formatted, candidates: List[Type[Formatter]], remaining) -> FormatSeq:\n    best = Best(remaining)\n    for candidate in candidates:\n        try:\n            best.add(candidate.format(raw, remaining))\n        except WeakMatchFailure as e:\n            continue\n        except StrongMatchFailure:\n            # TODO: Warn about potentially invalid special form\n            continue",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "rest_format",
        "kind": 2,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "def rest_format(exprs: List[Formatted],\n                *args,\n                formatter: Union[Formatter, Type[Formatter]] = ExpressionFormatter,\n                indent_level: int,\n                close_paren: str) -> Tuple[FormatSeq, bool]:\n    out = None\n    i = 0\n    while i != len(exprs):\n        curr_expr = exprs[i]\n        i += 1",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "LINE_LENGTH",
        "kind": 5,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "LINE_LENGTH = 50\nMAX_EXPR_COUNT = 10\nMAX_EXPR_LEN = 30\nINDENT = 4\nDEFINE_VALS = [\"define\", \"define-macro\"]\nDECLARE_VALS = [\"lambda\", \"mu\"]\nSHORTHAND = {\"quote\": \"'\", \"quasiquote\": \"`\", \"unquote\": \",\", \"unquote-splicing\": \",@\", \"variadic\": \".\"}\nMULTILINE_VALS = [\"let\", \"cond\", \"if\"]\nFREE_TOKENS = [\"if\", \"define\", \"define-macro\", \"mu\", \"lambda\"]\nOPEN_PARENS = [\"(\", \"[\"]",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "MAX_EXPR_COUNT",
        "kind": 5,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "MAX_EXPR_COUNT = 10\nMAX_EXPR_LEN = 30\nINDENT = 4\nDEFINE_VALS = [\"define\", \"define-macro\"]\nDECLARE_VALS = [\"lambda\", \"mu\"]\nSHORTHAND = {\"quote\": \"'\", \"quasiquote\": \"`\", \"unquote\": \",\", \"unquote-splicing\": \",@\", \"variadic\": \".\"}\nMULTILINE_VALS = [\"let\", \"cond\", \"if\"]\nFREE_TOKENS = [\"if\", \"define\", \"define-macro\", \"mu\", \"lambda\"]\nOPEN_PARENS = [\"(\", \"[\"]\nCLOSE_PARENS = [\")\", \"]\"]",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "MAX_EXPR_LEN",
        "kind": 5,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "MAX_EXPR_LEN = 30\nINDENT = 4\nDEFINE_VALS = [\"define\", \"define-macro\"]\nDECLARE_VALS = [\"lambda\", \"mu\"]\nSHORTHAND = {\"quote\": \"'\", \"quasiquote\": \"`\", \"unquote\": \",\", \"unquote-splicing\": \",@\", \"variadic\": \".\"}\nMULTILINE_VALS = [\"let\", \"cond\", \"if\"]\nFREE_TOKENS = [\"if\", \"define\", \"define-macro\", \"mu\", \"lambda\"]\nOPEN_PARENS = [\"(\", \"[\"]\nCLOSE_PARENS = [\")\", \"]\"]\nCACHE_SIZE = 2 ** 8",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "INDENT",
        "kind": 5,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "INDENT = 4\nDEFINE_VALS = [\"define\", \"define-macro\"]\nDECLARE_VALS = [\"lambda\", \"mu\"]\nSHORTHAND = {\"quote\": \"'\", \"quasiquote\": \"`\", \"unquote\": \",\", \"unquote-splicing\": \",@\", \"variadic\": \".\"}\nMULTILINE_VALS = [\"let\", \"cond\", \"if\"]\nFREE_TOKENS = [\"if\", \"define\", \"define-macro\", \"mu\", \"lambda\"]\nOPEN_PARENS = [\"(\", \"[\"]\nCLOSE_PARENS = [\")\", \"]\"]\nCACHE_SIZE = 2 ** 8\ndef prettify(strings: List[str], javastyle: bool = False) -> str:",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "DEFINE_VALS",
        "kind": 5,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "DEFINE_VALS = [\"define\", \"define-macro\"]\nDECLARE_VALS = [\"lambda\", \"mu\"]\nSHORTHAND = {\"quote\": \"'\", \"quasiquote\": \"`\", \"unquote\": \",\", \"unquote-splicing\": \",@\", \"variadic\": \".\"}\nMULTILINE_VALS = [\"let\", \"cond\", \"if\"]\nFREE_TOKENS = [\"if\", \"define\", \"define-macro\", \"mu\", \"lambda\"]\nOPEN_PARENS = [\"(\", \"[\"]\nCLOSE_PARENS = [\")\", \"]\"]\nCACHE_SIZE = 2 ** 8\ndef prettify(strings: List[str], javastyle: bool = False) -> str:\n    out = []",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "DECLARE_VALS",
        "kind": 5,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "DECLARE_VALS = [\"lambda\", \"mu\"]\nSHORTHAND = {\"quote\": \"'\", \"quasiquote\": \"`\", \"unquote\": \",\", \"unquote-splicing\": \",@\", \"variadic\": \".\"}\nMULTILINE_VALS = [\"let\", \"cond\", \"if\"]\nFREE_TOKENS = [\"if\", \"define\", \"define-macro\", \"mu\", \"lambda\"]\nOPEN_PARENS = [\"(\", \"[\"]\nCLOSE_PARENS = [\")\", \"]\"]\nCACHE_SIZE = 2 ** 8\ndef prettify(strings: List[str], javastyle: bool = False) -> str:\n    out = []\n    for i, string in enumerate(strings):",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "SHORTHAND",
        "kind": 5,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "SHORTHAND = {\"quote\": \"'\", \"quasiquote\": \"`\", \"unquote\": \",\", \"unquote-splicing\": \",@\", \"variadic\": \".\"}\nMULTILINE_VALS = [\"let\", \"cond\", \"if\"]\nFREE_TOKENS = [\"if\", \"define\", \"define-macro\", \"mu\", \"lambda\"]\nOPEN_PARENS = [\"(\", \"[\"]\nCLOSE_PARENS = [\")\", \"]\"]\nCACHE_SIZE = 2 ** 8\ndef prettify(strings: List[str], javastyle: bool = False) -> str:\n    out = []\n    for i, string in enumerate(strings):\n        if not string.strip():",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "MULTILINE_VALS",
        "kind": 5,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "MULTILINE_VALS = [\"let\", \"cond\", \"if\"]\nFREE_TOKENS = [\"if\", \"define\", \"define-macro\", \"mu\", \"lambda\"]\nOPEN_PARENS = [\"(\", \"[\"]\nCLOSE_PARENS = [\")\", \"]\"]\nCACHE_SIZE = 2 ** 8\ndef prettify(strings: List[str], javastyle: bool = False) -> str:\n    out = []\n    for i, string in enumerate(strings):\n        if not string.strip():\n            continue",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "FREE_TOKENS",
        "kind": 5,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "FREE_TOKENS = [\"if\", \"define\", \"define-macro\", \"mu\", \"lambda\"]\nOPEN_PARENS = [\"(\", \"[\"]\nCLOSE_PARENS = [\")\", \"]\"]\nCACHE_SIZE = 2 ** 8\ndef prettify(strings: List[str], javastyle: bool = False) -> str:\n    out = []\n    for i, string in enumerate(strings):\n        if not string.strip():\n            continue\n        out.extend(prettify_single(string, javastyle))",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "OPEN_PARENS",
        "kind": 5,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "OPEN_PARENS = [\"(\", \"[\"]\nCLOSE_PARENS = [\")\", \"]\"]\nCACHE_SIZE = 2 ** 8\ndef prettify(strings: List[str], javastyle: bool = False) -> str:\n    out = []\n    for i, string in enumerate(strings):\n        if not string.strip():\n            continue\n        out.extend(prettify_single(string, javastyle))\n    raw_out = []",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "CLOSE_PARENS",
        "kind": 5,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "CLOSE_PARENS = [\")\", \"]\"]\nCACHE_SIZE = 2 ** 8\ndef prettify(strings: List[str], javastyle: bool = False) -> str:\n    out = []\n    for i, string in enumerate(strings):\n        if not string.strip():\n            continue\n        out.extend(prettify_single(string, javastyle))\n    raw_out = []\n    for expr in out:",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "CACHE_SIZE",
        "kind": 5,
        "importPath": "lab.lab11.editor.formatter",
        "description": "lab.lab11.editor.formatter",
        "peekOfCode": "CACHE_SIZE = 2 ** 8\ndef prettify(strings: List[str], javastyle: bool = False) -> str:\n    out = []\n    for i, string in enumerate(strings):\n        if not string.strip():\n            continue\n        out.extend(prettify_single(string, javastyle))\n    raw_out = []\n    for expr in out:\n        if expr.startswith(\";\"):",
        "detail": "lab.lab11.editor.formatter",
        "documentation": {}
    },
    {
        "label": "FormatList",
        "kind": 6,
        "importPath": "lab.lab11.editor.format_parser",
        "description": "lab.lab11.editor.format_parser",
        "peekOfCode": "class FormatList:\n    def __init__(self,\n                 contents: List['Formatted'],\n                 close_paren,\n                 prefix: str=\"\"):\n        self.contents = contents\n        self.open_paren = \"(\" if close_paren == \")\" else \"[\"\n        self.close_paren = close_paren\n        self.prefix = prefix\n    class PrefixManager:",
        "detail": "lab.lab11.editor.format_parser",
        "documentation": {}
    },
    {
        "label": "FormatAtom",
        "kind": 6,
        "importPath": "lab.lab11.editor.format_parser",
        "description": "lab.lab11.editor.format_parser",
        "peekOfCode": "class FormatAtom:\n    def __init__(self, value: str):\n        self.value = value\n        self.prefix = \"\"\nclass FormatComment:\n    def __init__(self, value: str, allow_inline: bool):\n        self.value = value\n        self.prefix = \"\"\n        self.allow_inline = allow_inline\nFormatted = Union[FormatList, FormatAtom, FormatComment]",
        "detail": "lab.lab11.editor.format_parser",
        "documentation": {}
    },
    {
        "label": "FormatComment",
        "kind": 6,
        "importPath": "lab.lab11.editor.format_parser",
        "description": "lab.lab11.editor.format_parser",
        "peekOfCode": "class FormatComment:\n    def __init__(self, value: str, allow_inline: bool):\n        self.value = value\n        self.prefix = \"\"\n        self.allow_inline = allow_inline\nFormatted = Union[FormatList, FormatAtom, FormatComment]\ndef get_expression(buffer: TokenBuffer) -> Formatted:\n    token = buffer.pop_next_token()\n    if isinstance(token, Comment):\n        return FormatComment(token.value, not token.first_in_line)",
        "detail": "lab.lab11.editor.format_parser",
        "documentation": {}
    },
    {
        "label": "get_expression",
        "kind": 2,
        "importPath": "lab.lab11.editor.format_parser",
        "description": "lab.lab11.editor.format_parser",
        "peekOfCode": "def get_expression(buffer: TokenBuffer) -> Formatted:\n    token = buffer.pop_next_token()\n    if isinstance(token, Comment):\n        return FormatComment(token.value, not token.first_in_line)\n    elif token == \"#\" and not buffer.done and buffer.get_next_token() == \"[\":\n        buffer.pop_next_token()\n        out = FormatAtom(\"#[\" + buffer.pop_next_token().value + \"]\")\n        buffer.pop_next_token()\n    elif token in SPECIALS:\n        if token in (\"(\", \"[\"):",
        "detail": "lab.lab11.editor.format_parser",
        "documentation": {}
    },
    {
        "label": "get_rest_of_list",
        "kind": 2,
        "importPath": "lab.lab11.editor.format_parser",
        "description": "lab.lab11.editor.format_parser",
        "peekOfCode": "def get_rest_of_list(buffer: TokenBuffer, end_paren: str):\n    out = []\n    while buffer.get_next_token() != end_paren:\n        out.append(get_expression(buffer))\n    buffer.pop_next_token()\n    return FormatList(out, end_paren)",
        "detail": "lab.lab11.editor.format_parser",
        "documentation": {}
    },
    {
        "label": "Formatted",
        "kind": 5,
        "importPath": "lab.lab11.editor.format_parser",
        "description": "lab.lab11.editor.format_parser",
        "peekOfCode": "Formatted = Union[FormatList, FormatAtom, FormatComment]\ndef get_expression(buffer: TokenBuffer) -> Formatted:\n    token = buffer.pop_next_token()\n    if isinstance(token, Comment):\n        return FormatComment(token.value, not token.first_in_line)\n    elif token == \"#\" and not buffer.done and buffer.get_next_token() == \"[\":\n        buffer.pop_next_token()\n        out = FormatAtom(\"#[\" + buffer.pop_next_token().value + \"]\")\n        buffer.pop_next_token()\n    elif token in SPECIALS:",
        "detail": "lab.lab11.editor.format_parser",
        "documentation": {}
    },
    {
        "label": "Move",
        "kind": 6,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "class Move:\n    def __init__(self, stroke, fill):\n        self.stroke = stroke\n        self.fill = fill\n        self.seq = []\n    def export(self):\n        return {\n            \"seq\": \" \".join(self.seq),\n            \"stroke\": self.stroke,\n            \"fill\": self.fill,",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "Canvas",
        "kind": 6,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "class Canvas:\n    SIZE = 1024\n    def __init__(self):\n        self.x = None\n        self.y = None\n        self.angle = None\n        self.bg_color = None\n        self.moves: List[Move] = None\n        self.fill_move: Optional[Move] = None\n        self.pen_down = None",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "Backward",
        "kind": 6,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "class Backward(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if not isinstance(operand, Number):\n            raise OperandDeduceError(f\"Expected operand to be Number, not {operand}\")\n        log.logger.get_canvas().forward(-operand.value)\n        return Undefined\n@global_attr(\"begin_fill\")\nclass BeginFill(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 0, len(operands))",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "BeginFill",
        "kind": 6,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "class BeginFill(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 0, len(operands))\n        log.logger.get_canvas().begin_fill()\n        return Undefined\n@global_attr(\"bgcolor\")\nclass BGColor(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression):\n        log.logger.get_canvas().set_bg(make_color(operand))\n        return Undefined",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "BGColor",
        "kind": 6,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "class BGColor(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression):\n        log.logger.get_canvas().set_bg(make_color(operand))\n        return Undefined\n@global_attr(\"circle\")\nclass Circle(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_min_callable_length(self, 1, len(operands))\n        if len(operands) > 2:\n            verify_exact_callable_length(self, 2, len(operands))",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "Circle",
        "kind": 6,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "class Circle(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_min_callable_length(self, 1, len(operands))\n        if len(operands) > 2:\n            verify_exact_callable_length(self, 2, len(operands))\n        if not isinstance(operands[0], Number):\n            raise OperandDeduceError(f\"Expected radius to be Number, not {operands[0]}\")\n        if len(operands) > 2 and not isinstance(operands[1], Number):\n            raise OperandDeduceError(f\"Expected angle to be Number, not {operands[1]}\")\n        degs = 360 if len(operands) == 1 else operands[1].value",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "Clear",
        "kind": 6,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "class Clear(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 0, len(operands))\n        log.logger.get_canvas().reset()\n        return Undefined\n@global_attr(\"color\")\nclass Color(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression):\n        log.logger.get_canvas().set_color(make_color(operand))\n        return Undefined",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "Color",
        "kind": 6,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "class Color(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression):\n        log.logger.get_canvas().set_color(make_color(operand))\n        return Undefined\n@global_attr(\"end_fill\")\nclass EndFill(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 0, len(operands))\n        log.logger.get_canvas().end_fill()\n        return Undefined",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "EndFill",
        "kind": 6,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "class EndFill(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 0, len(operands))\n        log.logger.get_canvas().end_fill()\n        return Undefined\n@global_attr(\"exitonclick\")\nclass ExitOnClick(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 0, len(operands))\n        return Undefined",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "ExitOnClick",
        "kind": 6,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "class ExitOnClick(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 0, len(operands))\n        return Undefined\n@global_attr(\"forward\")\n@global_attr(\"fd\")\nclass Forward(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if not isinstance(operand, Number):\n            raise OperandDeduceError(f\"Expected operand to be Number, not {operand}\")",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "Forward",
        "kind": 6,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "class Forward(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if not isinstance(operand, Number):\n            raise OperandDeduceError(f\"Expected operand to be Number, not {operand}\")\n        log.logger.get_canvas().forward(operand.value)\n        return Undefined\n@global_attr(\"hideturtle\")\n@global_attr(\"ht\")\nclass HideTurtle(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "HideTurtle",
        "kind": 6,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "class HideTurtle(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 0, len(operands))\n        log.logger.get_canvas().hide_turtle()\n        return Undefined\n@global_attr(\"left\")\n@global_attr(\"lt\")\nclass Left(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if not isinstance(operand, Number):",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "Left",
        "kind": 6,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "class Left(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if not isinstance(operand, Number):\n            raise OperandDeduceError(f\"Expected operand to be Number, not {operand}\")\n        log.logger.get_canvas().rotate(operand.value)\n        return Undefined\n@global_attr(\"pendown\")\n@global_attr(\"pd\")\nclass PenDown(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "PenDown",
        "kind": 6,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "class PenDown(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 0, len(operands))\n        log.logger.get_canvas().pendown()\n        return Undefined\n@global_attr(\"penup\")\n@global_attr(\"pu\")\nclass PenUp(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 0, len(operands))",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "PenUp",
        "kind": 6,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "class PenUp(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 0, len(operands))\n        log.logger.get_canvas().penup()\n        return Undefined\n@global_attr(\"pixel\")\nclass Pixel(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 3, len(operands))\n        x, y, c, = operands",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "Pixel",
        "kind": 6,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "class Pixel(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 3, len(operands))\n        x, y, c, = operands\n        for v in x, y:\n            if not isinstance(v, Number):\n                raise OperandDeduceError(f\"Expected operand to be Number, not {v}\")\n        log.logger.get_canvas().pixel(x.value, y.value, make_color(c))\n        return Undefined\n@global_attr(\"pixelsize\")",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "PixelSize",
        "kind": 6,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "class PixelSize(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if not isinstance(operand, Number):\n            raise OperandDeduceError(f\"Expected operand to be Number, not {operand}\")\n        log.logger.get_canvas().set_pixel_size(operand.value)\n        return Undefined\n@global_attr(\"rgb\")\nclass RGB(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 3, len(operands))",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "RGB",
        "kind": 6,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "class RGB(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 3, len(operands))\n        for operand in operands:\n            if not isinstance(operand, Number):\n                raise OperandDeduceError(f\"Expected operand to be Number, not {operand}\")\n            if not 0 <= operand.value <= 1:\n                raise OperandDeduceError(f\"RGB values must be between 0 and 1, not {operand}\")\n        return String(\"#\" + \"\".join('{:02X}'.format(int(x.value * 255)) for x in operands))\n@global_attr(\"right\")",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "Right",
        "kind": 6,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "class Right(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if not isinstance(operand, Number):\n            raise OperandDeduceError(f\"Expected operand to be Number, not {operand}\")\n        log.logger.get_canvas().rotate(-operand.value)\n        return Undefined\n@global_attr(\"screen_width\")\n@global_attr(\"screen_height\")\nclass ScreenSize(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "ScreenSize",
        "kind": 6,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "class ScreenSize(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 0, len(operands))\n        return Number(log.logger.get_canvas().SIZE)\n@global_attr(\"setheading\")\n@global_attr(\"seth\")\nclass SetHeading(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if not isinstance(operand, Number):\n            raise OperandDeduceError(f\"Expected operand to be Number, not {operand}\")",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "SetHeading",
        "kind": 6,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "class SetHeading(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if not isinstance(operand, Number):\n            raise OperandDeduceError(f\"Expected operand to be Number, not {operand}\")\n        log.logger.get_canvas().abs_rotate(90 - operand.value)\n        return Undefined\n@global_attr(\"setposition\")\n@global_attr(\"setpos\")\n@global_attr(\"goto\")\nclass SetPosition(BuiltIn):",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "SetPosition",
        "kind": 6,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "class SetPosition(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame):\n        verify_exact_callable_length(self, 2, len(operands))\n        for operand in operands:\n            if not isinstance(operand, Number):\n                raise OperandDeduceError(f\"Expected operand to be Number, not {operand}\")\n        log.logger.get_canvas().move(operands[0].value, -operands[1].value)\n        return Undefined\n@global_attr(\"showturtle\")\n@global_attr(\"st\")",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "ShowTurtle",
        "kind": 6,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "class ShowTurtle(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 0, len(operands))\n        log.logger.get_canvas().show_turtle()\n        return Undefined\n@global_attr(\"speed\")\nclass Speed(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if not isinstance(operand, Number):\n            raise OperandDeduceError(f\"Expected operand to be Number, not {operand}\")",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "Speed",
        "kind": 6,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "class Speed(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if not isinstance(operand, Number):\n            raise OperandDeduceError(f\"Expected operand to be Number, not {operand}\")\n        return Undefined",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "make_action",
        "kind": 2,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "def make_action(command: str, *params: float) -> str:\n    return command + \" \" + \" \".join(str(param) for param in params)\ndef graphics_fragile(func):\n    def out(*args, **kwargs):\n        if log.logger.fragile:\n            raise IrreversibleOperationError()\n        return func(*args, **kwargs)\n    return out\nclass Move:\n    def __init__(self, stroke, fill):",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "graphics_fragile",
        "kind": 2,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "def graphics_fragile(func):\n    def out(*args, **kwargs):\n        if log.logger.fragile:\n            raise IrreversibleOperationError()\n        return func(*args, **kwargs)\n    return out\nclass Move:\n    def __init__(self, stroke, fill):\n        self.stroke = stroke\n        self.fill = fill",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "make_color",
        "kind": 2,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "def make_color(expression: Expression) -> str:\n    if not isinstance(expression, String) and not isinstance(expression, Symbol):\n        raise OperandDeduceError(f\"Expected a String or Symbol, received {expression}.\")\n    color = expression.value.lower()\n    # regex from https://stackoverflow.com/questions/30241375/python-how-to-check-if-string-is-a-hex-color-code\n    if color not in COLORS and not re.search(r'^#(?:[0-9a-fA-F]{3}){1,2}$', color):\n        raise OperandDeduceError(f\"Expected a valid CSS or hex color code, received {expression}.\")\n    return color\n@global_attr(\"backward\")\n@global_attr(\"back\")",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "ABSOLUTE_MOVE",
        "kind": 5,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "ABSOLUTE_MOVE = \"M\"\nRELATIVE_MOVE = \"m\"\nABSOLUTE_LINE = \"L\"\nRELATIVE_LINE = \"l\"\nCOMPLETE_PATH = \"Z\"\nABSOLUTE_ARC = \"A\"\nRELATIVE_ARC = \"a\"\ndef make_action(command: str, *params: float) -> str:\n    return command + \" \" + \" \".join(str(param) for param in params)\ndef graphics_fragile(func):",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "RELATIVE_MOVE",
        "kind": 5,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "RELATIVE_MOVE = \"m\"\nABSOLUTE_LINE = \"L\"\nRELATIVE_LINE = \"l\"\nCOMPLETE_PATH = \"Z\"\nABSOLUTE_ARC = \"A\"\nRELATIVE_ARC = \"a\"\ndef make_action(command: str, *params: float) -> str:\n    return command + \" \" + \" \".join(str(param) for param in params)\ndef graphics_fragile(func):\n    def out(*args, **kwargs):",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "ABSOLUTE_LINE",
        "kind": 5,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "ABSOLUTE_LINE = \"L\"\nRELATIVE_LINE = \"l\"\nCOMPLETE_PATH = \"Z\"\nABSOLUTE_ARC = \"A\"\nRELATIVE_ARC = \"a\"\ndef make_action(command: str, *params: float) -> str:\n    return command + \" \" + \" \".join(str(param) for param in params)\ndef graphics_fragile(func):\n    def out(*args, **kwargs):\n        if log.logger.fragile:",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "RELATIVE_LINE",
        "kind": 5,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "RELATIVE_LINE = \"l\"\nCOMPLETE_PATH = \"Z\"\nABSOLUTE_ARC = \"A\"\nRELATIVE_ARC = \"a\"\ndef make_action(command: str, *params: float) -> str:\n    return command + \" \" + \" \".join(str(param) for param in params)\ndef graphics_fragile(func):\n    def out(*args, **kwargs):\n        if log.logger.fragile:\n            raise IrreversibleOperationError()",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "COMPLETE_PATH",
        "kind": 5,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "COMPLETE_PATH = \"Z\"\nABSOLUTE_ARC = \"A\"\nRELATIVE_ARC = \"a\"\ndef make_action(command: str, *params: float) -> str:\n    return command + \" \" + \" \".join(str(param) for param in params)\ndef graphics_fragile(func):\n    def out(*args, **kwargs):\n        if log.logger.fragile:\n            raise IrreversibleOperationError()\n        return func(*args, **kwargs)",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "ABSOLUTE_ARC",
        "kind": 5,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "ABSOLUTE_ARC = \"A\"\nRELATIVE_ARC = \"a\"\ndef make_action(command: str, *params: float) -> str:\n    return command + \" \" + \" \".join(str(param) for param in params)\ndef graphics_fragile(func):\n    def out(*args, **kwargs):\n        if log.logger.fragile:\n            raise IrreversibleOperationError()\n        return func(*args, **kwargs)\n    return out",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "RELATIVE_ARC",
        "kind": 5,
        "importPath": "lab.lab11.editor.graphics",
        "description": "lab.lab11.editor.graphics",
        "peekOfCode": "RELATIVE_ARC = \"a\"\ndef make_action(command: str, *params: float) -> str:\n    return command + \" \" + \" \".join(str(param) for param in params)\ndef graphics_fragile(func):\n    def out(*args, **kwargs):\n        if log.logger.fragile:\n            raise IrreversibleOperationError()\n        return func(*args, **kwargs)\n    return out\nclass Move:",
        "detail": "lab.lab11.editor.graphics",
        "documentation": {}
    },
    {
        "label": "pair_to_list",
        "kind": 2,
        "importPath": "lab.lab11.editor.helper",
        "description": "lab.lab11.editor.helper",
        "peekOfCode": "def pair_to_list(pos: Pair) -> List[Expression]:\n    out = []\n    while pos is not Nil:\n        if not isinstance(pos, Pair):\n            raise OperandDeduceError(f\"List terminated with '{pos}', not nil\")\n        out.append(pos.first)\n        pos = pos.rest\n    return out\ndef dotted_pair_to_list(pos: Expression) -> Tuple[List[Expression], Optional[Expression]]:\n    out = []",
        "detail": "lab.lab11.editor.helper",
        "documentation": {}
    },
    {
        "label": "dotted_pair_to_list",
        "kind": 2,
        "importPath": "lab.lab11.editor.helper",
        "description": "lab.lab11.editor.helper",
        "peekOfCode": "def dotted_pair_to_list(pos: Expression) -> Tuple[List[Expression], Optional[Expression]]:\n    out = []\n    vararg = None\n    while pos is not Nil:\n        if not isinstance(pos, Pair):\n            vararg = pos\n            break\n        out.append(pos.first)\n        pos = pos.rest\n    return out, vararg",
        "detail": "lab.lab11.editor.helper",
        "documentation": {}
    },
    {
        "label": "assert_all_numbers",
        "kind": 2,
        "importPath": "lab.lab11.editor.helper",
        "description": "lab.lab11.editor.helper",
        "peekOfCode": "def assert_all_numbers(operands):\n    for operand in operands:\n        if not isinstance(operand, Number):\n            raise MathError(f\"Unable to perform arithmetic, as {operand} is not a number.\")\ndef verify_exact_callable_length(operator: Expression, expected: int, actual: int):\n    if expected != actual:\n        raise CallableResolutionError(f\"{operator} expected {expected} operands, received {actual}.\")\ndef verify_min_callable_length(operator: Expression, expected: int, actual: int):\n    if expected > actual:\n        raise CallableResolutionError(f\"{operator} expected at least {expected} operands, received {actual}.\")",
        "detail": "lab.lab11.editor.helper",
        "documentation": {}
    },
    {
        "label": "verify_exact_callable_length",
        "kind": 2,
        "importPath": "lab.lab11.editor.helper",
        "description": "lab.lab11.editor.helper",
        "peekOfCode": "def verify_exact_callable_length(operator: Expression, expected: int, actual: int):\n    if expected != actual:\n        raise CallableResolutionError(f\"{operator} expected {expected} operands, received {actual}.\")\ndef verify_min_callable_length(operator: Expression, expected: int, actual: int):\n    if expected > actual:\n        raise CallableResolutionError(f\"{operator} expected at least {expected} operands, received {actual}.\")\ndef make_list(exprs: List[Expression], last: Expression = Nil) -> Union[Pair, NilType]:\n    out = last\n    for expr in reversed(exprs):\n        out = Pair(expr, out)",
        "detail": "lab.lab11.editor.helper",
        "documentation": {}
    },
    {
        "label": "verify_min_callable_length",
        "kind": 2,
        "importPath": "lab.lab11.editor.helper",
        "description": "lab.lab11.editor.helper",
        "peekOfCode": "def verify_min_callable_length(operator: Expression, expected: int, actual: int):\n    if expected > actual:\n        raise CallableResolutionError(f\"{operator} expected at least {expected} operands, received {actual}.\")\ndef make_list(exprs: List[Expression], last: Expression = Nil) -> Union[Pair, NilType]:\n    out = last\n    for expr in reversed(exprs):\n        out = Pair(expr, out)\n    return out",
        "detail": "lab.lab11.editor.helper",
        "documentation": {}
    },
    {
        "label": "make_list",
        "kind": 2,
        "importPath": "lab.lab11.editor.helper",
        "description": "lab.lab11.editor.helper",
        "peekOfCode": "def make_list(exprs: List[Expression], last: Expression = Nil) -> Union[Pair, NilType]:\n    out = last\n    for expr in reversed(exprs):\n        out = Pair(expr, out)\n    return out",
        "detail": "lab.lab11.editor.helper",
        "documentation": {}
    },
    {
        "label": "Token",
        "kind": 6,
        "importPath": "lab.lab11.editor.lexer",
        "description": "lab.lab11.editor.lexer",
        "peekOfCode": "class Token:\n    def __init__(self, value: str):\n        self.value = value\n    def __eq__(self, other):\n        return other == self.value\n    def __hash__(self):\n        return hash(self.value)\n    def __repr__(self):\n        return repr(self.value)\n    def __str__(self):",
        "detail": "lab.lab11.editor.lexer",
        "documentation": {}
    },
    {
        "label": "Comment",
        "kind": 6,
        "importPath": "lab.lab11.editor.lexer",
        "description": "lab.lab11.editor.lexer",
        "peekOfCode": "class Comment(Token):\n    def __init__(self, value: str, first_in_line: bool):\n        super().__init__(value)\n        self.first_in_line = first_in_line\nclass TokenBuffer:\n    def __init__(self, lines, do_comments=False, ignore_brackets=False):\n        self.string = \"\\n\".join(lines)\n        self.tokens = tokenize(self.string, do_comments, ignore_brackets)\n        self.done = not self.tokens\n        self.i = 0",
        "detail": "lab.lab11.editor.lexer",
        "documentation": {}
    },
    {
        "label": "TokenBuffer",
        "kind": 6,
        "importPath": "lab.lab11.editor.lexer",
        "description": "lab.lab11.editor.lexer",
        "peekOfCode": "class TokenBuffer:\n    def __init__(self, lines, do_comments=False, ignore_brackets=False):\n        self.string = \"\\n\".join(lines)\n        self.tokens = tokenize(self.string, do_comments, ignore_brackets)\n        self.done = not self.tokens\n        self.i = 0\n    def get_next_token(self) -> Token:\n        if self.done:\n            raise ParseError(\"Incomplete expression, probably due to unmatched parentheses.\")\n        return self.tokens[self.i]",
        "detail": "lab.lab11.editor.lexer",
        "documentation": {}
    },
    {
        "label": "tokenize",
        "kind": 2,
        "importPath": "lab.lab11.editor.lexer",
        "description": "lab.lab11.editor.lexer",
        "peekOfCode": "def tokenize(string, do_comments, ignore_brackets) -> List[Token]:\n    string = string.strip()\n    tokens = []\n    i = 0\n    first_in_line = True\n    def _get_token():\n        \"\"\"Always starts at a non-space character\"\"\"\n        nonlocal i\n        if i == len(string):\n            return",
        "detail": "lab.lab11.editor.lexer",
        "documentation": {}
    },
    {
        "label": "SPECIALS",
        "kind": 5,
        "importPath": "lab.lab11.editor.lexer",
        "description": "lab.lab11.editor.lexer",
        "peekOfCode": "SPECIALS = [\"(\", \")\", \"[\", \"]\", \"'\", \"`\", \",\", \"@\", \"\\\"\", \";\"]\nclass Token:\n    def __init__(self, value: str):\n        self.value = value\n    def __eq__(self, other):\n        return other == self.value\n    def __hash__(self):\n        return hash(self.value)\n    def __repr__(self):\n        return repr(self.value)",
        "detail": "lab.lab11.editor.lexer",
        "documentation": {}
    },
    {
        "label": "Append",
        "kind": 6,
        "importPath": "lab.lab11.editor.lists",
        "description": "lab.lab11.editor.lists",
        "peekOfCode": "class Append(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        if len(operands) == 0:\n            return Nil\n        exprs = []\n        for operand in operands[:-1]:\n            if not isinstance(operand, Pair) and operand is not Nil:\n                raise OperandDeduceError(f\"Expected operand to be valid list, not {operand}\")\n            exprs.extend(pair_to_list(operand))\n        out = operands[-1]",
        "detail": "lab.lab11.editor.lists",
        "documentation": {}
    },
    {
        "label": "Car",
        "kind": 6,
        "importPath": "lab.lab11.editor.lists",
        "description": "lab.lab11.editor.lists",
        "peekOfCode": "class Car(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if isinstance(operand, Pair):\n            return operand.first\n        else:\n            raise OperandDeduceError(f\"Unable to extract first element, as {operand} is not a Pair.\")\n@global_attr(\"cdr\")\nclass Cdr(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if isinstance(operand, Pair):",
        "detail": "lab.lab11.editor.lists",
        "documentation": {}
    },
    {
        "label": "Cdr",
        "kind": 6,
        "importPath": "lab.lab11.editor.lists",
        "description": "lab.lab11.editor.lists",
        "peekOfCode": "class Cdr(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if isinstance(operand, Pair):\n            return operand.rest\n        else:\n            raise OperandDeduceError(f\"Unable to extract second element, as {operand} is not a Pair.\")\n@global_attr(\"cons\")\nclass Cons(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))",
        "detail": "lab.lab11.editor.lists",
        "documentation": {}
    },
    {
        "label": "Cons",
        "kind": 6,
        "importPath": "lab.lab11.editor.lists",
        "description": "lab.lab11.editor.lists",
        "peekOfCode": "class Cons(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        return Pair(operands[0], operands[1])\n@global_attr(\"length\")\nclass Length(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if not isinstance(operand, Pair) and operand is not Nil:\n            raise OperandDeduceError(f\"Unable to calculate length, as {operand} is not a valid list.\")\n        return Number(len(pair_to_list(operand)))",
        "detail": "lab.lab11.editor.lists",
        "documentation": {}
    },
    {
        "label": "Length",
        "kind": 6,
        "importPath": "lab.lab11.editor.lists",
        "description": "lab.lab11.editor.lists",
        "peekOfCode": "class Length(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if not isinstance(operand, Pair) and operand is not Nil:\n            raise OperandDeduceError(f\"Unable to calculate length, as {operand} is not a valid list.\")\n        return Number(len(pair_to_list(operand)))\n# @global_attr(\"map\")\n# class Map(BuiltIn):\n#     def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n#         verify_exact_callable_length(self, 2, len(operands))\n#",
        "detail": "lab.lab11.editor.lists",
        "documentation": {}
    },
    {
        "label": "MakeList",
        "kind": 6,
        "importPath": "lab.lab11.editor.lists",
        "description": "lab.lab11.editor.lists",
        "peekOfCode": "class MakeList(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        return make_list(operands)\n@global_attr(\"set-car!\")\nclass SetCar(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        if log.logger.fragile:\n            raise IrreversibleOperationError()\n        pair, val = operands",
        "detail": "lab.lab11.editor.lists",
        "documentation": {}
    },
    {
        "label": "SetCar",
        "kind": 6,
        "importPath": "lab.lab11.editor.lists",
        "description": "lab.lab11.editor.lists",
        "peekOfCode": "class SetCar(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 2, len(operands))\n        if log.logger.fragile:\n            raise IrreversibleOperationError()\n        pair, val = operands\n        if not isinstance(pair, Pair):\n            raise OperandDeduceError(f\"set-car! expected a Pair, received {pair}.\")\n        pair.first = val\n        log.logger.raw_out(\"WARNING: Mutation operations on pairs are not yet supported by the debugger.\")",
        "detail": "lab.lab11.editor.lists",
        "documentation": {}
    },
    {
        "label": "SetCdr",
        "kind": 6,
        "importPath": "lab.lab11.editor.lists",
        "description": "lab.lab11.editor.lists",
        "peekOfCode": "class SetCdr(BuiltIn):\n        def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n            verify_exact_callable_length(self, 2, len(operands))\n            if log.logger.fragile:\n                raise IrreversibleOperationError()\n            pair, val = operands\n            if not isinstance(pair, Pair):\n                raise OperandDeduceError(f\"set-cdr! expected a Pair, received {pair}.\")\n            if not isinstance(val, (Pair, Promise, NilType)):\n                raise OperandDeduceError(f\"Unable to assign {val} to cdr, expected a Pair, Nil, or Promise.\")",
        "detail": "lab.lab11.editor.lists",
        "documentation": {}
    },
    {
        "label": "Handler",
        "kind": 6,
        "importPath": "lab.lab11.editor.local_server",
        "description": "lab.lab11.editor.local_server",
        "peekOfCode": "class Handler(server.BaseHTTPRequestHandler):\n    cancellation_event = threading.Event()  # Shared across all instances, because the threading mixin creates a new instance every time...\n    def do_POST(self):\n        content_length = int(self.headers['Content-Length'])\n        raw_data = self.rfile.read(content_length)\n        data = urllib.parse.parse_qs(raw_data.decode(\"ascii\"))\n        path = urllib.parse.unquote(self.path)\n        result = self.handle_post_thread(data, path)\n        return result\n    def handle_post_thread(self, data, path):",
        "detail": "lab.lab11.editor.local_server",
        "documentation": {}
    },
    {
        "label": "ThreadedHTTPServer",
        "kind": 6,
        "importPath": "lab.lab11.editor.local_server",
        "description": "lab.lab11.editor.local_server",
        "peekOfCode": "class ThreadedHTTPServer(socketserver.ThreadingMixIn, server.HTTPServer):\n    daemon_threads = True\ndef start(file_args, port, open_browser):\n    global main_files\n    main_files = file_args\n    global PORT\n    PORT = port\n    socketserver.TCPServer.allow_reuse_address = True\n    e = None\n    for port in range(PORT, PORT + 10):",
        "detail": "lab.lab11.editor.local_server",
        "documentation": {}
    },
    {
        "label": "merge",
        "kind": 2,
        "importPath": "lab.lab11.editor.local_server",
        "description": "lab.lab11.editor.local_server",
        "peekOfCode": "def merge(states, new_states):\n    for i, new_state in enumerate(new_states):\n        if i == len(states):\n            states.append(new_state)\n        else:\n            for key, val in new_state.items():\n                states[i][key] = val\ndef cancelable_subprocess_call(cancellation_event, *args, **kwargs):\n    buffered = io.BytesIO()\n    with subprocess.Popen(*args, **kwargs) as proc:",
        "detail": "lab.lab11.editor.local_server",
        "documentation": {}
    },
    {
        "label": "cancelable_subprocess_call",
        "kind": 2,
        "importPath": "lab.lab11.editor.local_server",
        "description": "lab.lab11.editor.local_server",
        "peekOfCode": "def cancelable_subprocess_call(cancellation_event, *args, **kwargs):\n    buffered = io.BytesIO()\n    with subprocess.Popen(*args, **kwargs) as proc:\n        proc.stdin.close()\n        def pipeline(source, *sinks):  # We need this extra thread because there's no cross-platform way to poll a process's stdout\n            while True:\n                s = source.readline()\n                if not s: break\n                for sink in sinks:\n                    sink.write(s)",
        "detail": "lab.lab11.editor.local_server",
        "documentation": {}
    },
    {
        "label": "handle",
        "kind": 2,
        "importPath": "lab.lab11.editor.local_server",
        "description": "lab.lab11.editor.local_server",
        "peekOfCode": "def handle(code, curr_i, curr_f, global_frame_id, visualize_tail_calls, cancellation_event):\n    try:\n        global_frame = log.logger.frame_lookup.get(global_frame_id, None)\n        log.logger.new_query(global_frame, curr_i, curr_f)\n        scheme_limiter(cancellation_event,\n                       execution.string_exec,\n                       code, log.logger.out,\n                       visualize_tail_calls,\n                       global_frame.base if global_frame_id != -1 else None)\n    except OperationCanceledException:",
        "detail": "lab.lab11.editor.local_server",
        "documentation": {}
    },
    {
        "label": "instant",
        "kind": 2,
        "importPath": "lab.lab11.editor.local_server",
        "description": "lab.lab11.editor.local_server",
        "peekOfCode": "def instant(code, global_frame_id):\n    global_frame = log.logger.frame_lookup[global_frame_id]\n    log.logger.new_query(global_frame)\n    try:\n        log.logger.preview_mode(True)\n        scheme_limiter(0.3, execution.string_exec, code, log.logger.out, False, global_frame.base)\n    except (SchemeError, ZeroDivisionError) as e:\n        log.logger.out(e)\n    except TimeLimitException:\n        pass",
        "detail": "lab.lab11.editor.local_server",
        "documentation": {}
    },
    {
        "label": "supports_color",
        "kind": 2,
        "importPath": "lab.lab11.editor.local_server",
        "description": "lab.lab11.editor.local_server",
        "peekOfCode": "def supports_color():\n    \"\"\"\n    Returns True if the running system's terminal supports color, and False\n    otherwise.\n    \"\"\"\n    plat = sys.platform\n    supported_platform = plat != 'Pocket PC' and (plat != 'win32' or\n                                                  'ANSICON' in os.environ)\n    # isatty is not always implemented, #6223.\n    is_a_tty = hasattr(sys.stdout, 'isatty') and sys.stdout.isatty()",
        "detail": "lab.lab11.editor.local_server",
        "documentation": {}
    },
    {
        "label": "start",
        "kind": 2,
        "importPath": "lab.lab11.editor.local_server",
        "description": "lab.lab11.editor.local_server",
        "peekOfCode": "def start(file_args, port, open_browser):\n    global main_files\n    main_files = file_args\n    global PORT\n    PORT = port\n    socketserver.TCPServer.allow_reuse_address = True\n    e = None\n    for port in range(PORT, PORT + 10):\n        request = Request(f\"http://127.0.0.1:{port}/kill\", method='POST')\n        try:",
        "detail": "lab.lab11.editor.local_server",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": "lab.lab11.editor.local_server",
        "description": "lab.lab11.editor.local_server",
        "peekOfCode": "PORT = 8012\nmain_files = []\nstate = {}\nclass Handler(server.BaseHTTPRequestHandler):\n    cancellation_event = threading.Event()  # Shared across all instances, because the threading mixin creates a new instance every time...\n    def do_POST(self):\n        content_length = int(self.headers['Content-Length'])\n        raw_data = self.rfile.read(content_length)\n        data = urllib.parse.parse_qs(raw_data.decode(\"ascii\"))\n        path = urllib.parse.unquote(self.path)",
        "detail": "lab.lab11.editor.local_server",
        "documentation": {}
    },
    {
        "label": "main_files",
        "kind": 5,
        "importPath": "lab.lab11.editor.local_server",
        "description": "lab.lab11.editor.local_server",
        "peekOfCode": "main_files = []\nstate = {}\nclass Handler(server.BaseHTTPRequestHandler):\n    cancellation_event = threading.Event()  # Shared across all instances, because the threading mixin creates a new instance every time...\n    def do_POST(self):\n        content_length = int(self.headers['Content-Length'])\n        raw_data = self.rfile.read(content_length)\n        data = urllib.parse.parse_qs(raw_data.decode(\"ascii\"))\n        path = urllib.parse.unquote(self.path)\n        result = self.handle_post_thread(data, path)",
        "detail": "lab.lab11.editor.local_server",
        "documentation": {}
    },
    {
        "label": "state",
        "kind": 5,
        "importPath": "lab.lab11.editor.local_server",
        "description": "lab.lab11.editor.local_server",
        "peekOfCode": "state = {}\nclass Handler(server.BaseHTTPRequestHandler):\n    cancellation_event = threading.Event()  # Shared across all instances, because the threading mixin creates a new instance every time...\n    def do_POST(self):\n        content_length = int(self.headers['Content-Length'])\n        raw_data = self.rfile.read(content_length)\n        data = urllib.parse.parse_qs(raw_data.decode(\"ascii\"))\n        path = urllib.parse.unquote(self.path)\n        result = self.handle_post_thread(data, path)\n        return result",
        "detail": "lab.lab11.editor.local_server",
        "documentation": {}
    },
    {
        "label": "HolderState",
        "kind": 6,
        "importPath": "lab.lab11.editor.log",
        "description": "lab.lab11.editor.log",
        "peekOfCode": "class HolderState(Enum):\n    UNEVALUATED = 1\n    EVALUATING = 2\n    EVALUATED = 3\n    APPLYING = 4\nclass FakeObj:\n    def __getattr__(self, item):\n        return fake_obj\n    def __getitem__(self, item):\n        return fake_obj",
        "detail": "lab.lab11.editor.log",
        "documentation": {}
    },
    {
        "label": "FakeObj",
        "kind": 6,
        "importPath": "lab.lab11.editor.log",
        "description": "lab.lab11.editor.log",
        "peekOfCode": "class FakeObj:\n    def __getattr__(self, item):\n        return fake_obj\n    def __getitem__(self, item):\n        return fake_obj\n    def __call__(self, *args, **kwargs):\n        return fake_obj\nfake_obj = FakeObj()\nclass VisualExpression:\n    def __init__(self, base_expr: Expression = None, true_base_expr: Expression = None):",
        "detail": "lab.lab11.editor.log",
        "documentation": {}
    },
    {
        "label": "VisualExpression",
        "kind": 6,
        "importPath": "lab.lab11.editor.log",
        "description": "lab.lab11.editor.log",
        "peekOfCode": "class VisualExpression:\n    def __init__(self, base_expr: Expression = None, true_base_expr: Expression = None):\n        self.display_value = base_expr\n        self.base_expr = base_expr if true_base_expr is None else true_base_expr\n        self.value: Expression = None\n        self.children: List[Holder] = []\n        self.id = get_id()\n        if logger.op_count >= OP_LIMIT:\n            self.children = fake_obj\n            return",
        "detail": "lab.lab11.editor.log",
        "documentation": {}
    },
    {
        "label": "Holder",
        "kind": 6,
        "importPath": "lab.lab11.editor.log",
        "description": "lab.lab11.editor.log",
        "peekOfCode": "class Holder:\n    def __init__(self, expr: Expression, parent: VisualExpression):\n        self.expression: VisualExpression = VisualExpression(expr) if isinstance(expr, Expression) else expr\n        self.state = HolderState.UNEVALUATED\n        self.parent = parent\n    def evaluate(self):\n        self.state = HolderState.EVALUATING\n        announce(\"Evaluating\", self, Root.root)\n    def apply(self):\n        self.state = HolderState.APPLYING",
        "detail": "lab.lab11.editor.log",
        "documentation": {}
    },
    {
        "label": "Root",
        "kind": 6,
        "importPath": "lab.lab11.editor.log",
        "description": "lab.lab11.editor.log",
        "peekOfCode": "class Root:\n    root: Holder\n    set: bool = False\n    @classmethod\n    def setroot(cls, root: Holder):\n        cls.root = root\ndef limited(f):\n    def g(*args, **kwargs):\n        if not logger.log_op() and not kwargs.get(\"force\", False):\n            return",
        "detail": "lab.lab11.editor.log",
        "documentation": {}
    },
    {
        "label": "Logger",
        "kind": 6,
        "importPath": "lab.lab11.editor.log",
        "description": "lab.lab11.editor.log",
        "peekOfCode": "class Logger:\n    def __init__(self):\n        self._out = [[]]  # text printed to console\n        self.i = 0  # number of \"steps\" in the substitution tree\n        self.start = 0  # the step of the current expr\n        self.f_delta = 0  # the index of the first frame to generate\n        self.frame_lookup: Dict[int, StoredFrame] = {}  # lookup of all previous frames TODO: use weakrefs or something\n        self.active_frames: List[StoredFrame] = []  # new frames to be added to the js frame store\n        self.frame_updates = []  # when the env diagram is updated\n        self.global_frame: StoredFrame = None",
        "detail": "lab.lab11.editor.log",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "lab.lab11.editor.log",
        "description": "lab.lab11.editor.log",
        "peekOfCode": "class Node:\n    def __init__(self, expr: VisualExpression, transition_type: HolderState):\n        self.transitions = []\n        self.str = []\n        self.base_str = []\n        self.children = []\n        self.id = expr.id\n        self.modify(expr, transition_type)\n    @limited\n    def modify(self, expr: VisualExpression, transition_type: HolderState):",
        "detail": "lab.lab11.editor.log",
        "documentation": {}
    },
    {
        "label": "StoredFrame",
        "kind": 6,
        "importPath": "lab.lab11.editor.log",
        "description": "lab.lab11.editor.log",
        "peekOfCode": "class StoredFrame:\n    def __init__(self, i, base: 'evaluate_apply.Frame'):\n        i += logger.f_delta\n        if i == -1:\n            name = \"Builtins\"\n        elif i == 0:\n            name = \"Global\"\n        else:\n            name = f\"f{i}\"\n        self.name = name",
        "detail": "lab.lab11.editor.log",
        "documentation": {}
    },
    {
        "label": "Heap",
        "kind": 6,
        "importPath": "lab.lab11.editor.log",
        "description": "lab.lab11.editor.log",
        "peekOfCode": "class Heap:\n    HeapKey = Tuple[bool, Union[int, str]]  # the bool means that I'm NOT a pointer!\n    HeapObject = Union[List['HeapObject'], HeapKey]\n    def __init__(self):\n        self.prev: Dict[str, Heap.HeapObject] = {}\n        self.curr: Dict[str, Heap.HeapObject] = {}\n    def export(self):\n        out = self.curr\n        self.prev.update(self.curr)\n        self.curr = {}",
        "detail": "lab.lab11.editor.log",
        "documentation": {}
    },
    {
        "label": "limited",
        "kind": 2,
        "importPath": "lab.lab11.editor.log",
        "description": "lab.lab11.editor.log",
        "peekOfCode": "def limited(f):\n    def g(*args, **kwargs):\n        if not logger.log_op() and not kwargs.get(\"force\", False):\n            return\n        if \"force\" in kwargs:\n            del kwargs[\"force\"]\n        return f(*args, **kwargs)\n    return g\nclass Logger:\n    def __init__(self):",
        "detail": "lab.lab11.editor.log",
        "documentation": {}
    },
    {
        "label": "OP_LIMIT",
        "kind": 5,
        "importPath": "lab.lab11.editor.log",
        "description": "lab.lab11.editor.log",
        "peekOfCode": "OP_LIMIT = 25000\nclass HolderState(Enum):\n    UNEVALUATED = 1\n    EVALUATING = 2\n    EVALUATED = 3\n    APPLYING = 4\nclass FakeObj:\n    def __getattr__(self, item):\n        return fake_obj\n    def __getitem__(self, item):",
        "detail": "lab.lab11.editor.log",
        "documentation": {}
    },
    {
        "label": "fake_obj",
        "kind": 5,
        "importPath": "lab.lab11.editor.log",
        "description": "lab.lab11.editor.log",
        "peekOfCode": "fake_obj = FakeObj()\nclass VisualExpression:\n    def __init__(self, base_expr: Expression = None, true_base_expr: Expression = None):\n        self.display_value = base_expr\n        self.base_expr = base_expr if true_base_expr is None else true_base_expr\n        self.value: Expression = None\n        self.children: List[Holder] = []\n        self.id = get_id()\n        if logger.op_count >= OP_LIMIT:\n            self.children = fake_obj",
        "detail": "lab.lab11.editor.log",
        "documentation": {}
    },
    {
        "label": "return_symbol",
        "kind": 5,
        "importPath": "lab.lab11.editor.log",
        "description": "lab.lab11.editor.log",
        "peekOfCode": "return_symbol = Symbol(\"Return Value\")\nlogger = Logger()\nannounce = logger.log",
        "detail": "lab.lab11.editor.log",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lab.lab11.editor.log",
        "description": "lab.lab11.editor.log",
        "peekOfCode": "logger = Logger()\nannounce = logger.log",
        "detail": "lab.lab11.editor.log",
        "documentation": {}
    },
    {
        "label": "announce",
        "kind": 5,
        "importPath": "lab.lab11.editor.log",
        "description": "lab.lab11.editor.log",
        "peekOfCode": "announce = logger.log",
        "detail": "lab.lab11.editor.log",
        "documentation": {}
    },
    {
        "label": "get_id",
        "kind": 2,
        "importPath": "lab.lab11.editor.log_utils",
        "description": "lab.lab11.editor.log_utils",
        "peekOfCode": "def get_id():\n    global counter\n    counter += 1\n    return str(counter)",
        "detail": "lab.lab11.editor.log_utils",
        "documentation": {}
    },
    {
        "label": "counter",
        "kind": 5,
        "importPath": "lab.lab11.editor.log_utils",
        "description": "lab.lab11.editor.log_utils",
        "peekOfCode": "counter = 0\ndef get_id():\n    global counter\n    counter += 1\n    return str(counter)",
        "detail": "lab.lab11.editor.log_utils",
        "documentation": {}
    },
    {
        "label": "PrintCapture",
        "kind": 6,
        "importPath": "lab.lab11.editor.ok_interface",
        "description": "lab.lab11.editor.ok_interface",
        "peekOfCode": "class PrintCapture:\n    def __init__(self, old_stdout):\n        self.log = []\n        self.old_stdout = old_stdout\n    def write(self, message):\n        self.log.append(message)\n        self.old_stdout.write(message)\n    def flush(self):\n        sys.__stdout__.flush()\ndef capture_output(console, lines):",
        "detail": "lab.lab11.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "PromptOutput",
        "kind": 6,
        "importPath": "lab.lab11.editor.ok_interface",
        "description": "lab.lab11.editor.ok_interface",
        "peekOfCode": "class PromptOutput(metaclass=ABCMeta):\n    @abstractmethod\n    def representation(self):\n        pass\n    @abstractmethod\n    def success(self):\n        pass\nclass AreDifferent(PromptOutput, namedtuple('AreDifferent', ['prompt', 'expected', 'actual'])):\n    def representation(self):\n        return \"{expected}\\n{actual}\\n{prompt}\".format(",
        "detail": "lab.lab11.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "AreDifferent",
        "kind": 6,
        "importPath": "lab.lab11.editor.ok_interface",
        "description": "lab.lab11.editor.ok_interface",
        "peekOfCode": "class AreDifferent(PromptOutput, namedtuple('AreDifferent', ['prompt', 'expected', 'actual'])):\n    def representation(self):\n        return \"{expected}\\n{actual}\\n{prompt}\".format(\n            prompt=self.prompt,\n            expected=pad(\"; Expected: \", \";\", self.expected),\n            actual=pad(\"; Actual  : \", \";\", self.actual)\n        )\n    def success(self):\n        return False\nclass Error(PromptOutput, namedtuple('PromptOutput', ['prompt', 'error'])):",
        "detail": "lab.lab11.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "Error",
        "kind": 6,
        "importPath": "lab.lab11.editor.ok_interface",
        "description": "lab.lab11.editor.ok_interface",
        "peekOfCode": "class Error(PromptOutput, namedtuple('PromptOutput', ['prompt', 'error'])):\n    def representation(self):\n        return \"{error}\\n{prompt}\".format(\n            error=pad(\"; Error: \", \";\", self.error),\n            prompt=self.prompt\n        )\n    def success(self):\n        return False\nclass Same(PromptOutput, namedtuple('Same', ['prompt', 'output'])):\n    def representation(self):",
        "detail": "lab.lab11.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "Same",
        "kind": 6,
        "importPath": "lab.lab11.editor.ok_interface",
        "description": "lab.lab11.editor.ok_interface",
        "peekOfCode": "class Same(PromptOutput, namedtuple('Same', ['prompt', 'output'])):\n    def representation(self):\n        return \"{output}\\n{prompt}\".format(\n            prompt=self.prompt,\n            output=pad(\"; Success: \", \";\", self.output)\n        )\n    def success(self):\n        return True\nclass Locked(PromptOutput, namedtuple('Locked', [])):\n    def representation(self):",
        "detail": "lab.lab11.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "Locked",
        "kind": 6,
        "importPath": "lab.lab11.editor.ok_interface",
        "description": "lab.lab11.editor.ok_interface",
        "peekOfCode": "class Locked(PromptOutput, namedtuple('Locked', [])):\n    def representation(self):\n        return \"; Run python ok -u to unlock test case. \\n (error \\\"Test case locked!\\\")\"\n    def success(self):\n        return False\nclass TestCaseResult(namedtuple('TestCaseResult', ['cases_passed', 'cases_out', 'setup_out'])):\n    @property\n    def success(self):\n        return self.cases_passed\n    @property",
        "detail": "lab.lab11.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "TestCaseResult",
        "kind": 6,
        "importPath": "lab.lab11.editor.ok_interface",
        "description": "lab.lab11.editor.ok_interface",
        "peekOfCode": "class TestCaseResult(namedtuple('TestCaseResult', ['cases_passed', 'cases_out', 'setup_out'])):\n    @property\n    def success(self):\n        return self.cases_passed\n    @property\n    def output(self):\n        result = \"\"\n        if self.setup_out.success():\n            result += self.setup_out.prompt\n        else:",
        "detail": "lab.lab11.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "capture_output",
        "kind": 2,
        "importPath": "lab.lab11.editor.ok_interface",
        "description": "lab.lab11.editor.ok_interface",
        "peekOfCode": "def capture_output(console, lines):\n    old_stdout = sys.stdout\n    sys.stdout = out = PrintCapture(old_stdout)\n    result = console._interpret_lines(lines)\n    sys.stdout = old_stdout\n    if str(TerminatedError()) in \"\".join(out.log):\n        raise TerminatedError\n    return result, out.log\nclass PromptOutput(metaclass=ABCMeta):\n    @abstractmethod",
        "detail": "lab.lab11.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "chunked_input",
        "kind": 2,
        "importPath": "lab.lab11.editor.ok_interface",
        "description": "lab.lab11.editor.ok_interface",
        "peekOfCode": "def chunked_input(lines):\n    chunk = []\n    for line in lines:\n        chunk.append(line)\n        if not isinstance(line, str):\n            yield chunk\n            chunk = []\ndef remove_comments_and_combine(lines):\n    result = []\n    for line in lines:",
        "detail": "lab.lab11.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "remove_comments_and_combine",
        "kind": 2,
        "importPath": "lab.lab11.editor.ok_interface",
        "description": "lab.lab11.editor.ok_interface",
        "peekOfCode": "def remove_comments_and_combine(lines):\n    result = []\n    for line in lines:\n        if not line:\n            continue\n        if line[0] == \"#\":\n            line = line[1:]\n        line = line.strip()\n        result.append(line)\n    return \"\\n\".join(result)",
        "detail": "lab.lab11.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "pad",
        "kind": 2,
        "importPath": "lab.lab11.editor.ok_interface",
        "description": "lab.lab11.editor.ok_interface",
        "peekOfCode": "def pad(first_header, later_header, string):\n    assert len(later_header) <= len(first_header)\n    later_header += \" \" * (len(first_header) - len(later_header))\n    lines = string.split(\"\\n\")\n    lines[0] = first_header + lines[0]\n    for i in range(1, len(lines)):\n        lines[i] = later_header + lines[i]\n    return \"\\n\".join(lines)\ndef process(output, success):\n    prompt = []",
        "detail": "lab.lab11.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "process",
        "kind": 2,
        "importPath": "lab.lab11.editor.ok_interface",
        "description": "lab.lab11.editor.ok_interface",
        "peekOfCode": "def process(output, success):\n    prompt = []\n    lines = \"\".join(output).split(\"\\n\")\n    start_idx = len(lines)\n    for idx, line in enumerate(lines):\n        line = line.strip()\n        if not line:\n            continue\n        if line.startswith(\"scm> \") or line.startswith(\".... \"):\n            prompt.append(line[5:])",
        "detail": "lab.lab11.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "process_case",
        "kind": 2,
        "importPath": "lab.lab11.editor.ok_interface",
        "description": "lab.lab11.editor.ok_interface",
        "peekOfCode": "def process_case(case):\n    setup_success, setup_out = capture_output(case.console, case.setup.splitlines())\n    setup_out = \"\".join(setup_out)\n    if not setup_success:\n        return TestCaseResult(setup_success, [], process(setup_out, True))\n    interpret_success_overall = True\n    interpret_out_overall = []\n    for chunk in chunked_input(case.lines + case.teardown.splitlines()):\n        interpret_success, interpret_out = capture_output(case.console, chunk)\n        interpret_success_overall = interpret_success_overall and interpret_success",
        "detail": "lab.lab11.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "reload_tests",
        "kind": 2,
        "importPath": "lab.lab11.editor.ok_interface",
        "description": "lab.lab11.editor.ok_interface",
        "peekOfCode": "def reload_tests():\n    for testname in filter(lambda x: x.lower().endswith(\".py\"), os.listdir(os.curdir + \"/tests\")):\n        testname = \"tests.\" + testname[:-3]\n        if testname in sys.modules:\n            del sys.modules[testname]\n@contextmanager\ndef redirect_descriptor(from_, to):  # https://stackoverflow.com/a/22434262\n    fd = from_.fileno()\n    with os.fdopen(os.dup(fd), 'wb') as copied:\n        from_.flush()",
        "detail": "lab.lab11.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "redirect_descriptor",
        "kind": 2,
        "importPath": "lab.lab11.editor.ok_interface",
        "description": "lab.lab11.editor.ok_interface",
        "peekOfCode": "def redirect_descriptor(from_, to):  # https://stackoverflow.com/a/22434262\n    fd = from_.fileno()\n    with os.fdopen(os.dup(fd), 'wb') as copied:\n        from_.flush()\n        os.dup2(to.fileno(), fd)\n        try: yield from_\n        finally:\n            from_.flush()\n            os.dup2(copied.fileno(), fd)\ndef run_tests():",
        "detail": "lab.lab11.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "run_tests",
        "kind": 2,
        "importPath": "lab.lab11.editor.ok_interface",
        "description": "lab.lab11.editor.ok_interface",
        "peekOfCode": "def run_tests():\n    reload_tests()\n    # noinspection PyUnresolvedReferences\n    from client.api import assignment\n    import logging\n    LOGGING_FORMAT = '%(levelname)s  | %(filename)s:%(lineno)d | %(message)s'\n    logging.basicConfig(format=LOGGING_FORMAT)\n    log = logging.getLogger('client')  # Get top-level logger\n    # noinspection PyUnresolvedReferences\n    from client.cli.ok import parse_input",
        "detail": "lab.lab11.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "FAILURE_SETUP_HEADER",
        "kind": 5,
        "importPath": "lab.lab11.editor.ok_interface",
        "description": "lab.lab11.editor.ok_interface",
        "peekOfCode": "FAILURE_SETUP_HEADER = '''; There was an error in running the setup code (probably in loading your file)\n; Raw ok output follows'''\nFAILURE_SETUP_FOOTER = \"; Raw ok output over\"\nBEGIN_OUTPUT = b\"sdfghjkjhgfdfghjklkjhgfdxcfghj\"\nclass PrintCapture:\n    def __init__(self, old_stdout):\n        self.log = []\n        self.old_stdout = old_stdout\n    def write(self, message):\n        self.log.append(message)",
        "detail": "lab.lab11.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "FAILURE_SETUP_FOOTER",
        "kind": 5,
        "importPath": "lab.lab11.editor.ok_interface",
        "description": "lab.lab11.editor.ok_interface",
        "peekOfCode": "FAILURE_SETUP_FOOTER = \"; Raw ok output over\"\nBEGIN_OUTPUT = b\"sdfghjkjhgfdfghjklkjhgfdxcfghj\"\nclass PrintCapture:\n    def __init__(self, old_stdout):\n        self.log = []\n        self.old_stdout = old_stdout\n    def write(self, message):\n        self.log.append(message)\n        self.old_stdout.write(message)\n    def flush(self):",
        "detail": "lab.lab11.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "BEGIN_OUTPUT",
        "kind": 5,
        "importPath": "lab.lab11.editor.ok_interface",
        "description": "lab.lab11.editor.ok_interface",
        "peekOfCode": "BEGIN_OUTPUT = b\"sdfghjkjhgfdfghjklkjhgfdxcfghj\"\nclass PrintCapture:\n    def __init__(self, old_stdout):\n        self.log = []\n        self.old_stdout = old_stdout\n    def write(self, message):\n        self.log.append(message)\n        self.old_stdout.write(message)\n    def flush(self):\n        sys.__stdout__.flush()",
        "detail": "lab.lab11.editor.ok_interface",
        "documentation": {}
    },
    {
        "label": "save_config",
        "kind": 2,
        "importPath": "lab.lab11.editor.persistence",
        "description": "lab.lab11.editor.persistence",
        "peekOfCode": "def save_config(key, content):\n    os.makedirs(config_path, exist_ok=True)\n    with open(config_path + \"/\" + key + \".config\", \"w+\") as f:\n        f.write(json.dumps(content))\ndef load_config(key):\n    with open(config_path + \"/\" + key + \".config\", \"r\") as f:\n        return json.loads(f.read())",
        "detail": "lab.lab11.editor.persistence",
        "documentation": {}
    },
    {
        "label": "load_config",
        "kind": 2,
        "importPath": "lab.lab11.editor.persistence",
        "description": "lab.lab11.editor.persistence",
        "peekOfCode": "def load_config(key):\n    with open(config_path + \"/\" + key + \".config\", \"r\") as f:\n        return json.loads(f.read())",
        "detail": "lab.lab11.editor.persistence",
        "documentation": {}
    },
    {
        "label": "home",
        "kind": 5,
        "importPath": "lab.lab11.editor.persistence",
        "description": "lab.lab11.editor.persistence",
        "peekOfCode": "home = str(Path.home())\nconfig_path = home + \"/.scheme_editor\"\ndef save_config(key, content):\n    os.makedirs(config_path, exist_ok=True)\n    with open(config_path + \"/\" + key + \".config\", \"w+\") as f:\n        f.write(json.dumps(content))\ndef load_config(key):\n    with open(config_path + \"/\" + key + \".config\", \"r\") as f:\n        return json.loads(f.read())",
        "detail": "lab.lab11.editor.persistence",
        "documentation": {}
    },
    {
        "label": "config_path",
        "kind": 5,
        "importPath": "lab.lab11.editor.persistence",
        "description": "lab.lab11.editor.persistence",
        "peekOfCode": "config_path = home + \"/.scheme_editor\"\ndef save_config(key, content):\n    os.makedirs(config_path, exist_ok=True)\n    with open(config_path + \"/\" + key + \".config\", \"w+\") as f:\n        f.write(json.dumps(content))\ndef load_config(key):\n    with open(config_path + \"/\" + key + \".config\", \"r\") as f:\n        return json.loads(f.read())",
        "detail": "lab.lab11.editor.persistence",
        "documentation": {}
    },
    {
        "label": "BuiltIn",
        "kind": 6,
        "importPath": "lab.lab11.editor.primitives",
        "description": "lab.lab11.editor.primitives",
        "peekOfCode": "class BuiltIn(Applicable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder, eval_operands=True) -> Expression:\n        if eval_operands:\n            operands = evaluate_all(operands, frame, gui_holder.expression.children[1:])\n        gui_holder.expression.set_entries([])\n        gui_holder.apply()\n        return self.execute_evaluated(operands, frame)\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        raise NotImplementedError()\nclass SingleOperandPrimitive(BuiltIn):",
        "detail": "lab.lab11.editor.primitives",
        "documentation": {}
    },
    {
        "label": "SingleOperandPrimitive",
        "kind": 6,
        "importPath": "lab.lab11.editor.primitives",
        "description": "lab.lab11.editor.primitives",
        "peekOfCode": "class SingleOperandPrimitive(BuiltIn):\n    def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n        verify_exact_callable_length(self, 1, len(operands))\n        operand = operands[0]\n        return self.execute_simple(operand)\n    def execute_simple(self, operand: Expression) -> Expression:\n        raise NotImplementedError()\ndef load_primitives():\n    __import__(\"arithmetic\")\n    __import__(\"lists\")",
        "detail": "lab.lab11.editor.primitives",
        "documentation": {}
    },
    {
        "label": "load_primitives",
        "kind": 2,
        "importPath": "lab.lab11.editor.primitives",
        "description": "lab.lab11.editor.primitives",
        "peekOfCode": "def load_primitives():\n    __import__(\"arithmetic\")\n    __import__(\"lists\")\n    __import__(\"type_checking\")\n    __import__(\"console\")\n    __import__(\"graphics\")\n    __import__(\"visualizing\")",
        "detail": "lab.lab11.editor.primitives",
        "documentation": {}
    },
    {
        "label": "OperationCanceledException",
        "kind": 6,
        "importPath": "lab.lab11.editor.runtime_limiter",
        "description": "lab.lab11.editor.runtime_limiter",
        "peekOfCode": "class OperationCanceledException(Exception):\n    pass\nclass TimeLimitException(Exception):\n    pass\ndef limiter(raise_exception, lim, func, *args):\n    is_event = isinstance(lim, threading.Event)\n    lim_is_set = lim.is_set if is_event else None  # For performance\n    gettime = time.time  # For performance\n    end = (gettime() + lim) if not is_event else None\n    def tracer(*args):",
        "detail": "lab.lab11.editor.runtime_limiter",
        "documentation": {}
    },
    {
        "label": "TimeLimitException",
        "kind": 6,
        "importPath": "lab.lab11.editor.runtime_limiter",
        "description": "lab.lab11.editor.runtime_limiter",
        "peekOfCode": "class TimeLimitException(Exception):\n    pass\ndef limiter(raise_exception, lim, func, *args):\n    is_event = isinstance(lim, threading.Event)\n    lim_is_set = lim.is_set if is_event else None  # For performance\n    gettime = time.time  # For performance\n    end = (gettime() + lim) if not is_event else None\n    def tracer(*args):\n        if lim_is_set() if is_event else gettime() > end:\n            raise_exception(OperationCanceledException() if is_event else TimeLimitException())",
        "detail": "lab.lab11.editor.runtime_limiter",
        "documentation": {}
    },
    {
        "label": "limiter",
        "kind": 2,
        "importPath": "lab.lab11.editor.runtime_limiter",
        "description": "lab.lab11.editor.runtime_limiter",
        "peekOfCode": "def limiter(raise_exception, lim, func, *args):\n    is_event = isinstance(lim, threading.Event)\n    lim_is_set = lim.is_set if is_event else None  # For performance\n    gettime = time.time  # For performance\n    end = (gettime() + lim) if not is_event else None\n    def tracer(*args):\n        if lim_is_set() if is_event else gettime() > end:\n            raise_exception(OperationCanceledException() if is_event else TimeLimitException())\n        return tracer\n    sys_tracer = sys.gettrace()",
        "detail": "lab.lab11.editor.runtime_limiter",
        "documentation": {}
    },
    {
        "label": "scheme_limiter",
        "kind": 2,
        "importPath": "lab.lab11.editor.runtime_limiter",
        "description": "lab.lab11.editor.runtime_limiter",
        "peekOfCode": "def scheme_limiter(*args, **kwargs):\n    def raise_(e):  # Translate to scheme exception and throw\n        if isinstance(e, OperationCanceledException):\n            e = TerminatedError\n        raise e\n    return limiter(raise_, *args, **kwargs)",
        "detail": "lab.lab11.editor.runtime_limiter",
        "documentation": {}
    },
    {
        "label": "SchemeError",
        "kind": 6,
        "importPath": "lab.lab11.editor.scheme_exceptions",
        "description": "lab.lab11.editor.scheme_exceptions",
        "peekOfCode": "class SchemeError(Exception):\n    def __repr__(self):\n        return str(self)\nclass TerminatedError(SchemeError):\n    def __init__(self):\n        super().__init__(\"Error: program manually terminated\")\nclass ParseError(SchemeError):\n    pass\nclass SymbolLookupError(SchemeError):\n    pass",
        "detail": "lab.lab11.editor.scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "TerminatedError",
        "kind": 6,
        "importPath": "lab.lab11.editor.scheme_exceptions",
        "description": "lab.lab11.editor.scheme_exceptions",
        "peekOfCode": "class TerminatedError(SchemeError):\n    def __init__(self):\n        super().__init__(\"Error: program manually terminated\")\nclass ParseError(SchemeError):\n    pass\nclass SymbolLookupError(SchemeError):\n    pass\nclass OperandDeduceError(SchemeError):\n    pass\nclass TurtleDrawingError(SchemeError):",
        "detail": "lab.lab11.editor.scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "ParseError",
        "kind": 6,
        "importPath": "lab.lab11.editor.scheme_exceptions",
        "description": "lab.lab11.editor.scheme_exceptions",
        "peekOfCode": "class ParseError(SchemeError):\n    pass\nclass SymbolLookupError(SchemeError):\n    pass\nclass OperandDeduceError(SchemeError):\n    pass\nclass TurtleDrawingError(SchemeError):\n    pass\nclass CallableResolutionError(SchemeError):\n    pass",
        "detail": "lab.lab11.editor.scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "SymbolLookupError",
        "kind": 6,
        "importPath": "lab.lab11.editor.scheme_exceptions",
        "description": "lab.lab11.editor.scheme_exceptions",
        "peekOfCode": "class SymbolLookupError(SchemeError):\n    pass\nclass OperandDeduceError(SchemeError):\n    pass\nclass TurtleDrawingError(SchemeError):\n    pass\nclass CallableResolutionError(SchemeError):\n    pass\nclass MathError(SchemeError):\n    pass",
        "detail": "lab.lab11.editor.scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "OperandDeduceError",
        "kind": 6,
        "importPath": "lab.lab11.editor.scheme_exceptions",
        "description": "lab.lab11.editor.scheme_exceptions",
        "peekOfCode": "class OperandDeduceError(SchemeError):\n    pass\nclass TurtleDrawingError(SchemeError):\n    pass\nclass CallableResolutionError(SchemeError):\n    pass\nclass MathError(SchemeError):\n    pass\nclass ComparisonError(SchemeError):\n    pass",
        "detail": "lab.lab11.editor.scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "TurtleDrawingError",
        "kind": 6,
        "importPath": "lab.lab11.editor.scheme_exceptions",
        "description": "lab.lab11.editor.scheme_exceptions",
        "peekOfCode": "class TurtleDrawingError(SchemeError):\n    pass\nclass CallableResolutionError(SchemeError):\n    pass\nclass MathError(SchemeError):\n    pass\nclass ComparisonError(SchemeError):\n    pass\nclass TypeMismatchError(SchemeError):\n    pass",
        "detail": "lab.lab11.editor.scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "CallableResolutionError",
        "kind": 6,
        "importPath": "lab.lab11.editor.scheme_exceptions",
        "description": "lab.lab11.editor.scheme_exceptions",
        "peekOfCode": "class CallableResolutionError(SchemeError):\n    pass\nclass MathError(SchemeError):\n    pass\nclass ComparisonError(SchemeError):\n    pass\nclass TypeMismatchError(SchemeError):\n    pass\nclass IrreversibleOperationError(SchemeError):\n    pass",
        "detail": "lab.lab11.editor.scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "MathError",
        "kind": 6,
        "importPath": "lab.lab11.editor.scheme_exceptions",
        "description": "lab.lab11.editor.scheme_exceptions",
        "peekOfCode": "class MathError(SchemeError):\n    pass\nclass ComparisonError(SchemeError):\n    pass\nclass TypeMismatchError(SchemeError):\n    pass\nclass IrreversibleOperationError(SchemeError):\n    pass\nclass FormatError(SchemeError):\n    pass",
        "detail": "lab.lab11.editor.scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "ComparisonError",
        "kind": 6,
        "importPath": "lab.lab11.editor.scheme_exceptions",
        "description": "lab.lab11.editor.scheme_exceptions",
        "peekOfCode": "class ComparisonError(SchemeError):\n    pass\nclass TypeMismatchError(SchemeError):\n    pass\nclass IrreversibleOperationError(SchemeError):\n    pass\nclass FormatError(SchemeError):\n    pass\nclass LoadError(SchemeError):\n    pass",
        "detail": "lab.lab11.editor.scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "TypeMismatchError",
        "kind": 6,
        "importPath": "lab.lab11.editor.scheme_exceptions",
        "description": "lab.lab11.editor.scheme_exceptions",
        "peekOfCode": "class TypeMismatchError(SchemeError):\n    pass\nclass IrreversibleOperationError(SchemeError):\n    pass\nclass FormatError(SchemeError):\n    pass\nclass LoadError(SchemeError):\n    pass\nclass OutOfMemoryError(SchemeError):\n    pass",
        "detail": "lab.lab11.editor.scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "IrreversibleOperationError",
        "kind": 6,
        "importPath": "lab.lab11.editor.scheme_exceptions",
        "description": "lab.lab11.editor.scheme_exceptions",
        "peekOfCode": "class IrreversibleOperationError(SchemeError):\n    pass\nclass FormatError(SchemeError):\n    pass\nclass LoadError(SchemeError):\n    pass\nclass OutOfMemoryError(SchemeError):\n    pass",
        "detail": "lab.lab11.editor.scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "FormatError",
        "kind": 6,
        "importPath": "lab.lab11.editor.scheme_exceptions",
        "description": "lab.lab11.editor.scheme_exceptions",
        "peekOfCode": "class FormatError(SchemeError):\n    pass\nclass LoadError(SchemeError):\n    pass\nclass OutOfMemoryError(SchemeError):\n    pass",
        "detail": "lab.lab11.editor.scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "LoadError",
        "kind": 6,
        "importPath": "lab.lab11.editor.scheme_exceptions",
        "description": "lab.lab11.editor.scheme_exceptions",
        "peekOfCode": "class LoadError(SchemeError):\n    pass\nclass OutOfMemoryError(SchemeError):\n    pass",
        "detail": "lab.lab11.editor.scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "OutOfMemoryError",
        "kind": 6,
        "importPath": "lab.lab11.editor.scheme_exceptions",
        "description": "lab.lab11.editor.scheme_exceptions",
        "peekOfCode": "class OutOfMemoryError(SchemeError):\n    pass",
        "detail": "lab.lab11.editor.scheme_exceptions",
        "documentation": {}
    },
    {
        "label": "ProcedureObject",
        "kind": 6,
        "importPath": "lab.lab11.editor.special_forms",
        "description": "lab.lab11.editor.special_forms",
        "peekOfCode": "class ProcedureObject(Callable):\n    evaluates_operands: bool\n    lexically_scoped: bool\n    name: str\n    def __init__(self,\n                 params: List[Symbol],\n                 var_param: Optional[Symbol],\n                 body: List[Expression],\n                 frame: Frame,\n                 name: str=None):",
        "detail": "lab.lab11.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "LambdaObject",
        "kind": 6,
        "importPath": "lab.lab11.editor.special_forms",
        "description": "lab.lab11.editor.special_forms",
        "peekOfCode": "class LambdaObject(ProcedureObject, Applicable):\n    evaluates_operands = True\n    lexically_scoped = True\n    name = \"lambda\"\nclass MuObject(ProcedureObject, Applicable):\n    evaluates_operands = True\n    lexically_scoped = False\n    name = \"mu\"\nclass MacroObject(ProcedureObject, Callable):\n    evaluates_operands = False",
        "detail": "lab.lab11.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "MuObject",
        "kind": 6,
        "importPath": "lab.lab11.editor.special_forms",
        "description": "lab.lab11.editor.special_forms",
        "peekOfCode": "class MuObject(ProcedureObject, Applicable):\n    evaluates_operands = True\n    lexically_scoped = False\n    name = \"mu\"\nclass MacroObject(ProcedureObject, Callable):\n    evaluates_operands = False\n    lexically_scoped = True\n    name = \"macro\"\nclass ProcedureBuilder(Callable):\n    procedure: Type[ProcedureObject]",
        "detail": "lab.lab11.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "MacroObject",
        "kind": 6,
        "importPath": "lab.lab11.editor.special_forms",
        "description": "lab.lab11.editor.special_forms",
        "peekOfCode": "class MacroObject(ProcedureObject, Callable):\n    evaluates_operands = False\n    lexically_scoped = True\n    name = \"macro\"\nclass ProcedureBuilder(Callable):\n    procedure: Type[ProcedureObject]\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder, name: str = \"lambda\"):\n        verify_min_callable_length(self, 2, len(operands))\n        params = operands[0]\n        if not logger.dotted and not isinstance(params, (Pair, NilType)):",
        "detail": "lab.lab11.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "ProcedureBuilder",
        "kind": 6,
        "importPath": "lab.lab11.editor.special_forms",
        "description": "lab.lab11.editor.special_forms",
        "peekOfCode": "class ProcedureBuilder(Callable):\n    procedure: Type[ProcedureObject]\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder, name: str = \"lambda\"):\n        verify_min_callable_length(self, 2, len(operands))\n        params = operands[0]\n        if not logger.dotted and not isinstance(params, (Pair, NilType)):\n            raise OperandDeduceError(f\"Expected Pair as parameter list, received {params}.\")\n        params, var_param = dotted_pair_to_list(params)\n        for i, param in enumerate(params):\n            if (logger.dotted or i != len(params) - 1) and not isinstance(param, Symbol):",
        "detail": "lab.lab11.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Lambda",
        "kind": 6,
        "importPath": "lab.lab11.editor.special_forms",
        "description": "lab.lab11.editor.special_forms",
        "peekOfCode": "class Lambda(ProcedureBuilder):\n    procedure = LambdaObject\n@special_form(\"mu\")\nclass Mu(ProcedureBuilder):\n    procedure = MuObject\nclass Macro(ProcedureBuilder):\n    procedure = MacroObject\n@special_form(\"define-macro\")\nclass DefineMacro(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):",
        "detail": "lab.lab11.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Mu",
        "kind": 6,
        "importPath": "lab.lab11.editor.special_forms",
        "description": "lab.lab11.editor.special_forms",
        "peekOfCode": "class Mu(ProcedureBuilder):\n    procedure = MuObject\nclass Macro(ProcedureBuilder):\n    procedure = MacroObject\n@special_form(\"define-macro\")\nclass DefineMacro(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        verify_min_callable_length(self, 2, len(operands))\n        params = operands[0]\n        if not isinstance(params, Pair):",
        "detail": "lab.lab11.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Macro",
        "kind": 6,
        "importPath": "lab.lab11.editor.special_forms",
        "description": "lab.lab11.editor.special_forms",
        "peekOfCode": "class Macro(ProcedureBuilder):\n    procedure = MacroObject\n@special_form(\"define-macro\")\nclass DefineMacro(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        verify_min_callable_length(self, 2, len(operands))\n        params = operands[0]\n        if not isinstance(params, Pair):\n            raise OperandDeduceError(f\"Expected a Pair, not {params}, as the first operand of define-macro.\")\n        name = params.first",
        "detail": "lab.lab11.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "DefineMacro",
        "kind": 6,
        "importPath": "lab.lab11.editor.special_forms",
        "description": "lab.lab11.editor.special_forms",
        "peekOfCode": "class DefineMacro(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        verify_min_callable_length(self, 2, len(operands))\n        params = operands[0]\n        if not isinstance(params, Pair):\n            raise OperandDeduceError(f\"Expected a Pair, not {params}, as the first operand of define-macro.\")\n        name = params.first\n        operands[0] = params.rest\n        if not isinstance(name, Symbol):\n            raise OperandDeduceError(f\"Expected a Symbol, not {name}.\")",
        "detail": "lab.lab11.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Define",
        "kind": 6,
        "importPath": "lab.lab11.editor.special_forms",
        "description": "lab.lab11.editor.special_forms",
        "peekOfCode": "class Define(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        verify_min_callable_length(self, 2, len(operands))\n        params = operands[0]\n        if isinstance(params, Symbol):\n            verify_exact_callable_length(self, 2, len(operands))\n            frame.assign(params, evaluate(operands[1], frame, gui_holder.expression.children[2]))\n            return params\n        elif isinstance(params, Pair):\n            name = params.first",
        "detail": "lab.lab11.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Set",
        "kind": 6,
        "importPath": "lab.lab11.editor.special_forms",
        "description": "lab.lab11.editor.special_forms",
        "peekOfCode": "class Set(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        verify_exact_callable_length(self, 2, len(operands))\n        name = operands[0]\n        if not isinstance(name, Symbol):\n            raise OperandDeduceError(f\"Expected a Symbol, not {name}, as the first operand of set!\")\n        frame.mutate(name, evaluate(operands[1], frame, gui_holder.expression.children[2]))\n        return Undefined\n@special_form(\"begin\")\nclass Begin(Callable):",
        "detail": "lab.lab11.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Begin",
        "kind": 6,
        "importPath": "lab.lab11.editor.special_forms",
        "description": "lab.lab11.editor.special_forms",
        "peekOfCode": "class Begin(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        verify_min_callable_length(self, 1, len(operands))\n        out = None\n        for i, (operand, holder) in enumerate(zip(operands, gui_holder.expression.children[1:])):\n            out = evaluate(operand, frame, holder, i == len(operands) - 1)\n        return out\n@special_form(\"if\")\nclass If(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):",
        "detail": "lab.lab11.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "If",
        "kind": 6,
        "importPath": "lab.lab11.editor.special_forms",
        "description": "lab.lab11.editor.special_forms",
        "peekOfCode": "class If(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        verify_min_callable_length(self, 2, len(operands))\n        if len(operands) > 3:\n            verify_exact_callable_length(self, 3, len(operands))\n        if evaluate(operands[0], frame, gui_holder.expression.children[1]) is SingletonFalse:\n            if len(operands) == 2:\n                return Undefined\n            else:\n                return evaluate(operands[2], frame, gui_holder.expression.children[3], True)",
        "detail": "lab.lab11.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Quote",
        "kind": 6,
        "importPath": "lab.lab11.editor.special_forms",
        "description": "lab.lab11.editor.special_forms",
        "peekOfCode": "class Quote(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        verify_exact_callable_length(self, 1, len(operands))\n        return operands[0]\n@global_attr(\"eval\")\nclass Eval(Applicable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder, eval_operands=True):\n        verify_exact_callable_length(self, 1, len(operands))\n        if eval_operands:\n            operand = evaluate(operands[0], frame, gui_holder.expression.children[1])",
        "detail": "lab.lab11.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Eval",
        "kind": 6,
        "importPath": "lab.lab11.editor.special_forms",
        "description": "lab.lab11.editor.special_forms",
        "peekOfCode": "class Eval(Applicable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder, eval_operands=True):\n        verify_exact_callable_length(self, 1, len(operands))\n        if eval_operands:\n            operand = evaluate(operands[0], frame, gui_holder.expression.children[1])\n        else:\n            operand = operands[0]\n        gui_holder.expression.set_entries([VisualExpression(operand, gui_holder.expression.display_value)])\n        gui_holder.apply()\n        return evaluate(operand, frame, gui_holder.expression.children[0], True)",
        "detail": "lab.lab11.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Apply",
        "kind": 6,
        "importPath": "lab.lab11.editor.special_forms",
        "description": "lab.lab11.editor.special_forms",
        "peekOfCode": "class Apply(Applicable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder, eval_operands=True):\n        verify_exact_callable_length(self, 2, len(operands))\n        if eval_operands:\n            operands = evaluate_all(operands, frame, gui_holder.expression.children[1:])\n        func, args = operands\n        if not isinstance(func, Applicable):\n            raise OperandDeduceError(f\"Unable to apply {func}.\")\n        gui_holder.expression.set_entries([VisualExpression(Pair(func, args), gui_holder.expression.display_value)])\n        gui_holder.expression.children[0].expression.children = []",
        "detail": "lab.lab11.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Cond",
        "kind": 6,
        "importPath": "lab.lab11.editor.special_forms",
        "description": "lab.lab11.editor.special_forms",
        "peekOfCode": "class Cond(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        verify_min_callable_length(self, 1, len(operands))\n        for cond_i, cond in enumerate(operands):\n            if not isinstance(cond, Pair):\n                raise OperandDeduceError(f\"Unable to evaluate clause of cond, as {cond} is not a Pair.\")\n            expanded = pair_to_list(cond)\n            cond_holder = gui_holder.expression.children[cond_i + 1]\n            eval_condition = SingletonTrue\n            if not isinstance(expanded[0], Symbol) or expanded[0].value != \"else\":",
        "detail": "lab.lab11.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "And",
        "kind": 6,
        "importPath": "lab.lab11.editor.special_forms",
        "description": "lab.lab11.editor.special_forms",
        "peekOfCode": "class And(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        value = None\n        for i, expr in enumerate(operands):\n            value = evaluate(expr, frame, gui_holder.expression.children[i + 1], i == len(operands) - 1)\n            if value is SingletonFalse:\n                return SingletonFalse\n        return value if operands else SingletonTrue\n@special_form(\"or\")\nclass Or(Callable):",
        "detail": "lab.lab11.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Or",
        "kind": 6,
        "importPath": "lab.lab11.editor.special_forms",
        "description": "lab.lab11.editor.special_forms",
        "peekOfCode": "class Or(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        for i, expr in enumerate(operands):\n            value = evaluate(expr, frame, gui_holder.expression.children[i + 1], i == len(operands) - 1)\n            if value is not SingletonFalse:\n                return value\n        return SingletonFalse\n@special_form(\"let\")\nclass Let(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):",
        "detail": "lab.lab11.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Let",
        "kind": 6,
        "importPath": "lab.lab11.editor.special_forms",
        "description": "lab.lab11.editor.special_forms",
        "peekOfCode": "class Let(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        verify_min_callable_length(self, 2, len(operands))\n        bindings = operands[0]\n        if not isinstance(bindings, Pair) and bindings is not Nil:\n            raise OperandDeduceError(f\"Expected first argument of let to be a Pair, not {bindings}.\")\n        new_frame = Frame(\"anonymous let\", frame)\n        bindings_holder = gui_holder.expression.children[1]\n        bindings = pair_to_list(bindings)\n        for i, binding in enumerate(bindings):",
        "detail": "lab.lab11.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Variadic",
        "kind": 6,
        "importPath": "lab.lab11.editor.special_forms",
        "description": "lab.lab11.editor.special_forms",
        "peekOfCode": "class Variadic(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        raise CallableResolutionError(\"Variadic type parameter must be within a parameter list.\")\n@special_form(\"unquote\")\nclass Unquote(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        raise CallableResolutionError(\"Cannot evaluate unquote outside quasiquote.\")\n@special_form(\"unquote-splicing\")\nclass UnquoteSplicing(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):",
        "detail": "lab.lab11.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Unquote",
        "kind": 6,
        "importPath": "lab.lab11.editor.special_forms",
        "description": "lab.lab11.editor.special_forms",
        "peekOfCode": "class Unquote(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        raise CallableResolutionError(\"Cannot evaluate unquote outside quasiquote.\")\n@special_form(\"unquote-splicing\")\nclass UnquoteSplicing(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        raise CallableResolutionError(\"Cannot evaluate unquote-splicing outside quasiquote.\")\n@special_form(\"quasiquote\")\nclass Quasiquote(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):",
        "detail": "lab.lab11.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "UnquoteSplicing",
        "kind": 6,
        "importPath": "lab.lab11.editor.special_forms",
        "description": "lab.lab11.editor.special_forms",
        "peekOfCode": "class UnquoteSplicing(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        raise CallableResolutionError(\"Cannot evaluate unquote-splicing outside quasiquote.\")\n@special_form(\"quasiquote\")\nclass Quasiquote(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        verify_exact_callable_length(self, 1, len(operands))\n        return Quasiquote.quasiquote_evaluate(operands[0], frame, gui_holder.expression.children[1])\n    @classmethod\n    def quasiquote_evaluate(cls, expr: Expression, frame: Frame, gui_holder: Holder, splicing=False):",
        "detail": "lab.lab11.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Quasiquote",
        "kind": 6,
        "importPath": "lab.lab11.editor.special_forms",
        "description": "lab.lab11.editor.special_forms",
        "peekOfCode": "class Quasiquote(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        verify_exact_callable_length(self, 1, len(operands))\n        return Quasiquote.quasiquote_evaluate(operands[0], frame, gui_holder.expression.children[1])\n    @classmethod\n    def quasiquote_evaluate(cls, expr: Expression, frame: Frame, gui_holder: Holder, splicing=False):\n        is_well_formed = False\n        if isinstance(expr, Pair):\n            try:\n                lst = pair_to_list(expr)",
        "detail": "lab.lab11.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Load",
        "kind": 6,
        "importPath": "lab.lab11.editor.special_forms",
        "description": "lab.lab11.editor.special_forms",
        "peekOfCode": "class Load(Applicable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder, eval_operands=True):\n        verify_exact_callable_length(self, 1, len(operands))\n        if eval_operands:\n            operands = evaluate_all(operands, frame, gui_holder.expression.children[1:])\n        if not isinstance(operands[0], Symbol):\n            raise OperandDeduceError(f\"Load expected a Symbol, received {operands[0]}.\")\n        if logger.fragile:\n            raise IrreversibleOperationError()\n        try:",
        "detail": "lab.lab11.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "LoadAll",
        "kind": 6,
        "importPath": "lab.lab11.editor.special_forms",
        "description": "lab.lab11.editor.special_forms",
        "peekOfCode": "class LoadAll(Applicable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder, eval_operands=True):\n        verify_exact_callable_length(self, 1, len(operands))\n        if eval_operands:\n            operands = evaluate_all(operands, frame, gui_holder.expression.children[1:])\n        if not isinstance(operands[0], String):\n            raise OperandDeduceError(f\"Load expected a String, received {operands[0]}.\")\n        if logger.fragile:\n            raise IrreversibleOperationError()\n        from os import listdir",
        "detail": "lab.lab11.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "BeginNoExcept",
        "kind": 6,
        "importPath": "lab.lab11.editor.special_forms",
        "description": "lab.lab11.editor.special_forms",
        "peekOfCode": "class BeginNoExcept(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        out = Undefined\n        for i, (operand, holder) in enumerate(zip(operands, gui_holder.expression.children[1:])):\n            try:\n                out = evaluate(operand, frame, holder, i == len(operands) - 1)\n            except (SchemeError, RecursionError, ValueError, ZeroDivisionError) as e:\n                logger.raw_out(\"LoadError: \" + str(e) + \"\\n\")\n        return out\n@special_form(\"delay\")",
        "detail": "lab.lab11.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Delay",
        "kind": 6,
        "importPath": "lab.lab11.editor.special_forms",
        "description": "lab.lab11.editor.special_forms",
        "peekOfCode": "class Delay(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        verify_exact_callable_length(self, 1, len(operands))\n        return Promise(operands[0], frame)\n@global_attr(\"force\")\nclass Force(Applicable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder, eval_operands=True):\n        verify_exact_callable_length(self, 1, len(operands))\n        operand = operands[0]\n        if eval_operands:",
        "detail": "lab.lab11.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Force",
        "kind": 6,
        "importPath": "lab.lab11.editor.special_forms",
        "description": "lab.lab11.editor.special_forms",
        "peekOfCode": "class Force(Applicable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder, eval_operands=True):\n        verify_exact_callable_length(self, 1, len(operands))\n        operand = operands[0]\n        if eval_operands:\n            operand = evaluate_all(operands, frame, gui_holder.expression.children[1:])[0]\n        if not isinstance(operand, Promise):\n            raise OperandDeduceError(f\"Force expected a Promise, received {operand}\")\n        if operand.forced:\n            return operand.expr",
        "detail": "lab.lab11.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "ConsStream",
        "kind": 6,
        "importPath": "lab.lab11.editor.special_forms",
        "description": "lab.lab11.editor.special_forms",
        "peekOfCode": "class ConsStream(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        verify_exact_callable_length(self, 2, len(operands))\n        operands[0] = evaluate(operands[0], frame, gui_holder.expression.children[1])\n        return Pair(operands[0], Promise(operands[1], frame))\n@special_form(\"expect\")\nclass Expect(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        verify_exact_callable_length(self, 2, len(operands))\n        case = operands[0]",
        "detail": "lab.lab11.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Expect",
        "kind": 6,
        "importPath": "lab.lab11.editor.special_forms",
        "description": "lab.lab11.editor.special_forms",
        "peekOfCode": "class Expect(Callable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder):\n        verify_exact_callable_length(self, 2, len(operands))\n        case = operands[0]\n        operands[0] = evaluate(operands[0], frame, gui_holder.expression.children[1])\n        if not IsEqual().execute_evaluated(operands, frame).value:\n            log.logger.raw_out(f\"Evaluated {case}, expected {operands[1]}, got {operands[0]}.\\n\")\n        else:\n            log.logger.raw_out(f\"Evaluated {case}, got {operands[0]}, as expected.\\n\")\n        return Undefined",
        "detail": "lab.lab11.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "Error",
        "kind": 6,
        "importPath": "lab.lab11.editor.special_forms",
        "description": "lab.lab11.editor.special_forms",
        "peekOfCode": "class Error(Applicable):\n    def execute(self, operands: List[Expression], frame: Frame, gui_holder: Holder, eval_operands=True):\n        verify_exact_callable_length(self, 1, len(operands))\n        if eval_operands:\n            operands = evaluate_all(operands, frame, gui_holder.expression.children[1:])\n        raise SchemeError(operands[0])",
        "detail": "lab.lab11.editor.special_forms",
        "documentation": {}
    },
    {
        "label": "IsAtom",
        "kind": 6,
        "importPath": "lab.lab11.editor.type_checking",
        "description": "lab.lab11.editor.type_checking",
        "peekOfCode": "class IsAtom(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression):\n        return bools[isinstance(operand, Boolean) or isinstance(operand, Number)\n                     or isinstance(operand, Symbol) or operand is Nil]\n@global_attr(\"boolean?\")\nclass IsBoolean(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression):\n        return bools[isinstance(operand, Boolean)]\n@global_attr(\"integer?\")\nclass IsInteger(SingleOperandPrimitive):",
        "detail": "lab.lab11.editor.type_checking",
        "documentation": {}
    },
    {
        "label": "IsBoolean",
        "kind": 6,
        "importPath": "lab.lab11.editor.type_checking",
        "description": "lab.lab11.editor.type_checking",
        "peekOfCode": "class IsBoolean(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression):\n        return bools[isinstance(operand, Boolean)]\n@global_attr(\"integer?\")\nclass IsInteger(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression):\n        return bools[isinstance(operand, Number) and isinstance(operand.value, int)]\n@global_attr(\"list?\")\nclass IsList(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression):",
        "detail": "lab.lab11.editor.type_checking",
        "documentation": {}
    },
    {
        "label": "IsInteger",
        "kind": 6,
        "importPath": "lab.lab11.editor.type_checking",
        "description": "lab.lab11.editor.type_checking",
        "peekOfCode": "class IsInteger(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression):\n        return bools[isinstance(operand, Number) and isinstance(operand.value, int)]\n@global_attr(\"list?\")\nclass IsList(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression):\n        if isinstance(operand, Pair):\n            try:\n                pair_to_list(operand)\n                return SingletonTrue",
        "detail": "lab.lab11.editor.type_checking",
        "documentation": {}
    },
    {
        "label": "IsList",
        "kind": 6,
        "importPath": "lab.lab11.editor.type_checking",
        "description": "lab.lab11.editor.type_checking",
        "peekOfCode": "class IsList(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression):\n        if isinstance(operand, Pair):\n            try:\n                pair_to_list(operand)\n                return SingletonTrue\n            except OperandDeduceError:\n                return SingletonFalse\n        else:\n            return SingletonFalse",
        "detail": "lab.lab11.editor.type_checking",
        "documentation": {}
    },
    {
        "label": "IsNumber",
        "kind": 6,
        "importPath": "lab.lab11.editor.type_checking",
        "description": "lab.lab11.editor.type_checking",
        "peekOfCode": "class IsNumber(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        return bools[isinstance(operand, Number)]\n@global_attr(\"null?\")\nclass IsNull(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if operand is Nil:\n            return SingletonTrue\n        else:\n            return SingletonFalse",
        "detail": "lab.lab11.editor.type_checking",
        "documentation": {}
    },
    {
        "label": "IsNull",
        "kind": 6,
        "importPath": "lab.lab11.editor.type_checking",
        "description": "lab.lab11.editor.type_checking",
        "peekOfCode": "class IsNull(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        if operand is Nil:\n            return SingletonTrue\n        else:\n            return SingletonFalse\n@global_attr(\"pair?\")\nclass IsPair(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        return bools[isinstance(operand, Pair)]",
        "detail": "lab.lab11.editor.type_checking",
        "documentation": {}
    },
    {
        "label": "IsPair",
        "kind": 6,
        "importPath": "lab.lab11.editor.type_checking",
        "description": "lab.lab11.editor.type_checking",
        "peekOfCode": "class IsPair(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        return bools[isinstance(operand, Pair)]\n@global_attr(\"procedure?\")\nclass IsProcedure(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression):\n        return bools[isinstance(operand, LambdaObject) or\n                     isinstance(operand, MuObject) or\n                     isinstance(operand, MacroObject)]\n@global_attr(\"string?\")",
        "detail": "lab.lab11.editor.type_checking",
        "documentation": {}
    },
    {
        "label": "IsProcedure",
        "kind": 6,
        "importPath": "lab.lab11.editor.type_checking",
        "description": "lab.lab11.editor.type_checking",
        "peekOfCode": "class IsProcedure(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression):\n        return bools[isinstance(operand, LambdaObject) or\n                     isinstance(operand, MuObject) or\n                     isinstance(operand, MacroObject)]\n@global_attr(\"string?\")\nclass IsString(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        return bools[isinstance(operand, String)]\n@global_attr(\"symbol?\")",
        "detail": "lab.lab11.editor.type_checking",
        "documentation": {}
    },
    {
        "label": "IsString",
        "kind": 6,
        "importPath": "lab.lab11.editor.type_checking",
        "description": "lab.lab11.editor.type_checking",
        "peekOfCode": "class IsString(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        return bools[isinstance(operand, String)]\n@global_attr(\"symbol?\")\nclass IsSymbol(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        return bools[isinstance(operand, Symbol)]",
        "detail": "lab.lab11.editor.type_checking",
        "documentation": {}
    },
    {
        "label": "IsSymbol",
        "kind": 6,
        "importPath": "lab.lab11.editor.type_checking",
        "description": "lab.lab11.editor.type_checking",
        "peekOfCode": "class IsSymbol(SingleOperandPrimitive):\n    def execute_simple(self, operand: Expression) -> Expression:\n        return bools[isinstance(operand, Symbol)]",
        "detail": "lab.lab11.editor.type_checking",
        "documentation": {}
    },
    {
        "label": "AutoDraw",
        "kind": 6,
        "importPath": "lab.lab11.editor.visualizing",
        "description": "lab.lab11.editor.visualizing",
        "peekOfCode": "class AutoDraw(BuiltIn):\n        def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n            verify_exact_callable_length(self, 0, len(operands))\n            if log.logger.fragile:\n                raise IrreversibleOperationError()\n            log.logger.raw_out(\"Disable autodraw with (disable-autodraw).\\n\")\n            log.logger.raw_out(\"ENABLE_AUTODRAW[]\\n\")\n            return Undefined\n@global_attr(\"disable-autodraw\")\nclass DisableAutoDraw(BuiltIn):",
        "detail": "lab.lab11.editor.visualizing",
        "documentation": {}
    },
    {
        "label": "DisableAutoDraw",
        "kind": 6,
        "importPath": "lab.lab11.editor.visualizing",
        "description": "lab.lab11.editor.visualizing",
        "peekOfCode": "class DisableAutoDraw(BuiltIn):\n        def execute_evaluated(self, operands: List[Expression], frame: Frame) -> Expression:\n            verify_exact_callable_length(self, 0, len(operands))\n            if log.logger.fragile:\n                raise IrreversibleOperationError()\n            log.logger.raw_out(\"DISABLE_AUTODRAW[]\\n\")\n            return Undefined\n@global_attr(\"draw\")\nclass Draw(SingleOperandPrimitive):\n        def execute_simple(self, operand: Expression) -> Expression:",
        "detail": "lab.lab11.editor.visualizing",
        "documentation": {}
    },
    {
        "label": "Draw",
        "kind": 6,
        "importPath": "lab.lab11.editor.visualizing",
        "description": "lab.lab11.editor.visualizing",
        "peekOfCode": "class Draw(SingleOperandPrimitive):\n        def execute_simple(self, operand: Expression) -> Expression:\n            if log.logger.fragile:\n                raise IrreversibleOperationError()\n            log.logger.raw_out(\"DRAW\" +\n                               json.dumps([log.logger.i, log.logger.heap.record(operand)]) + \"\\n\")\n            return Undefined",
        "detail": "lab.lab11.editor.visualizing",
        "documentation": {}
    },
    {
        "label": "index",
        "kind": 2,
        "importPath": "lab.lab11.editor.web_server",
        "description": "lab.lab11.editor.web_server",
        "peekOfCode": "def index():\n    return render_template(\"index.html\", start_data=json.dumps({}))\n@app.route(\"/<code>\")\ndef lookup(code):\n    val = database.load(code)\n    if val is None:\n        return index()\n    return render_template(\"index.html\",\n                           start_data=repr(json.dumps({\"code\": eval(val[0]),\n                                                       \"skip_tree\": bool(val[1]),",
        "detail": "lab.lab11.editor.web_server",
        "documentation": {}
    },
    {
        "label": "lookup",
        "kind": 2,
        "importPath": "lab.lab11.editor.web_server",
        "description": "lab.lab11.editor.web_server",
        "peekOfCode": "def lookup(code):\n    val = database.load(code)\n    if val is None:\n        return index()\n    return render_template(\"index.html\",\n                           start_data=repr(json.dumps({\"code\": eval(val[0]),\n                                                       \"skip_tree\": bool(val[1]),\n                                                       \"hide_return_frames\": bool(val[2])})))\n@app.route(\"/process2\", methods=[\"POST\"])\ndef receive():",
        "detail": "lab.lab11.editor.web_server",
        "documentation": {}
    },
    {
        "label": "receive",
        "kind": 2,
        "importPath": "lab.lab11.editor.web_server",
        "description": "lab.lab11.editor.web_server",
        "peekOfCode": "def receive():\n    code = request.form.getlist(\"code[]\")\n    skip_tree = request.form.get(\"skip_tree\") == \"true\"\n    skip_envs = request.form.get(\"skip_envs\") == \"true\"\n    hide_return_frames = request.form.get(\"hide_return_frames\") == \"true\"\n    return handle(code, skip_tree, skip_envs, hide_return_frames)\ndef handle(code, skip_tree, skip_envs, hide_return_frames):\n    log.logger.setID(database.save(code, skip_tree, hide_return_frames))\n    log.logger.new_query(skip_tree, skip_envs, hide_return_frames)\n    try:",
        "detail": "lab.lab11.editor.web_server",
        "documentation": {}
    },
    {
        "label": "handle",
        "kind": 2,
        "importPath": "lab.lab11.editor.web_server",
        "description": "lab.lab11.editor.web_server",
        "peekOfCode": "def handle(code, skip_tree, skip_envs, hide_return_frames):\n    log.logger.setID(database.save(code, skip_tree, hide_return_frames))\n    log.logger.new_query(skip_tree, skip_envs, hide_return_frames)\n    try:\n        # execution.string_exec(code, gui.logger.out)\n        scheme_limiter(3, execution.string_exec, code, log.logger.out)\n    except SchemeError as e:\n        log.logger.out(e)\n    except TimeLimitException:\n        log.logger.out(\"Time limit exceeded. Try disabling the substitution visualizer (top checkbox) for increased \"",
        "detail": "lab.lab11.editor.web_server",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "lab.lab11.editor.web_server",
        "description": "lab.lab11.editor.web_server",
        "peekOfCode": "app = Flask(__name__)\n@app.route('/')\ndef index():\n    return render_template(\"index.html\", start_data=json.dumps({}))\n@app.route(\"/<code>\")\ndef lookup(code):\n    val = database.load(code)\n    if val is None:\n        return index()\n    return render_template(\"index.html\",",
        "detail": "lab.lab11.editor.web_server",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "lab.lab11.tests.if-program",
        "description": "lab.lab11.tests.if-program",
        "peekOfCode": "test = {\n  'name': 'if-program',\n  'points': 1,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          scm> (define expr (if-program '(= 0 0) '2 '3))\n          expr",
        "detail": "lab.lab11.tests.if-program",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "lab.lab11.tests.pow",
        "description": "lab.lab11.tests.pow",
        "peekOfCode": "test = {\n  'name': 'pow',\n  'points': 1,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          scm> (pow-expr 2 0)\n          1",
        "detail": "lab.lab11.tests.pow",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "lab.lab11.tests.repeat-lambda",
        "description": "lab.lab11.tests.repeat-lambda",
        "peekOfCode": "test = {\n  'name': 'repeat-lambda',\n  'points': 1,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          scm> (repeat (+ 2 3) (print 1))\n          1",
        "detail": "lab.lab11.tests.repeat-lambda",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "lab.lab11.tests.wwsd-quasiquote",
        "description": "lab.lab11.tests.wwsd-quasiquote",
        "peekOfCode": "test = {\n  'name': 'wwsd-quasiquote',\n  'points': 0,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          scm> '(1 x 3)\n          7026b4496459392f36b9a5b9dc64e31d",
        "detail": "lab.lab11.tests.wwsd-quasiquote",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "lab.lab12.tests.big",
        "description": "lab.lab12.tests.big",
        "peekOfCode": "test = {\n  'name': 'big',\n  'points': 1,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          sqlite> SELECT * FROM big;\n          61A",
        "detail": "lab.lab12.tests.big",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "lab.lab12.tests.pairs",
        "description": "lab.lab12.tests.pairs",
        "peekOfCode": "test = {\n  'name': 'pairs',\n  'points': 1,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          sqlite> SELECT * FROM pairs;\n          RSF and Wheeler together have 1600 seats",
        "detail": "lab.lab12.tests.pairs",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "lab.lab12.tests.remaining",
        "description": "lab.lab12.tests.remaining",
        "peekOfCode": "test = {\n  'name': 'remaining',\n  'points': 1,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          sqlite> SELECT * FROM remaining;\n          10|0",
        "detail": "lab.lab12.tests.remaining",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "lab.lab12.tests.sharing",
        "description": "lab.lab12.tests.sharing",
        "peekOfCode": "test = {\n  'name': 'sharing',\n  'points': 1,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          sqlite> SELECT * FROM sharing;\n          61A|3",
        "detail": "lab.lab12.tests.sharing",
        "documentation": {}
    },
    {
        "label": "WindowsConsoleIOMixin",
        "kind": 6,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "class WindowsConsoleIOMixin(object):\n\t# Ctrl+C handling with ReadFile() is messed up on Windows starting on Windows 8... here's some background reading:\n\t#   https://stackoverflow.com/a/43260436\n\t#   https://github.com/microsoft/terminal/issues/334\n\t# We use ReadConsole when we can, so it doesn't affect us, but it's good info to know regardless.\n\tdef __init__(self, fd):\n\t\tassert isatty(fd), \"file descriptor must refer to a console (note that on Windows, NUL satisfies isatty(), but is not a console)\"\n\t\tself.fd = fd\n\t\tself.handle = msvcrt.get_osfhandle(fd)\n\tdef fileno(self): return self.fd",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "WindowsConsoleRawIO",
        "kind": 6,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "class WindowsConsoleRawIO(WindowsConsoleIOMixin, io.RawIOBase):\n\tdef readinto(self, b):\n\t\twordsize = ctypes.sizeof(ctypes.c_wchar)\n\t\treturn self.readwcharsinto(getbuffer(b, True), len(b) // wordsize) * wordsize\n\tdef write(self, b):\n\t\twordsize = ctypes.sizeof(ctypes.c_wchar)\n\t\treturn self.writewchars(getbuffer(b, False), len(b) // wordsize) * wordsize\nclass WindowsConsoleTextIO(WindowsConsoleIOMixin, io.TextIOBase):\n\tbuf = None\n\tbuffered = unicode()",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "WindowsConsoleTextIO",
        "kind": 6,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "class WindowsConsoleTextIO(WindowsConsoleIOMixin, io.TextIOBase):\n\tbuf = None\n\tbuffered = unicode()\n\ttranslate = True\n\tdef getbuf(self, ncodeunits):\n\t\tbuf = self.buf\n\t\tif buf is None or len(buf) < ncodeunits:\n\t\t\tself.buf = buf = ctypes.create_unicode_buffer(ncodeunits)\n\t\treturn buf\n\t@staticmethod  # Don't let classes override this... they can override the caller instead",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "NonOwningTextIOWrapper",
        "kind": 6,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "class NonOwningTextIOWrapper(io.TextIOWrapper):\n\tdef __init__(self, base_textiowrapper, **kwargs):\n\t\tassert isinstance(base_textiowrapper, io.TextIOWrapper)\n\t\tself.base = base_textiowrapper  # must keep a reference to this alive so it doesn't get closed\n\t\tsuper(NonOwningTextIOWrapper, self).__init__(base_textiowrapper.buffer, **kwargs)\n\tdef close(self):\n\t\tsuper(NonOwningTextIOWrapper, self).flush()\ndef wrap_unicode_stdio(stream, is_writer, encoding):  # The underlying stream must NOT be used directly until the stream returned by this function is disposed of\n\tif isinstance(stream, io.TextIOWrapper):\n\t\tstream.flush()  # Make sure nothing is left in the buffer before we re-wrap it",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "StringEscapeParser",
        "kind": 6,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "class StringEscapeParser(object):\n\tdef __init__(self):\n\t\timport re\n\t\tself.pattern = re.compile(\"\\\"((?:[^\\\"\\\\n]+|\\\\\\\\.)*)(?:\\\"|$)|\\'([^\\'\\\\n]*)(?:\\'|$)|(\\\\S+)\")\n\t\tself.escape_pattern = re.compile(\"\\\\\\\\(.)\", re.DOTALL)\n\t@staticmethod\n\tdef escape_replacement(m):\n\t\ttext = m.group(1)\n\t\tif text == \"\\\\\": text = \"\\\\\"\n\t\telif text == \"/\": text = \"\\n\"",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "Database",
        "kind": 6,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "class Database(object):\n\tdef __init__(self, name, *args, **kwargs):\n\t\tself.connection = sqlite3.connect(name, *args, **kwargs)\n\t\tself.cursor = self.connection.cursor()\n\t\tself.name = name  # assign name only AFTER cursor is created\ndef isatty(file_or_fd):\n\tresult = True\n\tmethod = getattr(file_or_fd, 'isatty', None) if not isinstance(file_or_fd, int) else None  # this check is just an optimization\n\tif method is not None:\n\t\ttry: tty = method()",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "StdIOProxy",
        "kind": 6,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "class StdIOProxy(object):\n\t# Maybe useful later: codecs.StreamRecoder(bytesIO, codec.decode, codec.encode, codec.streamwriter, codec.streamreader, errors='surrogateescape')\n\tdef __init__(self, stdin, stdout, stderr, codec, allow_set_code_page):\n\t\tself.codec = codec\n\t\tstreams = (stdin, stdout, stderr)\n\t\tfor stream in streams:\n\t\t\tassert isinstance(stream, io.IOBase) or sys.version_info[0] < 3 and isinstance(stream, file) or hasattr(stream, 'mode'), \"unable to determine stream type\"\n\t\t\tassert not isinstance(stream, io.RawIOBase), \"RAW I/O APIs are different and not supported\"\n\t\tself.streaminfos = tuple(map(lambda stream:\n\t\t\t(",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "bytes_comparable_with_unicode",
        "kind": 6,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "class bytes_comparable_with_unicode(bytes):  # For Python 2/3 compatibility, to allow implicit conversion between strings and bytes when it is safe. (Used for strings like literals which we know be safe.)\n\tcodec = codecs.lookup('ascii')  # MUST be a safe encoding\n\t@classmethod\n\tdef coerce(cls, other, for_output=False):\n\t\treturn cls.codec.encode(other)[0] if not isinstance(other, bytes) else bytes_comparable_with_unicode(other) if for_output else other\n\t@classmethod\n\tdef translate_if_bytes(cls, value):\n\t\tif value is not None and isinstance(value, bytes): value = cls(value)\n\t\treturn value\n\tdef __hash__(self): return super(bytes_comparable_with_unicode, self).__hash__()  # To avoid warning",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "exception_encode",
        "kind": 2,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "def exception_encode(ex, codec):\n\tif str == bytes:\n\t\treduced = ex.__reduce__()\n\t\tex = reduced[0](*tuple(map(lambda arg: codec.decode(arg)[0] if isinstance(arg, bytes) else arg, reduced[1])))\n\treturn ex\ndef sql_commands(read_line):\n\tdelims = ['\"', \"'\", ';', '--']\n\tcounter = 0\n\tin_string = None\n\tj = i = 0",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "sql_commands",
        "kind": 2,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "def sql_commands(read_line):\n\tdelims = ['\"', \"'\", ';', '--']\n\tcounter = 0\n\tin_string = None\n\tj = i = 0\n\tprev_line = None\n\tline = None\n\tconcat = []\n\twhile True:\n\t\tif line is None:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "wrap_windows_console_io",
        "kind": 2,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "def wrap_windows_console_io(stream, is_output):\n\tfd = None\n\tif stream is not None and sys.version_info[0] < 3 and msvcrt and (is_output or pythonapi) and isatty(stream):\n\t\ttry: fd = stream.fileno()\n\t\texcept io.UnsupportedOperation: pass\n\tresult = stream\n\tif fd is not None:\n\t\tf = GetConsoleOutputCP if is_output else GetConsoleCP\n\t\tif not f or f() != CP_UTF8:\n\t\t\ttry:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "wrap_unicode_stdio",
        "kind": 2,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "def wrap_unicode_stdio(stream, is_writer, encoding):  # The underlying stream must NOT be used directly until the stream returned by this function is disposed of\n\tif isinstance(stream, io.TextIOWrapper):\n\t\tstream.flush()  # Make sure nothing is left in the buffer before we re-wrap it\n\t\tnone = object()\n\t\tkwargs = {}\n\t\tfor key in ['encoding', 'errors', 'newline', 'line_buffering', 'write_through']:\n\t\t\tvalue = getattr(stream, 'newlines' if key == 'newline' else key, none)\n\t\t\tif value is not none:\n\t\t\t\tkwargs[key] = value\n\t\tkwargs['encoding'] = encoding",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "isatty",
        "kind": 2,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "def isatty(file_or_fd):\n\tresult = True\n\tmethod = getattr(file_or_fd, 'isatty', None) if not isinstance(file_or_fd, int) else None  # this check is just an optimization\n\tif method is not None:\n\t\ttry: tty = method()\n\t\texcept io.UnsupportedOperation: tty = None\n\t\tresult = result and tty is not None and tty\n\tmethod = getattr(file_or_fd, 'fileno', None) if not isinstance(file_or_fd, int) else None  # this check is just an optimization\n\tif method is not None:\n\t\ttry: fd = method()",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "can_call_input_for_stdio",
        "kind": 2,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "def can_call_input_for_stdio(stream):\n\treturn stream == sys.stdin and sys.version_info[0] >= 3\nclass StdIOProxy(object):\n\t# Maybe useful later: codecs.StreamRecoder(bytesIO, codec.decode, codec.encode, codec.streamwriter, codec.streamreader, errors='surrogateescape')\n\tdef __init__(self, stdin, stdout, stderr, codec, allow_set_code_page):\n\t\tself.codec = codec\n\t\tstreams = (stdin, stdout, stderr)\n\t\tfor stream in streams:\n\t\t\tassert isinstance(stream, io.IOBase) or sys.version_info[0] < 3 and isinstance(stream, file) or hasattr(stream, 'mode'), \"unable to determine stream type\"\n\t\t\tassert not isinstance(stream, io.RawIOBase), \"RAW I/O APIs are different and not supported\"",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "wrap_bytes_comparable_with_unicode_readline",
        "kind": 2,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "def wrap_bytes_comparable_with_unicode_readline(readline):\n\tdef callback(*args):\n\t\tline = readline(*args)\n\t\tline = bytes_comparable_with_unicode.translate_if_bytes(line)\n\t\treturn line\n\treturn callback\ndef main(program, *args, **kwargs):  # **kwargs = dict(stdin=file, stdout=file, stderr=file); useful for callers who import this module\n\timport argparse  # slow import (compiles regexes etc.), so don't import it until needed\n\targparser = argparse.ArgumentParser(\n\t\tprog=os.path.basename(program),",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "def main(program, *args, **kwargs):  # **kwargs = dict(stdin=file, stdout=file, stderr=file); useful for callers who import this module\n\timport argparse  # slow import (compiles regexes etc.), so don't import it until needed\n\targparser = argparse.ArgumentParser(\n\t\tprog=os.path.basename(program),\n\t\tusage=None,\n\t\tdescription=None,\n\t\tepilog=None,\n\t\tparents=[],\n\t\tformatter_class=argparse.RawTextHelpFormatter)\n\targparser.add_argument('-version', '--version', action='store_true', help=\"show SQLite version\")",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "call_program",
        "kind": 2,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "def call_program(cmdline, input_text):\n\timport subprocess\n\treturn subprocess.Popen(cmdline, bufsize=0, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=False).communicate(input_text)\ndef test_query():\n\thexcodec = codecs.lookup('hex_codec')\n\tascii = 'ascii'\n\tdata1 = b\"\\xD8\\xA2\"\n\tdata2 = b\"\\x01\\x02\\xFF\\x01\\xFF\\xFE\\xFD\"\n\tvalues = [data1, data2]\n\tquery_bytes = b'SELECT %s;' % (b\", \".join(map(lambda b: b\"X'%s'\" % (hexcodec.encode(b)[0].upper(),), values)),)",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "test_query",
        "kind": 2,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "def test_query():\n\thexcodec = codecs.lookup('hex_codec')\n\tascii = 'ascii'\n\tdata1 = b\"\\xD8\\xA2\"\n\tdata2 = b\"\\x01\\x02\\xFF\\x01\\xFF\\xFE\\xFD\"\n\tvalues = [data1, data2]\n\tquery_bytes = b'SELECT %s;' % (b\", \".join(map(lambda b: b\"X'%s'\" % (hexcodec.encode(b)[0].upper(),), values)),)\n\texpected_bytes = b\"%s\\n\" % (b\"|\".join(values),)\n\treturn query_bytes, expected_bytes\ndef cross_test(sqlite_cmdline, codec):",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "cross_test",
        "kind": 2,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "def cross_test(sqlite_cmdline, codec):\n\t(query_bytes, expected_bytes) = test_query()\n\t(official_output, official_error) = call_program(sqlite_cmdline, query_bytes)\n\t# We can't use os.linesep here since binaries may belong to different platforms (Win32/MinGW vs. MSYS/Cygwin vs. WSL...)\n\tofficial_output = official_output.replace(b\"\\r\\n\", b\"\\n\")\n\tofficial_error = official_error.replace(b\"\\r\\n\", b\"\\n\")\n\tif official_output != expected_bytes:\n\t\traise sqlite3.ProgrammingError(\"expected bytes are wrong: official %s != expected %s\" % (repr(official_output), repr(expected_bytes)))\n\tif official_error:\n\t\traise sqlite3.ProgrammingError(\"did not expect errors from official binary\")",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "self_test",
        "kind": 2,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "def self_test(codec):\n\t(query_bytes, expected_bytes) = test_query()\n\tif not (lambda stdin, stdout, stderr: not main(sys.argv[0], stdin=stdin, stdout=stdout, stderr=stderr) and stdout.getvalue() == expected_bytes)(io.BytesIO(query_bytes), io.BytesIO(), io.BytesIO()):\n\t\traise sqlite3.ProgrammingError(\"byte I/O is broken\")\n\tif not (lambda stdin, stdout, stderr: not main(sys.argv[0], stdin=stdin, stdout=stdout, stderr=stderr) and stdout.getvalue() == codec.decode(expected_bytes, 'surrogateescape'))(io.StringIO(query_bytes.decode(ascii)), io.StringIO(), io.StringIO()):\n\t\traise sqlite3.ProgrammingError(\"string I/O is broken\")\nif __name__ == '__main__':\n\timport sys\n\texit_code = main(*sys.argv)\n\tif exit_code not in (None, 0): raise SystemExit(exit_code)",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "CP_UTF8",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "CP_UTF8 = 65001\npythonapi = None\nif msvcrt:\n\timport ctypes\n\t(BOOL, DWORD, HANDLE, UINT) = (ctypes.c_long, ctypes.c_ulong, ctypes.c_void_p, ctypes.c_uint)\n\tGetConsoleCP = ctypes.WINFUNCTYPE(UINT)(('GetConsoleCP', ctypes.windll.kernel32))\n\tSetConsoleCP = ctypes.WINFUNCTYPE(BOOL, UINT)(('SetConsoleCP', ctypes.windll.kernel32))\n\tGetConsoleOutputCP = ctypes.WINFUNCTYPE(UINT)(('GetConsoleOutputCP', ctypes.windll.kernel32))\n\tSetConsoleOutputCP = ctypes.WINFUNCTYPE(BOOL, UINT)(('SetConsoleOutputCP', ctypes.windll.kernel32))\n\tGetConsoleMode = ctypes.WINFUNCTYPE(BOOL, HANDLE, ctypes.POINTER(DWORD), use_last_error=True)(('GetConsoleMode', ctypes.windll.kernel32))",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "pythonapi",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "pythonapi = None\nif msvcrt:\n\timport ctypes\n\t(BOOL, DWORD, HANDLE, UINT) = (ctypes.c_long, ctypes.c_ulong, ctypes.c_void_p, ctypes.c_uint)\n\tGetConsoleCP = ctypes.WINFUNCTYPE(UINT)(('GetConsoleCP', ctypes.windll.kernel32))\n\tSetConsoleCP = ctypes.WINFUNCTYPE(BOOL, UINT)(('SetConsoleCP', ctypes.windll.kernel32))\n\tGetConsoleOutputCP = ctypes.WINFUNCTYPE(UINT)(('GetConsoleOutputCP', ctypes.windll.kernel32))\n\tSetConsoleOutputCP = ctypes.WINFUNCTYPE(BOOL, UINT)(('SetConsoleOutputCP', ctypes.windll.kernel32))\n\tGetConsoleMode = ctypes.WINFUNCTYPE(BOOL, HANDLE, ctypes.POINTER(DWORD), use_last_error=True)(('GetConsoleMode', ctypes.windll.kernel32))\n\tGetNumberOfConsoleInputEvents = ctypes.WINFUNCTYPE(BOOL, HANDLE, ctypes.POINTER(DWORD), use_last_error=True)(('GetNumberOfConsoleInputEvents', ctypes.windll.kernel32))",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tGetConsoleCP",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tGetConsoleCP = ctypes.WINFUNCTYPE(UINT)(('GetConsoleCP', ctypes.windll.kernel32))\n\tSetConsoleCP = ctypes.WINFUNCTYPE(BOOL, UINT)(('SetConsoleCP', ctypes.windll.kernel32))\n\tGetConsoleOutputCP = ctypes.WINFUNCTYPE(UINT)(('GetConsoleOutputCP', ctypes.windll.kernel32))\n\tSetConsoleOutputCP = ctypes.WINFUNCTYPE(BOOL, UINT)(('SetConsoleOutputCP', ctypes.windll.kernel32))\n\tGetConsoleMode = ctypes.WINFUNCTYPE(BOOL, HANDLE, ctypes.POINTER(DWORD), use_last_error=True)(('GetConsoleMode', ctypes.windll.kernel32))\n\tGetNumberOfConsoleInputEvents = ctypes.WINFUNCTYPE(BOOL, HANDLE, ctypes.POINTER(DWORD), use_last_error=True)(('GetNumberOfConsoleInputEvents', ctypes.windll.kernel32))\n\tReadConsoleW = ctypes.WINFUNCTYPE(BOOL, HANDLE, ctypes.c_void_p, DWORD, ctypes.POINTER(DWORD), ctypes.c_void_p, use_last_error=True)(('ReadConsoleW', ctypes.windll.kernel32))\n\tWriteConsoleW = ctypes.WINFUNCTYPE(BOOL, HANDLE, ctypes.c_void_p, DWORD, ctypes.POINTER(DWORD), ctypes.c_void_p, use_last_error=True)(('WriteConsoleW', ctypes.windll.kernel32))\n\tclass Py_buffer(ctypes.Structure): _fields_ = [('buf', ctypes.c_void_p), ('obj', ctypes.py_object), ('len', ctypes.c_ssize_t), ('itemsize', ctypes.c_ssize_t), ('readonly', ctypes.c_int), ('ndim', ctypes.c_int), ('format', ctypes.c_char_p), ('shape', ctypes.POINTER(ctypes.c_ssize_t)), ('strides', ctypes.POINTER(ctypes.c_ssize_t)), ('suboffsets', ctypes.POINTER(ctypes.c_ssize_t))] + ([('smalltable', ctypes.c_ssize_t * 2)] if sys.version_info[0] <= 2 else []) + [('internal', ctypes.c_void_p)]\n\ttry: from ctypes import pythonapi",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tSetConsoleCP",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tSetConsoleCP = ctypes.WINFUNCTYPE(BOOL, UINT)(('SetConsoleCP', ctypes.windll.kernel32))\n\tGetConsoleOutputCP = ctypes.WINFUNCTYPE(UINT)(('GetConsoleOutputCP', ctypes.windll.kernel32))\n\tSetConsoleOutputCP = ctypes.WINFUNCTYPE(BOOL, UINT)(('SetConsoleOutputCP', ctypes.windll.kernel32))\n\tGetConsoleMode = ctypes.WINFUNCTYPE(BOOL, HANDLE, ctypes.POINTER(DWORD), use_last_error=True)(('GetConsoleMode', ctypes.windll.kernel32))\n\tGetNumberOfConsoleInputEvents = ctypes.WINFUNCTYPE(BOOL, HANDLE, ctypes.POINTER(DWORD), use_last_error=True)(('GetNumberOfConsoleInputEvents', ctypes.windll.kernel32))\n\tReadConsoleW = ctypes.WINFUNCTYPE(BOOL, HANDLE, ctypes.c_void_p, DWORD, ctypes.POINTER(DWORD), ctypes.c_void_p, use_last_error=True)(('ReadConsoleW', ctypes.windll.kernel32))\n\tWriteConsoleW = ctypes.WINFUNCTYPE(BOOL, HANDLE, ctypes.c_void_p, DWORD, ctypes.POINTER(DWORD), ctypes.c_void_p, use_last_error=True)(('WriteConsoleW', ctypes.windll.kernel32))\n\tclass Py_buffer(ctypes.Structure): _fields_ = [('buf', ctypes.c_void_p), ('obj', ctypes.py_object), ('len', ctypes.c_ssize_t), ('itemsize', ctypes.c_ssize_t), ('readonly', ctypes.c_int), ('ndim', ctypes.c_int), ('format', ctypes.c_char_p), ('shape', ctypes.POINTER(ctypes.c_ssize_t)), ('strides', ctypes.POINTER(ctypes.c_ssize_t)), ('suboffsets', ctypes.POINTER(ctypes.c_ssize_t))] + ([('smalltable', ctypes.c_ssize_t * 2)] if sys.version_info[0] <= 2 else []) + [('internal', ctypes.c_void_p)]\n\ttry: from ctypes import pythonapi\n\texcept ImportError: pass",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tGetConsoleOutputCP",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tGetConsoleOutputCP = ctypes.WINFUNCTYPE(UINT)(('GetConsoleOutputCP', ctypes.windll.kernel32))\n\tSetConsoleOutputCP = ctypes.WINFUNCTYPE(BOOL, UINT)(('SetConsoleOutputCP', ctypes.windll.kernel32))\n\tGetConsoleMode = ctypes.WINFUNCTYPE(BOOL, HANDLE, ctypes.POINTER(DWORD), use_last_error=True)(('GetConsoleMode', ctypes.windll.kernel32))\n\tGetNumberOfConsoleInputEvents = ctypes.WINFUNCTYPE(BOOL, HANDLE, ctypes.POINTER(DWORD), use_last_error=True)(('GetNumberOfConsoleInputEvents', ctypes.windll.kernel32))\n\tReadConsoleW = ctypes.WINFUNCTYPE(BOOL, HANDLE, ctypes.c_void_p, DWORD, ctypes.POINTER(DWORD), ctypes.c_void_p, use_last_error=True)(('ReadConsoleW', ctypes.windll.kernel32))\n\tWriteConsoleW = ctypes.WINFUNCTYPE(BOOL, HANDLE, ctypes.c_void_p, DWORD, ctypes.POINTER(DWORD), ctypes.c_void_p, use_last_error=True)(('WriteConsoleW', ctypes.windll.kernel32))\n\tclass Py_buffer(ctypes.Structure): _fields_ = [('buf', ctypes.c_void_p), ('obj', ctypes.py_object), ('len', ctypes.c_ssize_t), ('itemsize', ctypes.c_ssize_t), ('readonly', ctypes.c_int), ('ndim', ctypes.c_int), ('format', ctypes.c_char_p), ('shape', ctypes.POINTER(ctypes.c_ssize_t)), ('strides', ctypes.POINTER(ctypes.c_ssize_t)), ('suboffsets', ctypes.POINTER(ctypes.c_ssize_t))] + ([('smalltable', ctypes.c_ssize_t * 2)] if sys.version_info[0] <= 2 else []) + [('internal', ctypes.c_void_p)]\n\ttry: from ctypes import pythonapi\n\texcept ImportError: pass\nif pythonapi:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tSetConsoleOutputCP",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tSetConsoleOutputCP = ctypes.WINFUNCTYPE(BOOL, UINT)(('SetConsoleOutputCP', ctypes.windll.kernel32))\n\tGetConsoleMode = ctypes.WINFUNCTYPE(BOOL, HANDLE, ctypes.POINTER(DWORD), use_last_error=True)(('GetConsoleMode', ctypes.windll.kernel32))\n\tGetNumberOfConsoleInputEvents = ctypes.WINFUNCTYPE(BOOL, HANDLE, ctypes.POINTER(DWORD), use_last_error=True)(('GetNumberOfConsoleInputEvents', ctypes.windll.kernel32))\n\tReadConsoleW = ctypes.WINFUNCTYPE(BOOL, HANDLE, ctypes.c_void_p, DWORD, ctypes.POINTER(DWORD), ctypes.c_void_p, use_last_error=True)(('ReadConsoleW', ctypes.windll.kernel32))\n\tWriteConsoleW = ctypes.WINFUNCTYPE(BOOL, HANDLE, ctypes.c_void_p, DWORD, ctypes.POINTER(DWORD), ctypes.c_void_p, use_last_error=True)(('WriteConsoleW', ctypes.windll.kernel32))\n\tclass Py_buffer(ctypes.Structure): _fields_ = [('buf', ctypes.c_void_p), ('obj', ctypes.py_object), ('len', ctypes.c_ssize_t), ('itemsize', ctypes.c_ssize_t), ('readonly', ctypes.c_int), ('ndim', ctypes.c_int), ('format', ctypes.c_char_p), ('shape', ctypes.POINTER(ctypes.c_ssize_t)), ('strides', ctypes.POINTER(ctypes.c_ssize_t)), ('suboffsets', ctypes.POINTER(ctypes.c_ssize_t))] + ([('smalltable', ctypes.c_ssize_t * 2)] if sys.version_info[0] <= 2 else []) + [('internal', ctypes.c_void_p)]\n\ttry: from ctypes import pythonapi\n\texcept ImportError: pass\nif pythonapi:\n\tdef getbuffer(b, writable):",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tGetConsoleMode",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tGetConsoleMode = ctypes.WINFUNCTYPE(BOOL, HANDLE, ctypes.POINTER(DWORD), use_last_error=True)(('GetConsoleMode', ctypes.windll.kernel32))\n\tGetNumberOfConsoleInputEvents = ctypes.WINFUNCTYPE(BOOL, HANDLE, ctypes.POINTER(DWORD), use_last_error=True)(('GetNumberOfConsoleInputEvents', ctypes.windll.kernel32))\n\tReadConsoleW = ctypes.WINFUNCTYPE(BOOL, HANDLE, ctypes.c_void_p, DWORD, ctypes.POINTER(DWORD), ctypes.c_void_p, use_last_error=True)(('ReadConsoleW', ctypes.windll.kernel32))\n\tWriteConsoleW = ctypes.WINFUNCTYPE(BOOL, HANDLE, ctypes.c_void_p, DWORD, ctypes.POINTER(DWORD), ctypes.c_void_p, use_last_error=True)(('WriteConsoleW', ctypes.windll.kernel32))\n\tclass Py_buffer(ctypes.Structure): _fields_ = [('buf', ctypes.c_void_p), ('obj', ctypes.py_object), ('len', ctypes.c_ssize_t), ('itemsize', ctypes.c_ssize_t), ('readonly', ctypes.c_int), ('ndim', ctypes.c_int), ('format', ctypes.c_char_p), ('shape', ctypes.POINTER(ctypes.c_ssize_t)), ('strides', ctypes.POINTER(ctypes.c_ssize_t)), ('suboffsets', ctypes.POINTER(ctypes.c_ssize_t))] + ([('smalltable', ctypes.c_ssize_t * 2)] if sys.version_info[0] <= 2 else []) + [('internal', ctypes.c_void_p)]\n\ttry: from ctypes import pythonapi\n\texcept ImportError: pass\nif pythonapi:\n\tdef getbuffer(b, writable):\n\t\tarr = Py_buffer()",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tGetNumberOfConsoleInputEvents",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tGetNumberOfConsoleInputEvents = ctypes.WINFUNCTYPE(BOOL, HANDLE, ctypes.POINTER(DWORD), use_last_error=True)(('GetNumberOfConsoleInputEvents', ctypes.windll.kernel32))\n\tReadConsoleW = ctypes.WINFUNCTYPE(BOOL, HANDLE, ctypes.c_void_p, DWORD, ctypes.POINTER(DWORD), ctypes.c_void_p, use_last_error=True)(('ReadConsoleW', ctypes.windll.kernel32))\n\tWriteConsoleW = ctypes.WINFUNCTYPE(BOOL, HANDLE, ctypes.c_void_p, DWORD, ctypes.POINTER(DWORD), ctypes.c_void_p, use_last_error=True)(('WriteConsoleW', ctypes.windll.kernel32))\n\tclass Py_buffer(ctypes.Structure): _fields_ = [('buf', ctypes.c_void_p), ('obj', ctypes.py_object), ('len', ctypes.c_ssize_t), ('itemsize', ctypes.c_ssize_t), ('readonly', ctypes.c_int), ('ndim', ctypes.c_int), ('format', ctypes.c_char_p), ('shape', ctypes.POINTER(ctypes.c_ssize_t)), ('strides', ctypes.POINTER(ctypes.c_ssize_t)), ('suboffsets', ctypes.POINTER(ctypes.c_ssize_t))] + ([('smalltable', ctypes.c_ssize_t * 2)] if sys.version_info[0] <= 2 else []) + [('internal', ctypes.c_void_p)]\n\ttry: from ctypes import pythonapi\n\texcept ImportError: pass\nif pythonapi:\n\tdef getbuffer(b, writable):\n\t\tarr = Py_buffer()\n\t\tpythonapi.PyObject_GetBuffer(ctypes.py_object(b), ctypes.byref(arr), ctypes.c_int(writable))",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tReadConsoleW",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tReadConsoleW = ctypes.WINFUNCTYPE(BOOL, HANDLE, ctypes.c_void_p, DWORD, ctypes.POINTER(DWORD), ctypes.c_void_p, use_last_error=True)(('ReadConsoleW', ctypes.windll.kernel32))\n\tWriteConsoleW = ctypes.WINFUNCTYPE(BOOL, HANDLE, ctypes.c_void_p, DWORD, ctypes.POINTER(DWORD), ctypes.c_void_p, use_last_error=True)(('WriteConsoleW', ctypes.windll.kernel32))\n\tclass Py_buffer(ctypes.Structure): _fields_ = [('buf', ctypes.c_void_p), ('obj', ctypes.py_object), ('len', ctypes.c_ssize_t), ('itemsize', ctypes.c_ssize_t), ('readonly', ctypes.c_int), ('ndim', ctypes.c_int), ('format', ctypes.c_char_p), ('shape', ctypes.POINTER(ctypes.c_ssize_t)), ('strides', ctypes.POINTER(ctypes.c_ssize_t)), ('suboffsets', ctypes.POINTER(ctypes.c_ssize_t))] + ([('smalltable', ctypes.c_ssize_t * 2)] if sys.version_info[0] <= 2 else []) + [('internal', ctypes.c_void_p)]\n\ttry: from ctypes import pythonapi\n\texcept ImportError: pass\nif pythonapi:\n\tdef getbuffer(b, writable):\n\t\tarr = Py_buffer()\n\t\tpythonapi.PyObject_GetBuffer(ctypes.py_object(b), ctypes.byref(arr), ctypes.c_int(writable))\n\t\ttry: buf = (ctypes.c_ubyte * arr.len).from_address(arr.buf)",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tWriteConsoleW",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tWriteConsoleW = ctypes.WINFUNCTYPE(BOOL, HANDLE, ctypes.c_void_p, DWORD, ctypes.POINTER(DWORD), ctypes.c_void_p, use_last_error=True)(('WriteConsoleW', ctypes.windll.kernel32))\n\tclass Py_buffer(ctypes.Structure): _fields_ = [('buf', ctypes.c_void_p), ('obj', ctypes.py_object), ('len', ctypes.c_ssize_t), ('itemsize', ctypes.c_ssize_t), ('readonly', ctypes.c_int), ('ndim', ctypes.c_int), ('format', ctypes.c_char_p), ('shape', ctypes.POINTER(ctypes.c_ssize_t)), ('strides', ctypes.POINTER(ctypes.c_ssize_t)), ('suboffsets', ctypes.POINTER(ctypes.c_ssize_t))] + ([('smalltable', ctypes.c_ssize_t * 2)] if sys.version_info[0] <= 2 else []) + [('internal', ctypes.c_void_p)]\n\ttry: from ctypes import pythonapi\n\texcept ImportError: pass\nif pythonapi:\n\tdef getbuffer(b, writable):\n\t\tarr = Py_buffer()\n\t\tpythonapi.PyObject_GetBuffer(ctypes.py_object(b), ctypes.byref(arr), ctypes.c_int(writable))\n\t\ttry: buf = (ctypes.c_ubyte * arr.len).from_address(arr.buf)\n\t\tfinally: pythonapi.PyBuffer_Release(ctypes.byref(arr))",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tarr",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tarr = Py_buffer()\n\t\tpythonapi.PyObject_GetBuffer(ctypes.py_object(b), ctypes.byref(arr), ctypes.c_int(writable))\n\t\ttry: buf = (ctypes.c_ubyte * arr.len).from_address(arr.buf)\n\t\tfinally: pythonapi.PyBuffer_Release(ctypes.byref(arr))\n\t\treturn buf\nENCODING = 'utf-8'\nif sys.version_info[0] < 3:\n\tclass NotASurrogateError(Exception): pass\n\tdef surrogateescape_handler(exc):\n\t\t# Source: https://github.com/PythonCharmers/python-future/blob/aef57391c0cd58bf840dff5e2bc2c8c0f5b0a1b4/src/future/utils/surrogateescape.py",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "ENCODING",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "ENCODING = 'utf-8'\nif sys.version_info[0] < 3:\n\tclass NotASurrogateError(Exception): pass\n\tdef surrogateescape_handler(exc):\n\t\t# Source: https://github.com/PythonCharmers/python-future/blob/aef57391c0cd58bf840dff5e2bc2c8c0f5b0a1b4/src/future/utils/surrogateescape.py\n\t\tmystring = exc.object[exc.start:exc.end]\n\t\ttry:\n\t\t\tif isinstance(exc, UnicodeDecodeError):\n\t\t\t\tdecoded = []\n\t\t\t\tfor ch in mystring:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tmystring",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tmystring = exc.object[exc.start:exc.end]\n\t\ttry:\n\t\t\tif isinstance(exc, UnicodeDecodeError):\n\t\t\t\tdecoded = []\n\t\t\t\tfor ch in mystring:\n\t\t\t\t\tif isinstance(ch, int):\n\t\t\t\t\t\tcode = ch\n\t\t\t\t\telse:\n\t\t\t\t\t\tcode = ord(ch)\n\t\t\t\t\tif 0x80 <= code <= 0xFF:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tdecoded",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\tdecoded = []\n\t\t\t\tfor ch in mystring:\n\t\t\t\t\tif isinstance(ch, int):\n\t\t\t\t\t\tcode = ch\n\t\t\t\t\telse:\n\t\t\t\t\t\tcode = ord(ch)\n\t\t\t\t\tif 0x80 <= code <= 0xFF:\n\t\t\t\t\t\tdecoded.append(unichr(0xDC00 + code))\n\t\t\t\t\telif code <= 0x7F:\n\t\t\t\t\t\tdecoded.append(unichr(code))",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\tcode",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\t\t\tcode = ch\n\t\t\t\t\telse:\n\t\t\t\t\t\tcode = ord(ch)\n\t\t\t\t\tif 0x80 <= code <= 0xFF:\n\t\t\t\t\t\tdecoded.append(unichr(0xDC00 + code))\n\t\t\t\t\telif code <= 0x7F:\n\t\t\t\t\t\tdecoded.append(unichr(code))\n\t\t\t\t\telse:\n\t\t\t\t\t\traise NotASurrogateError()\n\t\t\t\tdecoded = str().join(decoded)",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\tcode",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\t\t\tcode = ord(ch)\n\t\t\t\t\tif 0x80 <= code <= 0xFF:\n\t\t\t\t\t\tdecoded.append(unichr(0xDC00 + code))\n\t\t\t\t\telif code <= 0x7F:\n\t\t\t\t\t\tdecoded.append(unichr(code))\n\t\t\t\t\telse:\n\t\t\t\t\t\traise NotASurrogateError()\n\t\t\t\tdecoded = str().join(decoded)\n\t\t\telif isinstance(exc, UnicodeEncodeError):\n\t\t\t\tdecoded = []",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tdecoded",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\tdecoded = str().join(decoded)\n\t\t\telif isinstance(exc, UnicodeEncodeError):\n\t\t\t\tdecoded = []\n\t\t\t\tfor ch in mystring:\n\t\t\t\t\tcode = ord(ch)\n\t\t\t\t\tif not 0xD800 <= code <= 0xDCFF:\n\t\t\t\t\t\traise NotASurrogateError()\n\t\t\t\t\tif 0xDC00 <= code <= 0xDC7F:\n\t\t\t\t\t\tdecoded.append(unichr(code - 0xDC00))\n\t\t\t\t\telif code <= 0xDCFF:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tdecoded",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\tdecoded = []\n\t\t\t\tfor ch in mystring:\n\t\t\t\t\tcode = ord(ch)\n\t\t\t\t\tif not 0xD800 <= code <= 0xDCFF:\n\t\t\t\t\t\traise NotASurrogateError()\n\t\t\t\t\tif 0xDC00 <= code <= 0xDC7F:\n\t\t\t\t\t\tdecoded.append(unichr(code - 0xDC00))\n\t\t\t\t\telif code <= 0xDCFF:\n\t\t\t\t\t\tdecoded.append(unichr(code - 0xDC00))\n\t\t\t\t\telse:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tcode",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\t\tcode = ord(ch)\n\t\t\t\t\tif not 0xD800 <= code <= 0xDCFF:\n\t\t\t\t\t\traise NotASurrogateError()\n\t\t\t\t\tif 0xDC00 <= code <= 0xDC7F:\n\t\t\t\t\t\tdecoded.append(unichr(code - 0xDC00))\n\t\t\t\t\telif code <= 0xDCFF:\n\t\t\t\t\t\tdecoded.append(unichr(code - 0xDC00))\n\t\t\t\t\telse:\n\t\t\t\t\t\traise NotASurrogateError()\n\t\t\t\tdecoded = str().join(decoded)",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tdecoded",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\tdecoded = str().join(decoded)\n\t\t\telse:\n\t\t\t\traise exc\n\t\texcept NotASurrogateError:\n\t\t\traise exc\n\t\treturn (decoded, exc.end)\n\tcodecs.register_error('surrogateescape', surrogateescape_handler)\ndef exception_encode(ex, codec):\n\tif str == bytes:\n\t\treduced = ex.__reduce__()",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\treduced",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\treduced = ex.__reduce__()\n\t\tex = reduced[0](*tuple(map(lambda arg: codec.decode(arg)[0] if isinstance(arg, bytes) else arg, reduced[1])))\n\treturn ex\ndef sql_commands(read_line):\n\tdelims = ['\"', \"'\", ';', '--']\n\tcounter = 0\n\tin_string = None\n\tj = i = 0\n\tprev_line = None\n\tline = None",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tex",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tex = reduced[0](*tuple(map(lambda arg: codec.decode(arg)[0] if isinstance(arg, bytes) else arg, reduced[1])))\n\treturn ex\ndef sql_commands(read_line):\n\tdelims = ['\"', \"'\", ';', '--']\n\tcounter = 0\n\tin_string = None\n\tj = i = 0\n\tprev_line = None\n\tline = None\n\tconcat = []",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tdelims",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tdelims = ['\"', \"'\", ';', '--']\n\tcounter = 0\n\tin_string = None\n\tj = i = 0\n\tprev_line = None\n\tline = None\n\tconcat = []\n\twhile True:\n\t\tif line is None:\n\t\t\twhile True:  # process preprocessor directives",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tcounter",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tcounter = 0\n\tin_string = None\n\tj = i = 0\n\tprev_line = None\n\tline = None\n\tconcat = []\n\twhile True:\n\t\tif line is None:\n\t\t\twhile True:  # process preprocessor directives\n\t\t\t\tcounter += 1",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tin_string",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tin_string = None\n\tj = i = 0\n\tprev_line = None\n\tline = None\n\tconcat = []\n\twhile True:\n\t\tif line is None:\n\t\t\twhile True:  # process preprocessor directives\n\t\t\t\tcounter += 1\n\t\t\t\tnot_in_the_middle_of_any_input = not in_string and i == j and all(map(lambda chunk_: len(chunk_) == 0, concat))",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tj",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tj = i = 0\n\tprev_line = None\n\tline = None\n\tconcat = []\n\twhile True:\n\t\tif line is None:\n\t\t\twhile True:  # process preprocessor directives\n\t\t\t\tcounter += 1\n\t\t\t\tnot_in_the_middle_of_any_input = not in_string and i == j and all(map(lambda chunk_: len(chunk_) == 0, concat))\n\t\t\t\tline = read_line(counter - 1, not_in_the_middle_of_any_input, prev_line)",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tprev_line",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tprev_line = None\n\tline = None\n\tconcat = []\n\twhile True:\n\t\tif line is None:\n\t\t\twhile True:  # process preprocessor directives\n\t\t\t\tcounter += 1\n\t\t\t\tnot_in_the_middle_of_any_input = not in_string and i == j and all(map(lambda chunk_: len(chunk_) == 0, concat))\n\t\t\t\tline = read_line(counter - 1, not_in_the_middle_of_any_input, prev_line)\n\t\t\t\tempty_string = line[:0] if line is not None else line",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tline",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tline = None\n\tconcat = []\n\twhile True:\n\t\tif line is None:\n\t\t\twhile True:  # process preprocessor directives\n\t\t\t\tcounter += 1\n\t\t\t\tnot_in_the_middle_of_any_input = not in_string and i == j and all(map(lambda chunk_: len(chunk_) == 0, concat))\n\t\t\t\tline = read_line(counter - 1, not_in_the_middle_of_any_input, prev_line)\n\t\t\t\tempty_string = line[:0] if line is not None else line\n\t\t\t\tprev_line = line",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tconcat",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tconcat = []\n\twhile True:\n\t\tif line is None:\n\t\t\twhile True:  # process preprocessor directives\n\t\t\t\tcounter += 1\n\t\t\t\tnot_in_the_middle_of_any_input = not in_string and i == j and all(map(lambda chunk_: len(chunk_) == 0, concat))\n\t\t\t\tline = read_line(counter - 1, not_in_the_middle_of_any_input, prev_line)\n\t\t\t\tempty_string = line[:0] if line is not None else line\n\t\t\t\tprev_line = line\n\t\t\t\tif not line:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tnot_in_the_middle_of_any_input",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\tnot_in_the_middle_of_any_input = not in_string and i == j and all(map(lambda chunk_: len(chunk_) == 0, concat))\n\t\t\t\tline = read_line(counter - 1, not_in_the_middle_of_any_input, prev_line)\n\t\t\t\tempty_string = line[:0] if line is not None else line\n\t\t\t\tprev_line = line\n\t\t\t\tif not line:\n\t\t\t\t\tbreak\n\t\t\t\tif not_in_the_middle_of_any_input and line.startswith(\".\"):\n\t\t\t\t\tyield line\n\t\t\t\t\tline = None\n\t\t\t\telse:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tline",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\tline = read_line(counter - 1, not_in_the_middle_of_any_input, prev_line)\n\t\t\t\tempty_string = line[:0] if line is not None else line\n\t\t\t\tprev_line = line\n\t\t\t\tif not line:\n\t\t\t\t\tbreak\n\t\t\t\tif not_in_the_middle_of_any_input and line.startswith(\".\"):\n\t\t\t\t\tyield line\n\t\t\t\t\tline = None\n\t\t\t\telse:\n\t\t\t\t\tbreak",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tempty_string",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\tempty_string = line[:0] if line is not None else line\n\t\t\t\tprev_line = line\n\t\t\t\tif not line:\n\t\t\t\t\tbreak\n\t\t\t\tif not_in_the_middle_of_any_input and line.startswith(\".\"):\n\t\t\t\t\tyield line\n\t\t\t\t\tline = None\n\t\t\t\telse:\n\t\t\t\t\tbreak\n\t\t\tif not line:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tprev_line",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\tprev_line = line\n\t\t\t\tif not line:\n\t\t\t\t\tbreak\n\t\t\t\tif not_in_the_middle_of_any_input and line.startswith(\".\"):\n\t\t\t\t\tyield line\n\t\t\t\t\tline = None\n\t\t\t\telse:\n\t\t\t\t\tbreak\n\t\t\tif not line:\n\t\t\t\tbreak",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tline",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\t\tline = None\n\t\t\t\telse:\n\t\t\t\t\tbreak\n\t\t\tif not line:\n\t\t\t\tbreak\n\t\t\tj = i = 0\n\t\tif j < len(line):\n\t\t\t(j, delim) = min(map(lambda pair: pair if pair[0] >= 0 else (len(line), pair[1]), map(lambda d: (line.find(d, j), d), in_string or delims if in_string != '--' else \"\\n\")))\n\t\t\tif i < j: concat.append(line[i:j]); i = j\n\t\t\tif not in_string:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\tj",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\tj = i = 0\n\t\tif j < len(line):\n\t\t\t(j, delim) = min(map(lambda pair: pair if pair[0] >= 0 else (len(line), pair[1]), map(lambda d: (line.find(d, j), d), in_string or delims if in_string != '--' else \"\\n\")))\n\t\t\tif i < j: concat.append(line[i:j]); i = j\n\t\t\tif not in_string:\n\t\t\t\tif j < len(line):\n\t\t\t\t\tj += len(delim)\n\t\t\t\t\tif delim == ';':\n\t\t\t\t\t\ti = j\n\t\t\t\t\t\tconcat.append(line[j : j + len(delim)])    # ensure delimeter is the same type as the string (it may not be due to implicit conversion)",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\ti",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\t\t\ti = j\n\t\t\t\t\t\tconcat.append(line[j : j + len(delim)])    # ensure delimeter is the same type as the string (it may not be due to implicit conversion)\n\t\t\t\t\t\t# Eat up any further spaces until a newline\n\t\t\t\t\t\twhile j < len(line):\n\t\t\t\t\t\t\tdelim = line[j:j+1]\n\t\t\t\t\t\t\tif not delim.isspace(): break\n\t\t\t\t\t\t\tj += 1\n\t\t\t\t\t\t\tif delim == \"\\n\": break\n\t\t\t\t\t\tif i < j: concat.append(line[i:j]); i = j\n\t\t\t\t\t\tyield empty_string.join(concat)",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\t\tdelim",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\t\t\t\tdelim = line[j:j+1]\n\t\t\t\t\t\t\tif not delim.isspace(): break\n\t\t\t\t\t\t\tj += 1\n\t\t\t\t\t\t\tif delim == \"\\n\": break\n\t\t\t\t\t\tif i < j: concat.append(line[i:j]); i = j\n\t\t\t\t\t\tyield empty_string.join(concat)\n\t\t\t\t\t\tdel concat[:]\n\t\t\t\t\telse:\n\t\t\t\t\t\tin_string = delim\n\t\t\telse:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\tin_string",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\t\t\tin_string = delim\n\t\t\telse:\n\t\t\t\tif j < len(line):\n\t\t\t\t\tch = line[j:j+1]\n\t\t\t\t\tassert ch == in_string or in_string == '--'\n\t\t\t\t\tj += 1\n\t\t\t\t\ti = j\n\t\t\t\t\tconcat.append(ch)\n\t\t\t\t\tin_string = None\n\t\telse:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tch",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\t\tch = line[j:j+1]\n\t\t\t\t\tassert ch == in_string or in_string == '--'\n\t\t\t\t\tj += 1\n\t\t\t\t\ti = j\n\t\t\t\t\tconcat.append(ch)\n\t\t\t\t\tin_string = None\n\t\telse:\n\t\t\tif i < j: concat.append(line[i:j]); i = j\n\t\t\tline = None\nclass WindowsConsoleIOMixin(object):",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\ti",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\t\ti = j\n\t\t\t\t\tconcat.append(ch)\n\t\t\t\t\tin_string = None\n\t\telse:\n\t\t\tif i < j: concat.append(line[i:j]); i = j\n\t\t\tline = None\nclass WindowsConsoleIOMixin(object):\n\t# Ctrl+C handling with ReadFile() is messed up on Windows starting on Windows 8... here's some background reading:\n\t#   https://stackoverflow.com/a/43260436\n\t#   https://github.com/microsoft/terminal/issues/334",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tin_string",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\t\tin_string = None\n\t\telse:\n\t\t\tif i < j: concat.append(line[i:j]); i = j\n\t\t\tline = None\nclass WindowsConsoleIOMixin(object):\n\t# Ctrl+C handling with ReadFile() is messed up on Windows starting on Windows 8... here's some background reading:\n\t#   https://stackoverflow.com/a/43260436\n\t#   https://github.com/microsoft/terminal/issues/334\n\t# We use ReadConsole when we can, so it doesn't affect us, but it's good info to know regardless.\n\tdef __init__(self, fd):",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\tline",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\tline = None\nclass WindowsConsoleIOMixin(object):\n\t# Ctrl+C handling with ReadFile() is messed up on Windows starting on Windows 8... here's some background reading:\n\t#   https://stackoverflow.com/a/43260436\n\t#   https://github.com/microsoft/terminal/issues/334\n\t# We use ReadConsole when we can, so it doesn't affect us, but it's good info to know regardless.\n\tdef __init__(self, fd):\n\t\tassert isatty(fd), \"file descriptor must refer to a console (note that on Windows, NUL satisfies isatty(), but is not a console)\"\n\t\tself.fd = fd\n\t\tself.handle = msvcrt.get_osfhandle(fd)",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tself.fd",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tself.fd = fd\n\t\tself.handle = msvcrt.get_osfhandle(fd)\n\tdef fileno(self): return self.fd\n\tdef isatty(self): return isatty(self.fd)\n\tdef seekable(self): return False\n\tdef readable(self): return GetNumberOfConsoleInputEvents(self.handle, ctypes.byref(DWORD(0))) != 0\n\tdef writable(self): n = DWORD(0); return WriteConsoleW(self.handle, ctypes.c_void_p(), n, ctypes.byref(n), ctypes.c_void_p()) != 0\n\tdef readwcharsinto(self, buf, n):\n\t\tnr = DWORD(n)\n\t\told_error = ctypes.get_last_error()",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tself.handle",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tself.handle = msvcrt.get_osfhandle(fd)\n\tdef fileno(self): return self.fd\n\tdef isatty(self): return isatty(self.fd)\n\tdef seekable(self): return False\n\tdef readable(self): return GetNumberOfConsoleInputEvents(self.handle, ctypes.byref(DWORD(0))) != 0\n\tdef writable(self): n = DWORD(0); return WriteConsoleW(self.handle, ctypes.c_void_p(), n, ctypes.byref(n), ctypes.c_void_p()) != 0\n\tdef readwcharsinto(self, buf, n):\n\t\tnr = DWORD(n)\n\t\told_error = ctypes.get_last_error()\n\t\tctypes.set_last_error(0)",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tnr",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tnr = DWORD(n)\n\t\told_error = ctypes.get_last_error()\n\t\tctypes.set_last_error(0)\n\t\tsuccess = ReadConsoleW(self.handle, buf, nr, ctypes.byref(nr), ctypes.c_void_p())\n\t\terror = ctypes.get_last_error()\n\t\tctypes.set_last_error(old_error)\n\t\tif not success: raise ctypes.WinError(error)\n\t\tERROR_OPERATION_ABORTED = 995\n\t\tif nr.value == 0 and error == ERROR_OPERATION_ABORTED:\n\t\t\t# Apparently this can trigger pending KeyboardInterrupts?",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\told_error",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\told_error = ctypes.get_last_error()\n\t\tctypes.set_last_error(0)\n\t\tsuccess = ReadConsoleW(self.handle, buf, nr, ctypes.byref(nr), ctypes.c_void_p())\n\t\terror = ctypes.get_last_error()\n\t\tctypes.set_last_error(old_error)\n\t\tif not success: raise ctypes.WinError(error)\n\t\tERROR_OPERATION_ABORTED = 995\n\t\tif nr.value == 0 and error == ERROR_OPERATION_ABORTED:\n\t\t\t# Apparently this can trigger pending KeyboardInterrupts?\n\t\t\ttime.sleep(1.0 / (1 << 64))",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tsuccess",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tsuccess = ReadConsoleW(self.handle, buf, nr, ctypes.byref(nr), ctypes.c_void_p())\n\t\terror = ctypes.get_last_error()\n\t\tctypes.set_last_error(old_error)\n\t\tif not success: raise ctypes.WinError(error)\n\t\tERROR_OPERATION_ABORTED = 995\n\t\tif nr.value == 0 and error == ERROR_OPERATION_ABORTED:\n\t\t\t# Apparently this can trigger pending KeyboardInterrupts?\n\t\t\ttime.sleep(1.0 / (1 << 64))\n\t\t\traise KeyboardInterrupt()  # If Python doesn't raise it, we can\n\t\treturn nr.value",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\terror",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\terror = ctypes.get_last_error()\n\t\tctypes.set_last_error(old_error)\n\t\tif not success: raise ctypes.WinError(error)\n\t\tERROR_OPERATION_ABORTED = 995\n\t\tif nr.value == 0 and error == ERROR_OPERATION_ABORTED:\n\t\t\t# Apparently this can trigger pending KeyboardInterrupts?\n\t\t\ttime.sleep(1.0 / (1 << 64))\n\t\t\traise KeyboardInterrupt()  # If Python doesn't raise it, we can\n\t\treturn nr.value\n\tdef writewchars(self, buf, n):",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tERROR_OPERATION_ABORTED",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tERROR_OPERATION_ABORTED = 995\n\t\tif nr.value == 0 and error == ERROR_OPERATION_ABORTED:\n\t\t\t# Apparently this can trigger pending KeyboardInterrupts?\n\t\t\ttime.sleep(1.0 / (1 << 64))\n\t\t\traise KeyboardInterrupt()  # If Python doesn't raise it, we can\n\t\treturn nr.value\n\tdef writewchars(self, buf, n):\n\t\tnw = DWORD(n)\n\t\tif not WriteConsoleW(self.handle, buf, nw, ctypes.byref(nw), ctypes.c_void_p()):\n\t\t\traise ctypes.WinError()",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tnw",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tnw = DWORD(n)\n\t\tif not WriteConsoleW(self.handle, buf, nw, ctypes.byref(nw), ctypes.c_void_p()):\n\t\t\traise ctypes.WinError()\n\t\treturn nw.value\nclass WindowsConsoleRawIO(WindowsConsoleIOMixin, io.RawIOBase):\n\tdef readinto(self, b):\n\t\twordsize = ctypes.sizeof(ctypes.c_wchar)\n\t\treturn self.readwcharsinto(getbuffer(b, True), len(b) // wordsize) * wordsize\n\tdef write(self, b):\n\t\twordsize = ctypes.sizeof(ctypes.c_wchar)",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\twordsize",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\twordsize = ctypes.sizeof(ctypes.c_wchar)\n\t\treturn self.readwcharsinto(getbuffer(b, True), len(b) // wordsize) * wordsize\n\tdef write(self, b):\n\t\twordsize = ctypes.sizeof(ctypes.c_wchar)\n\t\treturn self.writewchars(getbuffer(b, False), len(b) // wordsize) * wordsize\nclass WindowsConsoleTextIO(WindowsConsoleIOMixin, io.TextIOBase):\n\tbuf = None\n\tbuffered = unicode()\n\ttranslate = True\n\tdef getbuf(self, ncodeunits):",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\twordsize",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\twordsize = ctypes.sizeof(ctypes.c_wchar)\n\t\treturn self.writewchars(getbuffer(b, False), len(b) // wordsize) * wordsize\nclass WindowsConsoleTextIO(WindowsConsoleIOMixin, io.TextIOBase):\n\tbuf = None\n\tbuffered = unicode()\n\ttranslate = True\n\tdef getbuf(self, ncodeunits):\n\t\tbuf = self.buf\n\t\tif buf is None or len(buf) < ncodeunits:\n\t\t\tself.buf = buf = ctypes.create_unicode_buffer(ncodeunits)",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tbuf",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tbuf = None\n\tbuffered = unicode()\n\ttranslate = True\n\tdef getbuf(self, ncodeunits):\n\t\tbuf = self.buf\n\t\tif buf is None or len(buf) < ncodeunits:\n\t\t\tself.buf = buf = ctypes.create_unicode_buffer(ncodeunits)\n\t\treturn buf\n\t@staticmethod  # Don't let classes override this... they can override the caller instead\n\tdef do_read(self, nchars, translate_newlines):",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tbuffered",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tbuffered = unicode()\n\ttranslate = True\n\tdef getbuf(self, ncodeunits):\n\t\tbuf = self.buf\n\t\tif buf is None or len(buf) < ncodeunits:\n\t\t\tself.buf = buf = ctypes.create_unicode_buffer(ncodeunits)\n\t\treturn buf\n\t@staticmethod  # Don't let classes override this... they can override the caller instead\n\tdef do_read(self, nchars, translate_newlines):\n\t\tprenewline = os.linesep[:-1]",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\ttranslate",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\ttranslate = True\n\tdef getbuf(self, ncodeunits):\n\t\tbuf = self.buf\n\t\tif buf is None or len(buf) < ncodeunits:\n\t\t\tself.buf = buf = ctypes.create_unicode_buffer(ncodeunits)\n\t\treturn buf\n\t@staticmethod  # Don't let classes override this... they can override the caller instead\n\tdef do_read(self, nchars, translate_newlines):\n\t\tprenewline = os.linesep[:-1]\n\t\tnewline = os.linesep[-1:]",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tbuf",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tbuf = self.buf\n\t\tif buf is None or len(buf) < ncodeunits:\n\t\t\tself.buf = buf = ctypes.create_unicode_buffer(ncodeunits)\n\t\treturn buf\n\t@staticmethod  # Don't let classes override this... they can override the caller instead\n\tdef do_read(self, nchars, translate_newlines):\n\t\tprenewline = os.linesep[:-1]\n\t\tnewline = os.linesep[-1:]\n\t\tempty = os.linesep[:0]\n\t\tif nchars is None or nchars < -1: nchars = -1",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\tself.buf",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\tself.buf = buf = ctypes.create_unicode_buffer(ncodeunits)\n\t\treturn buf\n\t@staticmethod  # Don't let classes override this... they can override the caller instead\n\tdef do_read(self, nchars, translate_newlines):\n\t\tprenewline = os.linesep[:-1]\n\t\tnewline = os.linesep[-1:]\n\t\tempty = os.linesep[:0]\n\t\tif nchars is None or nchars < -1: nchars = -1\n\t\tncodeunits = nchars if nchars >= 0 else io.DEFAULT_BUFFER_SIZE  # Unit mismatch, but doesn't matter; we'll loop\n\t\tbuf = None",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tprenewline",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tprenewline = os.linesep[:-1]\n\t\tnewline = os.linesep[-1:]\n\t\tempty = os.linesep[:0]\n\t\tif nchars is None or nchars < -1: nchars = -1\n\t\tncodeunits = nchars if nchars >= 0 else io.DEFAULT_BUFFER_SIZE  # Unit mismatch, but doesn't matter; we'll loop\n\t\tbuf = None\n\t\tistart = 0\n\t\twhile True:\n\t\t\tiend = self.buffered.find(newline, istart, min(istart + nchars, len(self.buffered)) if nchars >= 0 else None) if newline is not None else nchars\n\t\t\tif iend >= 0: iend += len(newline) if newline is not None else 0",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tnewline",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tnewline = os.linesep[-1:]\n\t\tempty = os.linesep[:0]\n\t\tif nchars is None or nchars < -1: nchars = -1\n\t\tncodeunits = nchars if nchars >= 0 else io.DEFAULT_BUFFER_SIZE  # Unit mismatch, but doesn't matter; we'll loop\n\t\tbuf = None\n\t\tistart = 0\n\t\twhile True:\n\t\t\tiend = self.buffered.find(newline, istart, min(istart + nchars, len(self.buffered)) if nchars >= 0 else None) if newline is not None else nchars\n\t\t\tif iend >= 0: iend += len(newline) if newline is not None else 0\n\t\t\tif 0 <= iend <= len(self.buffered):",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tempty",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tempty = os.linesep[:0]\n\t\tif nchars is None or nchars < -1: nchars = -1\n\t\tncodeunits = nchars if nchars >= 0 else io.DEFAULT_BUFFER_SIZE  # Unit mismatch, but doesn't matter; we'll loop\n\t\tbuf = None\n\t\tistart = 0\n\t\twhile True:\n\t\t\tiend = self.buffered.find(newline, istart, min(istart + nchars, len(self.buffered)) if nchars >= 0 else None) if newline is not None else nchars\n\t\t\tif iend >= 0: iend += len(newline) if newline is not None else 0\n\t\t\tif 0 <= iend <= len(self.buffered):\n\t\t\t\tbreak",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tncodeunits",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tncodeunits = nchars if nchars >= 0 else io.DEFAULT_BUFFER_SIZE  # Unit mismatch, but doesn't matter; we'll loop\n\t\tbuf = None\n\t\tistart = 0\n\t\twhile True:\n\t\t\tiend = self.buffered.find(newline, istart, min(istart + nchars, len(self.buffered)) if nchars >= 0 else None) if newline is not None else nchars\n\t\t\tif iend >= 0: iend += len(newline) if newline is not None else 0\n\t\t\tif 0 <= iend <= len(self.buffered):\n\t\t\t\tbreak\n\t\t\tif buf is None: buf = self.getbuf(ncodeunits)\n\t\t\tistart = len(self.buffered)",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tbuf",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tbuf = None\n\t\tistart = 0\n\t\twhile True:\n\t\t\tiend = self.buffered.find(newline, istart, min(istart + nchars, len(self.buffered)) if nchars >= 0 else None) if newline is not None else nchars\n\t\t\tif iend >= 0: iend += len(newline) if newline is not None else 0\n\t\t\tif 0 <= iend <= len(self.buffered):\n\t\t\t\tbreak\n\t\t\tif buf is None: buf = self.getbuf(ncodeunits)\n\t\t\tistart = len(self.buffered)\n\t\t\tchunk = buf[:self.readwcharsinto(buf, ncodeunits)]",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tistart",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tistart = 0\n\t\twhile True:\n\t\t\tiend = self.buffered.find(newline, istart, min(istart + nchars, len(self.buffered)) if nchars >= 0 else None) if newline is not None else nchars\n\t\t\tif iend >= 0: iend += len(newline) if newline is not None else 0\n\t\t\tif 0 <= iend <= len(self.buffered):\n\t\t\t\tbreak\n\t\t\tif buf is None: buf = self.getbuf(ncodeunits)\n\t\t\tistart = len(self.buffered)\n\t\t\tchunk = buf[:self.readwcharsinto(buf, ncodeunits)]\n\t\t\tif translate_newlines: chunk = chunk.replace(prenewline, empty)",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\tiend",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\tiend = self.buffered.find(newline, istart, min(istart + nchars, len(self.buffered)) if nchars >= 0 else None) if newline is not None else nchars\n\t\t\tif iend >= 0: iend += len(newline) if newline is not None else 0\n\t\t\tif 0 <= iend <= len(self.buffered):\n\t\t\t\tbreak\n\t\t\tif buf is None: buf = self.getbuf(ncodeunits)\n\t\t\tistart = len(self.buffered)\n\t\t\tchunk = buf[:self.readwcharsinto(buf, ncodeunits)]\n\t\t\tif translate_newlines: chunk = chunk.replace(prenewline, empty)\n\t\t\tif chunk.startswith('\\x1A'):  # EOF on Windows (Ctrl+Z) at the beginning of a line results in the entire rest of the buffer being discarded\n\t\t\t\tiend = istart",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\tistart",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\tistart = len(self.buffered)\n\t\t\tchunk = buf[:self.readwcharsinto(buf, ncodeunits)]\n\t\t\tif translate_newlines: chunk = chunk.replace(prenewline, empty)\n\t\t\tif chunk.startswith('\\x1A'):  # EOF on Windows (Ctrl+Z) at the beginning of a line results in the entire rest of the buffer being discarded\n\t\t\t\tiend = istart\n\t\t\t\tbreak\n\t\t\t# Python 2 and Python 3 behaviors differ on Windows... Python 2's sys.stdin.readline() just deletes the next character if it sees EOF in the middle of a string! I won't emulate that here.\n\t\t\tself.buffered += chunk  # We're relying on Python's concatenation optimization here... we don't do it ourselves, since we want self.buffered to be valid every iteration in case there is an exception raised\n\t\tresult = self.buffered[:iend]\n\t\tself.buffered = self.buffered[iend:]",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\tchunk",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\tchunk = buf[:self.readwcharsinto(buf, ncodeunits)]\n\t\t\tif translate_newlines: chunk = chunk.replace(prenewline, empty)\n\t\t\tif chunk.startswith('\\x1A'):  # EOF on Windows (Ctrl+Z) at the beginning of a line results in the entire rest of the buffer being discarded\n\t\t\t\tiend = istart\n\t\t\t\tbreak\n\t\t\t# Python 2 and Python 3 behaviors differ on Windows... Python 2's sys.stdin.readline() just deletes the next character if it sees EOF in the middle of a string! I won't emulate that here.\n\t\t\tself.buffered += chunk  # We're relying on Python's concatenation optimization here... we don't do it ourselves, since we want self.buffered to be valid every iteration in case there is an exception raised\n\t\tresult = self.buffered[:iend]\n\t\tself.buffered = self.buffered[iend:]\n\t\treturn result",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tiend",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\tiend = istart\n\t\t\t\tbreak\n\t\t\t# Python 2 and Python 3 behaviors differ on Windows... Python 2's sys.stdin.readline() just deletes the next character if it sees EOF in the middle of a string! I won't emulate that here.\n\t\t\tself.buffered += chunk  # We're relying on Python's concatenation optimization here... we don't do it ourselves, since we want self.buffered to be valid every iteration in case there is an exception raised\n\t\tresult = self.buffered[:iend]\n\t\tself.buffered = self.buffered[iend:]\n\t\treturn result\n\tdef read(self, nchars=-1): return WindowsConsoleTextIO.do_read(self, nchars, None, self.translate)\n\tdef readline(self, nchars=-1): return WindowsConsoleTextIO.do_read(self, nchars, self.translate)\n\tdef write(self, text): buf = ctypes.create_unicode_buffer(text); return self.writewchars(buf, max(len(buf) - 1, 0))",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tresult",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tresult = self.buffered[:iend]\n\t\tself.buffered = self.buffered[iend:]\n\t\treturn result\n\tdef read(self, nchars=-1): return WindowsConsoleTextIO.do_read(self, nchars, None, self.translate)\n\tdef readline(self, nchars=-1): return WindowsConsoleTextIO.do_read(self, nchars, self.translate)\n\tdef write(self, text): buf = ctypes.create_unicode_buffer(text); return self.writewchars(buf, max(len(buf) - 1, 0))\ndef wrap_windows_console_io(stream, is_output):\n\tfd = None\n\tif stream is not None and sys.version_info[0] < 3 and msvcrt and (is_output or pythonapi) and isatty(stream):\n\t\ttry: fd = stream.fileno()",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tself.buffered",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tself.buffered = self.buffered[iend:]\n\t\treturn result\n\tdef read(self, nchars=-1): return WindowsConsoleTextIO.do_read(self, nchars, None, self.translate)\n\tdef readline(self, nchars=-1): return WindowsConsoleTextIO.do_read(self, nchars, self.translate)\n\tdef write(self, text): buf = ctypes.create_unicode_buffer(text); return self.writewchars(buf, max(len(buf) - 1, 0))\ndef wrap_windows_console_io(stream, is_output):\n\tfd = None\n\tif stream is not None and sys.version_info[0] < 3 and msvcrt and (is_output or pythonapi) and isatty(stream):\n\t\ttry: fd = stream.fileno()\n\t\texcept io.UnsupportedOperation: pass",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tfd",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tfd = None\n\tif stream is not None and sys.version_info[0] < 3 and msvcrt and (is_output or pythonapi) and isatty(stream):\n\t\ttry: fd = stream.fileno()\n\t\texcept io.UnsupportedOperation: pass\n\tresult = stream\n\tif fd is not None:\n\t\tf = GetConsoleOutputCP if is_output else GetConsoleCP\n\t\tif not f or f() != CP_UTF8:\n\t\t\ttry:\n\t\t\t\tif True or is_output:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tresult",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tresult = stream\n\tif fd is not None:\n\t\tf = GetConsoleOutputCP if is_output else GetConsoleCP\n\t\tif not f or f() != CP_UTF8:\n\t\t\ttry:\n\t\t\t\tif True or is_output:\n\t\t\t\t\tresult = WindowsConsoleTextIO(fd)\n\t\t\t\telse:\n\t\t\t\t\tresult = io.TextIOWrapper((io.BufferedWriter if is_output else io.BufferedReader)(WindowsConsoleRawIO(fd)), 'utf-16-le', 'strict', line_buffering=True)\n\t\t\texcept IOError: pass",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tf",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tf = GetConsoleOutputCP if is_output else GetConsoleCP\n\t\tif not f or f() != CP_UTF8:\n\t\t\ttry:\n\t\t\t\tif True or is_output:\n\t\t\t\t\tresult = WindowsConsoleTextIO(fd)\n\t\t\t\telse:\n\t\t\t\t\tresult = io.TextIOWrapper((io.BufferedWriter if is_output else io.BufferedReader)(WindowsConsoleRawIO(fd)), 'utf-16-le', 'strict', line_buffering=True)\n\t\t\texcept IOError: pass\n\treturn result\nclass NonOwningTextIOWrapper(io.TextIOWrapper):",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tresult",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\t\tresult = WindowsConsoleTextIO(fd)\n\t\t\t\telse:\n\t\t\t\t\tresult = io.TextIOWrapper((io.BufferedWriter if is_output else io.BufferedReader)(WindowsConsoleRawIO(fd)), 'utf-16-le', 'strict', line_buffering=True)\n\t\t\texcept IOError: pass\n\treturn result\nclass NonOwningTextIOWrapper(io.TextIOWrapper):\n\tdef __init__(self, base_textiowrapper, **kwargs):\n\t\tassert isinstance(base_textiowrapper, io.TextIOWrapper)\n\t\tself.base = base_textiowrapper  # must keep a reference to this alive so it doesn't get closed\n\t\tsuper(NonOwningTextIOWrapper, self).__init__(base_textiowrapper.buffer, **kwargs)",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tresult",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\t\tresult = io.TextIOWrapper((io.BufferedWriter if is_output else io.BufferedReader)(WindowsConsoleRawIO(fd)), 'utf-16-le', 'strict', line_buffering=True)\n\t\t\texcept IOError: pass\n\treturn result\nclass NonOwningTextIOWrapper(io.TextIOWrapper):\n\tdef __init__(self, base_textiowrapper, **kwargs):\n\t\tassert isinstance(base_textiowrapper, io.TextIOWrapper)\n\t\tself.base = base_textiowrapper  # must keep a reference to this alive so it doesn't get closed\n\t\tsuper(NonOwningTextIOWrapper, self).__init__(base_textiowrapper.buffer, **kwargs)\n\tdef close(self):\n\t\tsuper(NonOwningTextIOWrapper, self).flush()",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tself.base",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tself.base = base_textiowrapper  # must keep a reference to this alive so it doesn't get closed\n\t\tsuper(NonOwningTextIOWrapper, self).__init__(base_textiowrapper.buffer, **kwargs)\n\tdef close(self):\n\t\tsuper(NonOwningTextIOWrapper, self).flush()\ndef wrap_unicode_stdio(stream, is_writer, encoding):  # The underlying stream must NOT be used directly until the stream returned by this function is disposed of\n\tif isinstance(stream, io.TextIOWrapper):\n\t\tstream.flush()  # Make sure nothing is left in the buffer before we re-wrap it\n\t\tnone = object()\n\t\tkwargs = {}\n\t\tfor key in ['encoding', 'errors', 'newline', 'line_buffering', 'write_through']:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tnone",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tnone = object()\n\t\tkwargs = {}\n\t\tfor key in ['encoding', 'errors', 'newline', 'line_buffering', 'write_through']:\n\t\t\tvalue = getattr(stream, 'newlines' if key == 'newline' else key, none)\n\t\t\tif value is not none:\n\t\t\t\tkwargs[key] = value\n\t\tkwargs['encoding'] = encoding\n\t\tresult = NonOwningTextIOWrapper(stream, **kwargs)\n\telif 'PYTHONIOENCODING' not in os.environ and str == bytes and stream in (sys.stdin, sys.stdout, sys.stderr):\n\t\tresult = (codecs.getwriter if is_writer else codecs.getreader)(encoding)(stream)",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tkwargs",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tkwargs = {}\n\t\tfor key in ['encoding', 'errors', 'newline', 'line_buffering', 'write_through']:\n\t\t\tvalue = getattr(stream, 'newlines' if key == 'newline' else key, none)\n\t\t\tif value is not none:\n\t\t\t\tkwargs[key] = value\n\t\tkwargs['encoding'] = encoding\n\t\tresult = NonOwningTextIOWrapper(stream, **kwargs)\n\telif 'PYTHONIOENCODING' not in os.environ and str == bytes and stream in (sys.stdin, sys.stdout, sys.stderr):\n\t\tresult = (codecs.getwriter if is_writer else codecs.getreader)(encoding)(stream)\n\telse:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\tvalue",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\tvalue = getattr(stream, 'newlines' if key == 'newline' else key, none)\n\t\t\tif value is not none:\n\t\t\t\tkwargs[key] = value\n\t\tkwargs['encoding'] = encoding\n\t\tresult = NonOwningTextIOWrapper(stream, **kwargs)\n\telif 'PYTHONIOENCODING' not in os.environ and str == bytes and stream in (sys.stdin, sys.stdout, sys.stderr):\n\t\tresult = (codecs.getwriter if is_writer else codecs.getreader)(encoding)(stream)\n\telse:\n\t\tresult = stream\n\treturn result",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tkwargs[key]",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\tkwargs[key] = value\n\t\tkwargs['encoding'] = encoding\n\t\tresult = NonOwningTextIOWrapper(stream, **kwargs)\n\telif 'PYTHONIOENCODING' not in os.environ and str == bytes and stream in (sys.stdin, sys.stdout, sys.stderr):\n\t\tresult = (codecs.getwriter if is_writer else codecs.getreader)(encoding)(stream)\n\telse:\n\t\tresult = stream\n\treturn result\nclass StringEscapeParser(object):\n\tdef __init__(self):",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tkwargs['encoding']",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tkwargs['encoding'] = encoding\n\t\tresult = NonOwningTextIOWrapper(stream, **kwargs)\n\telif 'PYTHONIOENCODING' not in os.environ and str == bytes and stream in (sys.stdin, sys.stdout, sys.stderr):\n\t\tresult = (codecs.getwriter if is_writer else codecs.getreader)(encoding)(stream)\n\telse:\n\t\tresult = stream\n\treturn result\nclass StringEscapeParser(object):\n\tdef __init__(self):\n\t\timport re",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tresult",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tresult = NonOwningTextIOWrapper(stream, **kwargs)\n\telif 'PYTHONIOENCODING' not in os.environ and str == bytes and stream in (sys.stdin, sys.stdout, sys.stderr):\n\t\tresult = (codecs.getwriter if is_writer else codecs.getreader)(encoding)(stream)\n\telse:\n\t\tresult = stream\n\treturn result\nclass StringEscapeParser(object):\n\tdef __init__(self):\n\t\timport re\n\t\tself.pattern = re.compile(\"\\\"((?:[^\\\"\\\\n]+|\\\\\\\\.)*)(?:\\\"|$)|\\'([^\\'\\\\n]*)(?:\\'|$)|(\\\\S+)\")",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tresult",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tresult = (codecs.getwriter if is_writer else codecs.getreader)(encoding)(stream)\n\telse:\n\t\tresult = stream\n\treturn result\nclass StringEscapeParser(object):\n\tdef __init__(self):\n\t\timport re\n\t\tself.pattern = re.compile(\"\\\"((?:[^\\\"\\\\n]+|\\\\\\\\.)*)(?:\\\"|$)|\\'([^\\'\\\\n]*)(?:\\'|$)|(\\\\S+)\")\n\t\tself.escape_pattern = re.compile(\"\\\\\\\\(.)\", re.DOTALL)\n\t@staticmethod",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tresult",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tresult = stream\n\treturn result\nclass StringEscapeParser(object):\n\tdef __init__(self):\n\t\timport re\n\t\tself.pattern = re.compile(\"\\\"((?:[^\\\"\\\\n]+|\\\\\\\\.)*)(?:\\\"|$)|\\'([^\\'\\\\n]*)(?:\\'|$)|(\\\\S+)\")\n\t\tself.escape_pattern = re.compile(\"\\\\\\\\(.)\", re.DOTALL)\n\t@staticmethod\n\tdef escape_replacement(m):\n\t\ttext = m.group(1)",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tself.pattern",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tself.pattern = re.compile(\"\\\"((?:[^\\\"\\\\n]+|\\\\\\\\.)*)(?:\\\"|$)|\\'([^\\'\\\\n]*)(?:\\'|$)|(\\\\S+)\")\n\t\tself.escape_pattern = re.compile(\"\\\\\\\\(.)\", re.DOTALL)\n\t@staticmethod\n\tdef escape_replacement(m):\n\t\ttext = m.group(1)\n\t\tif text == \"\\\\\": text = \"\\\\\"\n\t\telif text == \"/\": text = \"\\n\"\n\t\telif text == \"n\": text = \"\\n\"\n\t\telif text == \"r\": text = \"\\r\"\n\t\telif text == \"t\": text = \"\\t\"",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tself.escape_pattern",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tself.escape_pattern = re.compile(\"\\\\\\\\(.)\", re.DOTALL)\n\t@staticmethod\n\tdef escape_replacement(m):\n\t\ttext = m.group(1)\n\t\tif text == \"\\\\\": text = \"\\\\\"\n\t\telif text == \"/\": text = \"\\n\"\n\t\telif text == \"n\": text = \"\\n\"\n\t\telif text == \"r\": text = \"\\r\"\n\t\telif text == \"t\": text = \"\\t\"\n\t\telif text == \"v\": text = \"\\v\"",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\ttext",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\ttext = m.group(1)\n\t\tif text == \"\\\\\": text = \"\\\\\"\n\t\telif text == \"/\": text = \"\\n\"\n\t\telif text == \"n\": text = \"\\n\"\n\t\telif text == \"r\": text = \"\\r\"\n\t\telif text == \"t\": text = \"\\t\"\n\t\telif text == \"v\": text = \"\\v\"\n\t\telif text == \"f\": text = \"\\f\"\n\t\telif text == \"a\": text = \"\\a\"\n\t\telif text == \"b\": text = \"\\b\"",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tescape_pattern",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tescape_pattern = self.escape_pattern\n\t\tescape_replacement = self.escape_replacement\n\t\tresult = []\n\t\tfor match in self.pattern.finditer(s):\n\t\t\t[m1, m2, m3] = match.groups()\n\t\t\tif m1 is not None: result.append(escape_pattern.sub(escape_replacement, m1))\n\t\t\tif m2 is not None: result.append(m2)\n\t\t\tif m3 is not None: result.append(escape_pattern.sub(escape_replacement, m3))\n\t\treturn result\nclass Database(object):",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tescape_replacement",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tescape_replacement = self.escape_replacement\n\t\tresult = []\n\t\tfor match in self.pattern.finditer(s):\n\t\t\t[m1, m2, m3] = match.groups()\n\t\t\tif m1 is not None: result.append(escape_pattern.sub(escape_replacement, m1))\n\t\t\tif m2 is not None: result.append(m2)\n\t\t\tif m3 is not None: result.append(escape_pattern.sub(escape_replacement, m3))\n\t\treturn result\nclass Database(object):\n\tdef __init__(self, name, *args, **kwargs):",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tresult",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tresult = []\n\t\tfor match in self.pattern.finditer(s):\n\t\t\t[m1, m2, m3] = match.groups()\n\t\t\tif m1 is not None: result.append(escape_pattern.sub(escape_replacement, m1))\n\t\t\tif m2 is not None: result.append(m2)\n\t\t\tif m3 is not None: result.append(escape_pattern.sub(escape_replacement, m3))\n\t\treturn result\nclass Database(object):\n\tdef __init__(self, name, *args, **kwargs):\n\t\tself.connection = sqlite3.connect(name, *args, **kwargs)",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tself.connection",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tself.connection = sqlite3.connect(name, *args, **kwargs)\n\t\tself.cursor = self.connection.cursor()\n\t\tself.name = name  # assign name only AFTER cursor is created\ndef isatty(file_or_fd):\n\tresult = True\n\tmethod = getattr(file_or_fd, 'isatty', None) if not isinstance(file_or_fd, int) else None  # this check is just an optimization\n\tif method is not None:\n\t\ttry: tty = method()\n\t\texcept io.UnsupportedOperation: tty = None\n\t\tresult = result and tty is not None and tty",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tself.cursor",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tself.cursor = self.connection.cursor()\n\t\tself.name = name  # assign name only AFTER cursor is created\ndef isatty(file_or_fd):\n\tresult = True\n\tmethod = getattr(file_or_fd, 'isatty', None) if not isinstance(file_or_fd, int) else None  # this check is just an optimization\n\tif method is not None:\n\t\ttry: tty = method()\n\t\texcept io.UnsupportedOperation: tty = None\n\t\tresult = result and tty is not None and tty\n\tmethod = getattr(file_or_fd, 'fileno', None) if not isinstance(file_or_fd, int) else None  # this check is just an optimization",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tself.name",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tself.name = name  # assign name only AFTER cursor is created\ndef isatty(file_or_fd):\n\tresult = True\n\tmethod = getattr(file_or_fd, 'isatty', None) if not isinstance(file_or_fd, int) else None  # this check is just an optimization\n\tif method is not None:\n\t\ttry: tty = method()\n\t\texcept io.UnsupportedOperation: tty = None\n\t\tresult = result and tty is not None and tty\n\tmethod = getattr(file_or_fd, 'fileno', None) if not isinstance(file_or_fd, int) else None  # this check is just an optimization\n\tif method is not None:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tresult",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tresult = True\n\tmethod = getattr(file_or_fd, 'isatty', None) if not isinstance(file_or_fd, int) else None  # this check is just an optimization\n\tif method is not None:\n\t\ttry: tty = method()\n\t\texcept io.UnsupportedOperation: tty = None\n\t\tresult = result and tty is not None and tty\n\tmethod = getattr(file_or_fd, 'fileno', None) if not isinstance(file_or_fd, int) else None  # this check is just an optimization\n\tif method is not None:\n\t\ttry: fd = method()\n\t\texcept io.UnsupportedOperation: fd = None",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tmethod",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tmethod = getattr(file_or_fd, 'isatty', None) if not isinstance(file_or_fd, int) else None  # this check is just an optimization\n\tif method is not None:\n\t\ttry: tty = method()\n\t\texcept io.UnsupportedOperation: tty = None\n\t\tresult = result and tty is not None and tty\n\tmethod = getattr(file_or_fd, 'fileno', None) if not isinstance(file_or_fd, int) else None  # this check is just an optimization\n\tif method is not None:\n\t\ttry: fd = method()\n\t\texcept io.UnsupportedOperation: fd = None\n\t\tresult = result and fd is not None and os.isatty(fd) and (not msvcrt or GetConsoleMode(msvcrt.get_osfhandle(fd), ctypes.byref(DWORD(0))) != 0)",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tresult",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tresult = result and tty is not None and tty\n\tmethod = getattr(file_or_fd, 'fileno', None) if not isinstance(file_or_fd, int) else None  # this check is just an optimization\n\tif method is not None:\n\t\ttry: fd = method()\n\t\texcept io.UnsupportedOperation: fd = None\n\t\tresult = result and fd is not None and os.isatty(fd) and (not msvcrt or GetConsoleMode(msvcrt.get_osfhandle(fd), ctypes.byref(DWORD(0))) != 0)\n\treturn result\ndef can_call_input_for_stdio(stream):\n\treturn stream == sys.stdin and sys.version_info[0] >= 3\nclass StdIOProxy(object):",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tmethod",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tmethod = getattr(file_or_fd, 'fileno', None) if not isinstance(file_or_fd, int) else None  # this check is just an optimization\n\tif method is not None:\n\t\ttry: fd = method()\n\t\texcept io.UnsupportedOperation: fd = None\n\t\tresult = result and fd is not None and os.isatty(fd) and (not msvcrt or GetConsoleMode(msvcrt.get_osfhandle(fd), ctypes.byref(DWORD(0))) != 0)\n\treturn result\ndef can_call_input_for_stdio(stream):\n\treturn stream == sys.stdin and sys.version_info[0] >= 3\nclass StdIOProxy(object):\n\t# Maybe useful later: codecs.StreamRecoder(bytesIO, codec.decode, codec.encode, codec.streamwriter, codec.streamreader, errors='surrogateescape')",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tresult",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tresult = result and fd is not None and os.isatty(fd) and (not msvcrt or GetConsoleMode(msvcrt.get_osfhandle(fd), ctypes.byref(DWORD(0))) != 0)\n\treturn result\ndef can_call_input_for_stdio(stream):\n\treturn stream == sys.stdin and sys.version_info[0] >= 3\nclass StdIOProxy(object):\n\t# Maybe useful later: codecs.StreamRecoder(bytesIO, codec.decode, codec.encode, codec.streamwriter, codec.streamreader, errors='surrogateescape')\n\tdef __init__(self, stdin, stdout, stderr, codec, allow_set_code_page):\n\t\tself.codec = codec\n\t\tstreams = (stdin, stdout, stderr)\n\t\tfor stream in streams:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tself.codec",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tself.codec = codec\n\t\tstreams = (stdin, stdout, stderr)\n\t\tfor stream in streams:\n\t\t\tassert isinstance(stream, io.IOBase) or sys.version_info[0] < 3 and isinstance(stream, file) or hasattr(stream, 'mode'), \"unable to determine stream type\"\n\t\t\tassert not isinstance(stream, io.RawIOBase), \"RAW I/O APIs are different and not supported\"\n\t\tself.streaminfos = tuple(map(lambda stream:\n\t\t\t(\n\t\t\t\tstream,\n\t\t\t\tisinstance(stream, io.BufferedIOBase) or isinstance(stream, io.RawIOBase) or not isinstance(stream, io.TextIOBase) and 'b' in stream.mode,\n\t\t\t\tisinstance(stream, io.TextIOBase) or not (isinstance(stream, io.BufferedIOBase) or isinstance(stream, io.RawIOBase)) and 'b' not in stream.mode,",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tstreams",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tstreams = (stdin, stdout, stderr)\n\t\tfor stream in streams:\n\t\t\tassert isinstance(stream, io.IOBase) or sys.version_info[0] < 3 and isinstance(stream, file) or hasattr(stream, 'mode'), \"unable to determine stream type\"\n\t\t\tassert not isinstance(stream, io.RawIOBase), \"RAW I/O APIs are different and not supported\"\n\t\tself.streaminfos = tuple(map(lambda stream:\n\t\t\t(\n\t\t\t\tstream,\n\t\t\t\tisinstance(stream, io.BufferedIOBase) or isinstance(stream, io.RawIOBase) or not isinstance(stream, io.TextIOBase) and 'b' in stream.mode,\n\t\t\t\tisinstance(stream, io.TextIOBase) or not (isinstance(stream, io.BufferedIOBase) or isinstance(stream, io.RawIOBase)) and 'b' not in stream.mode,\n\t\t\t\tallow_set_code_page",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tself.streaminfos",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tself.streaminfos = tuple(map(lambda stream:\n\t\t\t(\n\t\t\t\tstream,\n\t\t\t\tisinstance(stream, io.BufferedIOBase) or isinstance(stream, io.RawIOBase) or not isinstance(stream, io.TextIOBase) and 'b' in stream.mode,\n\t\t\t\tisinstance(stream, io.TextIOBase) or not (isinstance(stream, io.BufferedIOBase) or isinstance(stream, io.RawIOBase)) and 'b' not in stream.mode,\n\t\t\t\tallow_set_code_page\n\t\t\t),\n\t\t\tstreams))\n\t@property\n\tdef stdin(self): return self.streaminfos[0][0]",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tstream",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tstream = streaminfo[0]\n\t\tcan_binary = streaminfo[1]\n\t\tcan_text = streaminfo[2]\n\t\tif not isinstance(arg, bytes) and not isinstance(arg, buffer) and not isinstance(arg, unicode):\n\t\t\targ = unicode(arg)\n\t\tif isinstance(arg, bytes) or isinstance(arg, buffer):\n\t\t\tif not can_binary:\n\t\t\t\targ = codec.decode(arg, 'surrogateescape')[0]\n\t\telif isinstance(arg, unicode):\n\t\t\tif not can_text:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tcan_binary",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tcan_binary = streaminfo[1]\n\t\tcan_text = streaminfo[2]\n\t\tif not isinstance(arg, bytes) and not isinstance(arg, buffer) and not isinstance(arg, unicode):\n\t\t\targ = unicode(arg)\n\t\tif isinstance(arg, bytes) or isinstance(arg, buffer):\n\t\t\tif not can_binary:\n\t\t\t\targ = codec.decode(arg, 'surrogateescape')[0]\n\t\telif isinstance(arg, unicode):\n\t\t\tif not can_text:\n\t\t\t\targ = codec.encode(unicode(arg), 'strict')[0]",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tcan_text",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tcan_text = streaminfo[2]\n\t\tif not isinstance(arg, bytes) and not isinstance(arg, buffer) and not isinstance(arg, unicode):\n\t\t\targ = unicode(arg)\n\t\tif isinstance(arg, bytes) or isinstance(arg, buffer):\n\t\t\tif not can_binary:\n\t\t\t\targ = codec.decode(arg, 'surrogateescape')[0]\n\t\telif isinstance(arg, unicode):\n\t\t\tif not can_text:\n\t\t\t\targ = codec.encode(unicode(arg), 'strict')[0]\n\t\treturn arg",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\targ",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\targ = unicode(arg)\n\t\tif isinstance(arg, bytes) or isinstance(arg, buffer):\n\t\t\tif not can_binary:\n\t\t\t\targ = codec.decode(arg, 'surrogateescape')[0]\n\t\telif isinstance(arg, unicode):\n\t\t\tif not can_text:\n\t\t\t\targ = codec.encode(unicode(arg), 'strict')[0]\n\t\treturn arg\n\t@staticmethod\n\tdef _do_readline(stream, allow_set_code_page, *args):",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\targ",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\targ = codec.decode(arg, 'surrogateescape')[0]\n\t\telif isinstance(arg, unicode):\n\t\t\tif not can_text:\n\t\t\t\targ = codec.encode(unicode(arg), 'strict')[0]\n\t\treturn arg\n\t@staticmethod\n\tdef _do_readline(stream, allow_set_code_page, *args):\n\t\tnew_code_page = CP_UTF8\n\t\told_code_page = GetConsoleCP() if msvcrt and GetConsoleCP and isatty(stream) else None\n\t\tif old_code_page == new_code_page: old_code_page = None  # Don't change code page if it's already correct...",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\targ",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\targ = codec.encode(unicode(arg), 'strict')[0]\n\t\treturn arg\n\t@staticmethod\n\tdef _do_readline(stream, allow_set_code_page, *args):\n\t\tnew_code_page = CP_UTF8\n\t\told_code_page = GetConsoleCP() if msvcrt and GetConsoleCP and isatty(stream) else None\n\t\tif old_code_page == new_code_page: old_code_page = None  # Don't change code page if it's already correct...\n\t\tif old_code_page is not None:\n\t\t\tif not SetConsoleCP(new_code_page):\n\t\t\t\told_code_page = None",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tnew_code_page",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tnew_code_page = CP_UTF8\n\t\told_code_page = GetConsoleCP() if msvcrt and GetConsoleCP and isatty(stream) else None\n\t\tif old_code_page == new_code_page: old_code_page = None  # Don't change code page if it's already correct...\n\t\tif old_code_page is not None:\n\t\t\tif not SetConsoleCP(new_code_page):\n\t\t\t\told_code_page = None\n\t\ttry:\n\t\t\tresult = stream.readline(*args)\n\t\tfinally:\n\t\t\tif old_code_page is not None:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\told_code_page",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\told_code_page = GetConsoleCP() if msvcrt and GetConsoleCP and isatty(stream) else None\n\t\tif old_code_page == new_code_page: old_code_page = None  # Don't change code page if it's already correct...\n\t\tif old_code_page is not None:\n\t\t\tif not SetConsoleCP(new_code_page):\n\t\t\t\told_code_page = None\n\t\ttry:\n\t\t\tresult = stream.readline(*args)\n\t\tfinally:\n\t\t\tif old_code_page is not None:\n\t\t\t\tSetConsoleCP(old_code_page)",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\told_code_page",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\told_code_page = None\n\t\ttry:\n\t\t\tresult = stream.readline(*args)\n\t\tfinally:\n\t\t\tif old_code_page is not None:\n\t\t\t\tSetConsoleCP(old_code_page)\n\t\treturn result\n\t@staticmethod\n\tdef _do_write(stream, allow_set_code_page, *args):\n\t\tnew_code_page = CP_UTF8",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\tresult",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\tresult = stream.readline(*args)\n\t\tfinally:\n\t\t\tif old_code_page is not None:\n\t\t\t\tSetConsoleCP(old_code_page)\n\t\treturn result\n\t@staticmethod\n\tdef _do_write(stream, allow_set_code_page, *args):\n\t\tnew_code_page = CP_UTF8\n\t\told_code_page = GetConsoleOutputCP() if msvcrt and GetConsoleOutputCP and isatty(stream) else None\n\t\tif old_code_page == new_code_page: old_code_page = None  # Don't change code page if it's already correct...",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tnew_code_page",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tnew_code_page = CP_UTF8\n\t\told_code_page = GetConsoleOutputCP() if msvcrt and GetConsoleOutputCP and isatty(stream) else None\n\t\tif old_code_page == new_code_page: old_code_page = None  # Don't change code page if it's already correct...\n\t\tif old_code_page is not None:\n\t\t\tif not SetConsoleOutputCP(new_code_page):\n\t\t\t\told_code_page = None\n\t\ttry:\n\t\t\tresult = stream.write(*args)\n\t\tfinally:\n\t\t\tif old_code_page is not None:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\told_code_page",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\told_code_page = GetConsoleOutputCP() if msvcrt and GetConsoleOutputCP and isatty(stream) else None\n\t\tif old_code_page == new_code_page: old_code_page = None  # Don't change code page if it's already correct...\n\t\tif old_code_page is not None:\n\t\t\tif not SetConsoleOutputCP(new_code_page):\n\t\t\t\told_code_page = None\n\t\ttry:\n\t\t\tresult = stream.write(*args)\n\t\tfinally:\n\t\t\tif old_code_page is not None:\n\t\t\t\tSetConsoleCP(old_code_page)",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\told_code_page",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\told_code_page = None\n\t\ttry:\n\t\t\tresult = stream.write(*args)\n\t\tfinally:\n\t\t\tif old_code_page is not None:\n\t\t\t\tSetConsoleCP(old_code_page)\n\t\treturn result\n\tdef _readln(self, streaminfo, codec, prompt):\n\t\tstream = streaminfo[0]\n\t\tcan_binary = streaminfo[1]",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\tresult",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\tresult = stream.write(*args)\n\t\tfinally:\n\t\t\tif old_code_page is not None:\n\t\t\t\tSetConsoleCP(old_code_page)\n\t\treturn result\n\tdef _readln(self, streaminfo, codec, prompt):\n\t\tstream = streaminfo[0]\n\t\tcan_binary = streaminfo[1]\n\t\tallow_set_code_page = streaminfo[3]\n\t\tif can_call_input_for_stdio(stream) and not can_binary:  # input() can't work with binary data",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tstream",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tstream = streaminfo[0]\n\t\tcan_binary = streaminfo[1]\n\t\tallow_set_code_page = streaminfo[3]\n\t\tif can_call_input_for_stdio(stream) and not can_binary:  # input() can't work with binary data\n\t\t\tresult = self._coerce(streaminfo, codec, \"\")\n\t\t\ttry:\n\t\t\t\tresult = input(*((self._coerce(streaminfo, codec, prompt),) if prompt is not None else ()))\n\t\t\t\tresult += self._coerce(streaminfo, codec, \"\\n\")\n\t\t\texcept EOFError: pass\n\t\telse:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tcan_binary",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tcan_binary = streaminfo[1]\n\t\tallow_set_code_page = streaminfo[3]\n\t\tif can_call_input_for_stdio(stream) and not can_binary:  # input() can't work with binary data\n\t\t\tresult = self._coerce(streaminfo, codec, \"\")\n\t\t\ttry:\n\t\t\t\tresult = input(*((self._coerce(streaminfo, codec, prompt),) if prompt is not None else ()))\n\t\t\t\tresult += self._coerce(streaminfo, codec, \"\\n\")\n\t\t\texcept EOFError: pass\n\t\telse:\n\t\t\tself.output(*((prompt,) if prompt is not None else ()))",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tallow_set_code_page",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tallow_set_code_page = streaminfo[3]\n\t\tif can_call_input_for_stdio(stream) and not can_binary:  # input() can't work with binary data\n\t\t\tresult = self._coerce(streaminfo, codec, \"\")\n\t\t\ttry:\n\t\t\t\tresult = input(*((self._coerce(streaminfo, codec, prompt),) if prompt is not None else ()))\n\t\t\t\tresult += self._coerce(streaminfo, codec, \"\\n\")\n\t\t\texcept EOFError: pass\n\t\telse:\n\t\t\tself.output(*((prompt,) if prompt is not None else ()))\n\t\t\tself.error()",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\tresult",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\tresult = self._coerce(streaminfo, codec, \"\")\n\t\t\ttry:\n\t\t\t\tresult = input(*((self._coerce(streaminfo, codec, prompt),) if prompt is not None else ()))\n\t\t\t\tresult += self._coerce(streaminfo, codec, \"\\n\")\n\t\t\texcept EOFError: pass\n\t\telse:\n\t\t\tself.output(*((prompt,) if prompt is not None else ()))\n\t\t\tself.error()\n\t\t\tresult = StdIOProxy._do_readline(stream, allow_set_code_page)\n\t\treturn result",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tresult",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\tresult = input(*((self._coerce(streaminfo, codec, prompt),) if prompt is not None else ()))\n\t\t\t\tresult += self._coerce(streaminfo, codec, \"\\n\")\n\t\t\texcept EOFError: pass\n\t\telse:\n\t\t\tself.output(*((prompt,) if prompt is not None else ()))\n\t\t\tself.error()\n\t\t\tresult = StdIOProxy._do_readline(stream, allow_set_code_page)\n\t\treturn result\n\tdef _writeln(self, streaminfo, codec, *args, **kwargs):\n\t\tstream = streaminfo[0]",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\tresult",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\tresult = StdIOProxy._do_readline(stream, allow_set_code_page)\n\t\treturn result\n\tdef _writeln(self, streaminfo, codec, *args, **kwargs):\n\t\tstream = streaminfo[0]\n\t\tallow_set_code_page = streaminfo[3]\n\t\tflush = kwargs.pop('flush', True)\n\t\tkwargs.setdefault('end', '\\n')\n\t\tkwargs.setdefault('sep', ' ')\n\t\tend = kwargs.get('end')\n\t\tsep = kwargs.get('sep')",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tstream",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tstream = streaminfo[0]\n\t\tallow_set_code_page = streaminfo[3]\n\t\tflush = kwargs.pop('flush', True)\n\t\tkwargs.setdefault('end', '\\n')\n\t\tkwargs.setdefault('sep', ' ')\n\t\tend = kwargs.get('end')\n\t\tsep = kwargs.get('sep')\n\t\tfirst = True\n\t\tfor arg in args:\n\t\t\tif first: first = False",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tallow_set_code_page",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tallow_set_code_page = streaminfo[3]\n\t\tflush = kwargs.pop('flush', True)\n\t\tkwargs.setdefault('end', '\\n')\n\t\tkwargs.setdefault('sep', ' ')\n\t\tend = kwargs.get('end')\n\t\tsep = kwargs.get('sep')\n\t\tfirst = True\n\t\tfor arg in args:\n\t\t\tif first: first = False\n\t\t\telif sep is not None:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tflush",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tflush = kwargs.pop('flush', True)\n\t\tkwargs.setdefault('end', '\\n')\n\t\tkwargs.setdefault('sep', ' ')\n\t\tend = kwargs.get('end')\n\t\tsep = kwargs.get('sep')\n\t\tfirst = True\n\t\tfor arg in args:\n\t\t\tif first: first = False\n\t\t\telif sep is not None:\n\t\t\t\tStdIOProxy._do_write(stream, allow_set_code_page, self._coerce(streaminfo, codec, sep))",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tend",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tend = kwargs.get('end')\n\t\tsep = kwargs.get('sep')\n\t\tfirst = True\n\t\tfor arg in args:\n\t\t\tif first: first = False\n\t\t\telif sep is not None:\n\t\t\t\tStdIOProxy._do_write(stream, allow_set_code_page, self._coerce(streaminfo, codec, sep))\n\t\t\tStdIOProxy._do_write(stream, allow_set_code_page, self._coerce(streaminfo, codec, arg))\n\t\tif end is not None:\n\t\t\tStdIOProxy._do_write(stream, allow_set_code_page, self._coerce(streaminfo, codec, end))",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tsep",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tsep = kwargs.get('sep')\n\t\tfirst = True\n\t\tfor arg in args:\n\t\t\tif first: first = False\n\t\t\telif sep is not None:\n\t\t\t\tStdIOProxy._do_write(stream, allow_set_code_page, self._coerce(streaminfo, codec, sep))\n\t\t\tStdIOProxy._do_write(stream, allow_set_code_page, self._coerce(streaminfo, codec, arg))\n\t\tif end is not None:\n\t\t\tStdIOProxy._do_write(stream, allow_set_code_page, self._coerce(streaminfo, codec, end))\n\t\tif flush: stream.flush()",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tfirst",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tfirst = True\n\t\tfor arg in args:\n\t\t\tif first: first = False\n\t\t\telif sep is not None:\n\t\t\t\tStdIOProxy._do_write(stream, allow_set_code_page, self._coerce(streaminfo, codec, sep))\n\t\t\tStdIOProxy._do_write(stream, allow_set_code_page, self._coerce(streaminfo, codec, arg))\n\t\tif end is not None:\n\t\t\tStdIOProxy._do_write(stream, allow_set_code_page, self._coerce(streaminfo, codec, end))\n\t\tif flush: stream.flush()\n\tdef inputln(self, prompt=None): return self._readln(self.streaminfos[0], self.codec, prompt)",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tcodec",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tcodec = codecs.lookup('ascii')  # MUST be a safe encoding\n\t@classmethod\n\tdef coerce(cls, other, for_output=False):\n\t\treturn cls.codec.encode(other)[0] if not isinstance(other, bytes) else bytes_comparable_with_unicode(other) if for_output else other\n\t@classmethod\n\tdef translate_if_bytes(cls, value):\n\t\tif value is not None and isinstance(value, bytes): value = cls(value)\n\t\treturn value\n\tdef __hash__(self): return super(bytes_comparable_with_unicode, self).__hash__()  # To avoid warning\n\tdef __eq__(self, other): return super(bytes_comparable_with_unicode, self).__eq__(self.coerce(other))",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t__unicode__",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t__unicode__ = __str__\n\t\tdef __str__(self): raise NotImplementedError()\ndef wrap_bytes_comparable_with_unicode_readline(readline):\n\tdef callback(*args):\n\t\tline = readline(*args)\n\t\tline = bytes_comparable_with_unicode.translate_if_bytes(line)\n\t\treturn line\n\treturn callback\ndef main(program, *args, **kwargs):  # **kwargs = dict(stdin=file, stdout=file, stderr=file); useful for callers who import this module\n\timport argparse  # slow import (compiles regexes etc.), so don't import it until needed",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tline",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tline = readline(*args)\n\t\tline = bytes_comparable_with_unicode.translate_if_bytes(line)\n\t\treturn line\n\treturn callback\ndef main(program, *args, **kwargs):  # **kwargs = dict(stdin=file, stdout=file, stderr=file); useful for callers who import this module\n\timport argparse  # slow import (compiles regexes etc.), so don't import it until needed\n\targparser = argparse.ArgumentParser(\n\t\tprog=os.path.basename(program),\n\t\tusage=None,\n\t\tdescription=None,",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tline",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tline = bytes_comparable_with_unicode.translate_if_bytes(line)\n\t\treturn line\n\treturn callback\ndef main(program, *args, **kwargs):  # **kwargs = dict(stdin=file, stdout=file, stderr=file); useful for callers who import this module\n\timport argparse  # slow import (compiles regexes etc.), so don't import it until needed\n\targparser = argparse.ArgumentParser(\n\t\tprog=os.path.basename(program),\n\t\tusage=None,\n\t\tdescription=None,\n\t\tepilog=None,",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\targparser",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\targparser = argparse.ArgumentParser(\n\t\tprog=os.path.basename(program),\n\t\tusage=None,\n\t\tdescription=None,\n\t\tepilog=None,\n\t\tparents=[],\n\t\tformatter_class=argparse.RawTextHelpFormatter)\n\targparser.add_argument('-version', '--version', action='store_true', help=\"show SQLite version\")\n\targparser.add_argument('-batch', '--batch', action='store_true', help=\"force batch I/O\")\n\targparser.add_argument('-init', '--init', metavar=\"FILE\", help=\"read/process named file\")",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tparsed_args",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tparsed_args = argparser.parse_args(args)\n\tcodec = codecs.lookup(parsed_args.encoding or argparser.get_default('encoding'))\n\tif parsed_args.self_test: self_test(codec)\n\tif parsed_args.cross_test: cross_test(\"sqlite3\", codec)\n\tparse_escaped_strings = StringEscapeParser()\n\tif parsed_args.unicode_stdio == \"true\":\n\t\tstdin = wrap_unicode_stdio(stdin, False, codec.name)\n\t\tstdout = wrap_unicode_stdio(stdout, True, codec.name)\n\t\tstderr = wrap_unicode_stdio(stderr, True, codec.name)\n\tif parsed_args.console == \"true\":",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tcodec",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tcodec = codecs.lookup(parsed_args.encoding or argparser.get_default('encoding'))\n\tif parsed_args.self_test: self_test(codec)\n\tif parsed_args.cross_test: cross_test(\"sqlite3\", codec)\n\tparse_escaped_strings = StringEscapeParser()\n\tif parsed_args.unicode_stdio == \"true\":\n\t\tstdin = wrap_unicode_stdio(stdin, False, codec.name)\n\t\tstdout = wrap_unicode_stdio(stdout, True, codec.name)\n\t\tstderr = wrap_unicode_stdio(stderr, True, codec.name)\n\tif parsed_args.console == \"true\":\n\t\tstdin = wrap_windows_console_io(stdin, False)",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tparse_escaped_strings",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tparse_escaped_strings = StringEscapeParser()\n\tif parsed_args.unicode_stdio == \"true\":\n\t\tstdin = wrap_unicode_stdio(stdin, False, codec.name)\n\t\tstdout = wrap_unicode_stdio(stdout, True, codec.name)\n\t\tstderr = wrap_unicode_stdio(stderr, True, codec.name)\n\tif parsed_args.console == \"true\":\n\t\tstdin = wrap_windows_console_io(stdin, False)\n\t\tstdout = wrap_windows_console_io(stdout, True)\n\t\tstderr = wrap_windows_console_io(stderr, True)\n\tallow_set_code_page = sys.version_info[0] < 3 and False  # This is only necessary on Python 2 if we use the default I/O functions instead of bypassing to ReadConsole()/WriteConsole()",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tstdin",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tstdin = wrap_unicode_stdio(stdin, False, codec.name)\n\t\tstdout = wrap_unicode_stdio(stdout, True, codec.name)\n\t\tstderr = wrap_unicode_stdio(stderr, True, codec.name)\n\tif parsed_args.console == \"true\":\n\t\tstdin = wrap_windows_console_io(stdin, False)\n\t\tstdout = wrap_windows_console_io(stdout, True)\n\t\tstderr = wrap_windows_console_io(stderr, True)\n\tallow_set_code_page = sys.version_info[0] < 3 and False  # This is only necessary on Python 2 if we use the default I/O functions instead of bypassing to ReadConsole()/WriteConsole()\n\tstdio = StdIOProxy(stdin, stdout, stderr, codec, allow_set_code_page)\n\tdb = None",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tstdout",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tstdout = wrap_unicode_stdio(stdout, True, codec.name)\n\t\tstderr = wrap_unicode_stdio(stderr, True, codec.name)\n\tif parsed_args.console == \"true\":\n\t\tstdin = wrap_windows_console_io(stdin, False)\n\t\tstdout = wrap_windows_console_io(stdout, True)\n\t\tstderr = wrap_windows_console_io(stderr, True)\n\tallow_set_code_page = sys.version_info[0] < 3 and False  # This is only necessary on Python 2 if we use the default I/O functions instead of bypassing to ReadConsole()/WriteConsole()\n\tstdio = StdIOProxy(stdin, stdout, stderr, codec, allow_set_code_page)\n\tdb = None\n\tno_args = len(args) == 0",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tstderr",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tstderr = wrap_unicode_stdio(stderr, True, codec.name)\n\tif parsed_args.console == \"true\":\n\t\tstdin = wrap_windows_console_io(stdin, False)\n\t\tstdout = wrap_windows_console_io(stdout, True)\n\t\tstderr = wrap_windows_console_io(stderr, True)\n\tallow_set_code_page = sys.version_info[0] < 3 and False  # This is only necessary on Python 2 if we use the default I/O functions instead of bypassing to ReadConsole()/WriteConsole()\n\tstdio = StdIOProxy(stdin, stdout, stderr, codec, allow_set_code_page)\n\tdb = None\n\tno_args = len(args) == 0\n\tinit_sql = parsed_args.sql",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tstdin",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tstdin = wrap_windows_console_io(stdin, False)\n\t\tstdout = wrap_windows_console_io(stdout, True)\n\t\tstderr = wrap_windows_console_io(stderr, True)\n\tallow_set_code_page = sys.version_info[0] < 3 and False  # This is only necessary on Python 2 if we use the default I/O functions instead of bypassing to ReadConsole()/WriteConsole()\n\tstdio = StdIOProxy(stdin, stdout, stderr, codec, allow_set_code_page)\n\tdb = None\n\tno_args = len(args) == 0\n\tinit_sql = parsed_args.sql\n\tis_nonpipe_input = stdin.isatty()  # NOT the same thing as TTY! (NUL and /dev/null are the difference)\n\tinit_show_prompt = not parsed_args.batch and is_nonpipe_input",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tstdout",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tstdout = wrap_windows_console_io(stdout, True)\n\t\tstderr = wrap_windows_console_io(stderr, True)\n\tallow_set_code_page = sys.version_info[0] < 3 and False  # This is only necessary on Python 2 if we use the default I/O functions instead of bypassing to ReadConsole()/WriteConsole()\n\tstdio = StdIOProxy(stdin, stdout, stderr, codec, allow_set_code_page)\n\tdb = None\n\tno_args = len(args) == 0\n\tinit_sql = parsed_args.sql\n\tis_nonpipe_input = stdin.isatty()  # NOT the same thing as TTY! (NUL and /dev/null are the difference)\n\tinit_show_prompt = not parsed_args.batch and is_nonpipe_input\n\tif not parsed_args.batch and isatty(stdin) and (parsed_args.readline == \"true\" or __name__ == '__main__') and parsed_args.readline != \"false\":",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tstderr",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tstderr = wrap_windows_console_io(stderr, True)\n\tallow_set_code_page = sys.version_info[0] < 3 and False  # This is only necessary on Python 2 if we use the default I/O functions instead of bypassing to ReadConsole()/WriteConsole()\n\tstdio = StdIOProxy(stdin, stdout, stderr, codec, allow_set_code_page)\n\tdb = None\n\tno_args = len(args) == 0\n\tinit_sql = parsed_args.sql\n\tis_nonpipe_input = stdin.isatty()  # NOT the same thing as TTY! (NUL and /dev/null are the difference)\n\tinit_show_prompt = not parsed_args.batch and is_nonpipe_input\n\tif not parsed_args.batch and isatty(stdin) and (parsed_args.readline == \"true\" or __name__ == '__main__') and parsed_args.readline != \"false\":\n\t\ttry:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tallow_set_code_page",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tallow_set_code_page = sys.version_info[0] < 3 and False  # This is only necessary on Python 2 if we use the default I/O functions instead of bypassing to ReadConsole()/WriteConsole()\n\tstdio = StdIOProxy(stdin, stdout, stderr, codec, allow_set_code_page)\n\tdb = None\n\tno_args = len(args) == 0\n\tinit_sql = parsed_args.sql\n\tis_nonpipe_input = stdin.isatty()  # NOT the same thing as TTY! (NUL and /dev/null are the difference)\n\tinit_show_prompt = not parsed_args.batch and is_nonpipe_input\n\tif not parsed_args.batch and isatty(stdin) and (parsed_args.readline == \"true\" or __name__ == '__main__') and parsed_args.readline != \"false\":\n\t\ttry:\n\t\t\twith warnings.catch_warnings():",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tstdio",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tstdio = StdIOProxy(stdin, stdout, stderr, codec, allow_set_code_page)\n\tdb = None\n\tno_args = len(args) == 0\n\tinit_sql = parsed_args.sql\n\tis_nonpipe_input = stdin.isatty()  # NOT the same thing as TTY! (NUL and /dev/null are the difference)\n\tinit_show_prompt = not parsed_args.batch and is_nonpipe_input\n\tif not parsed_args.batch and isatty(stdin) and (parsed_args.readline == \"true\" or __name__ == '__main__') and parsed_args.readline != \"false\":\n\t\ttry:\n\t\t\twith warnings.catch_warnings():\n\t\t\t\twarnings.filterwarnings('ignore', category=DeprecationWarning)",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tdb",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tdb = None\n\tno_args = len(args) == 0\n\tinit_sql = parsed_args.sql\n\tis_nonpipe_input = stdin.isatty()  # NOT the same thing as TTY! (NUL and /dev/null are the difference)\n\tinit_show_prompt = not parsed_args.batch and is_nonpipe_input\n\tif not parsed_args.batch and isatty(stdin) and (parsed_args.readline == \"true\" or __name__ == '__main__') and parsed_args.readline != \"false\":\n\t\ttry:\n\t\t\twith warnings.catch_warnings():\n\t\t\t\twarnings.filterwarnings('ignore', category=DeprecationWarning)\n\t\t\t\timport readline",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tno_args",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tno_args = len(args) == 0\n\tinit_sql = parsed_args.sql\n\tis_nonpipe_input = stdin.isatty()  # NOT the same thing as TTY! (NUL and /dev/null are the difference)\n\tinit_show_prompt = not parsed_args.batch and is_nonpipe_input\n\tif not parsed_args.batch and isatty(stdin) and (parsed_args.readline == \"true\" or __name__ == '__main__') and parsed_args.readline != \"false\":\n\t\ttry:\n\t\t\twith warnings.catch_warnings():\n\t\t\t\twarnings.filterwarnings('ignore', category=DeprecationWarning)\n\t\t\t\timport readline\n\t\texcept ImportError: pass",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tinit_sql",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tinit_sql = parsed_args.sql\n\tis_nonpipe_input = stdin.isatty()  # NOT the same thing as TTY! (NUL and /dev/null are the difference)\n\tinit_show_prompt = not parsed_args.batch and is_nonpipe_input\n\tif not parsed_args.batch and isatty(stdin) and (parsed_args.readline == \"true\" or __name__ == '__main__') and parsed_args.readline != \"false\":\n\t\ttry:\n\t\t\twith warnings.catch_warnings():\n\t\t\t\twarnings.filterwarnings('ignore', category=DeprecationWarning)\n\t\t\t\timport readline\n\t\texcept ImportError: pass\n\tif parsed_args and parsed_args.version:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tis_nonpipe_input",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tis_nonpipe_input = stdin.isatty()  # NOT the same thing as TTY! (NUL and /dev/null are the difference)\n\tinit_show_prompt = not parsed_args.batch and is_nonpipe_input\n\tif not parsed_args.batch and isatty(stdin) and (parsed_args.readline == \"true\" or __name__ == '__main__') and parsed_args.readline != \"false\":\n\t\ttry:\n\t\t\twith warnings.catch_warnings():\n\t\t\t\twarnings.filterwarnings('ignore', category=DeprecationWarning)\n\t\t\t\timport readline\n\t\texcept ImportError: pass\n\tif parsed_args and parsed_args.version:\n\t\tstdio.outputln(sqlite3.sqlite_version);",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tinit_show_prompt",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tinit_show_prompt = not parsed_args.batch and is_nonpipe_input\n\tif not parsed_args.batch and isatty(stdin) and (parsed_args.readline == \"true\" or __name__ == '__main__') and parsed_args.readline != \"false\":\n\t\ttry:\n\t\t\twith warnings.catch_warnings():\n\t\t\t\twarnings.filterwarnings('ignore', category=DeprecationWarning)\n\t\t\t\timport readline\n\t\texcept ImportError: pass\n\tif parsed_args and parsed_args.version:\n\t\tstdio.outputln(sqlite3.sqlite_version);\n\telse:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tfilename",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tfilename = parsed_args.filename\n\t\tif filename is None: filename = \":memory:\"\n\t\tdb = Database(filename, isolation_level=None)\n\tdef exec_script(db, filename, ignore_io_errors):\n\t\ttry:\n\t\t\twith io.open(filename, 'r', encoding=codec.name) as f:  # Assume .sql files are text -- any binary data inside them should be X'' encoded, not embedded directly\n\t\t\t\tfor command in sql_commands(wrap_bytes_comparable_with_unicode_readline(lambda *args: (lambda s: (s) or None)(f.readline()))):\n\t\t\t\t\tresult = exec_command(db, command, False and ignore_io_errors)\n\t\t\t\t\tif result is not None:\n\t\t\t\t\t\treturn result",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tdb",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tdb = Database(filename, isolation_level=None)\n\tdef exec_script(db, filename, ignore_io_errors):\n\t\ttry:\n\t\t\twith io.open(filename, 'r', encoding=codec.name) as f:  # Assume .sql files are text -- any binary data inside them should be X'' encoded, not embedded directly\n\t\t\t\tfor command in sql_commands(wrap_bytes_comparable_with_unicode_readline(lambda *args: (lambda s: (s) or None)(f.readline()))):\n\t\t\t\t\tresult = exec_command(db, command, False and ignore_io_errors)\n\t\t\t\t\tif result is not None:\n\t\t\t\t\t\treturn result\n\t\texcept IOError as ex:\n\t\t\tstdio.errorln(ex)",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tresult",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\t\tresult = exec_command(db, command, False and ignore_io_errors)\n\t\t\t\t\tif result is not None:\n\t\t\t\t\t\treturn result\n\t\texcept IOError as ex:\n\t\t\tstdio.errorln(ex)\n\t\t\tif not ignore_io_errors: return ex.errno\n\tdef raise_invalid_command_error(command):\n\t\tif isinstance(command, bytes): command = codec.decode(command)[0]\n\t\tif command.startswith(\".\"): command = command[1:]\n\t\traise RuntimeError(\"Error: unknown command or invalid arguments:  \\\"%s\\\". Enter \\\".help\\\" for help\" % (command.rstrip().replace(\"\\\\\", \"\\\\\\\\\").replace(\"\\\"\", \"\\\\\\\"\"),))",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tresults",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tresults = None\n\t\tquery = None\n\t\tquery_parameters = {}\n\t\ttry:\n\t\t\tif command.startswith(\".\"):\n\t\t\t\targs = list(parse_escaped_strings(command))\n\t\t\t\tif args[0] in (\".quit\", \".exit\"):\n\t\t\t\t\treturn 0\n\t\t\t\telif args[0] == \".help\":\n\t\t\t\t\tstdio.error(\"\"\"",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tquery",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tquery = None\n\t\tquery_parameters = {}\n\t\ttry:\n\t\t\tif command.startswith(\".\"):\n\t\t\t\targs = list(parse_escaped_strings(command))\n\t\t\t\tif args[0] in (\".quit\", \".exit\"):\n\t\t\t\t\treturn 0\n\t\t\t\telif args[0] == \".help\":\n\t\t\t\t\tstdio.error(\"\"\"\n.cd DIRECTORY          Change the working directory to DIRECTORY",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\tquery_parameters",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\tquery_parameters = {}\n\t\ttry:\n\t\t\tif command.startswith(\".\"):\n\t\t\t\targs = list(parse_escaped_strings(command))\n\t\t\t\tif args[0] in (\".quit\", \".exit\"):\n\t\t\t\t\treturn 0\n\t\t\t\telif args[0] == \".help\":\n\t\t\t\t\tstdio.error(\"\"\"\n.cd DIRECTORY          Change the working directory to DIRECTORY\n.dump                  Dump the database in an SQL text format",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\targs",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\targs = list(parse_escaped_strings(command))\n\t\t\t\tif args[0] in (\".quit\", \".exit\"):\n\t\t\t\t\treturn 0\n\t\t\t\telif args[0] == \".help\":\n\t\t\t\t\tstdio.error(\"\"\"\n.cd DIRECTORY          Change the working directory to DIRECTORY\n.dump                  Dump the database in an SQL text format\n.exit                  Exit this program\n.help                  Show this message\n.open FILE             Close existing database and reopen FILE",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tforeign_keys",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\t\tforeign_keys = db.cursor.execute(\"PRAGMA foreign_keys;\").fetchone()[0]\n\t\t\t\t\tif foreign_keys in (0, \"0\", \"off\", \"OFF\"):\n\t\t\t\t\t\tstdio.outputln(\"PRAGMA foreign_keys=OFF;\", flush=False)\n\t\t\t\t\tfor line in db.connection.iterdump():\n\t\t\t\t\t\tstdio.outputln(line, flush=False)\n\t\t\t\t\tstdio.output()\n\t\t\t\telif args[0] == \".open\":\n\t\t\t\t\tif len(args) <= 1: raise_invalid_command_error(command)\n\t\t\t\t\tfilename = args[-1]\n\t\t\t\t\tfor option in args[+1:-1]:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tfilename",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\t\tfilename = args[-1]\n\t\t\t\t\tfor option in args[+1:-1]:\n\t\t\t\t\t\traise ValueError(\"option %s not supported\" % (repr(option),))\n\t\t\t\t\ttry: db.__init__(filename)\n\t\t\t\t\texcept sqlite3.OperationalError as ex:\n\t\t\t\t\t\tex.args = ex.args[:0] + (\"Error: unable to open database \\\"%s\\\": %s\" % (filename, ex.args[0]),) + ex.args[1:]\n\t\t\t\t\t\traise\n\t\t\t\telif args[0] == \".print\":\n\t\t\t\t\tstdio.outputln(*args[1:])\n\t\t\t\telif args[0] == \".read\":",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\tex.args",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\t\t\tex.args = ex.args[:0] + (\"Error: unable to open database \\\"%s\\\": %s\" % (filename, ex.args[0]),) + ex.args[1:]\n\t\t\t\t\t\traise\n\t\t\t\telif args[0] == \".print\":\n\t\t\t\t\tstdio.outputln(*args[1:])\n\t\t\t\telif args[0] == \".read\":\n\t\t\t\t\tif len(args) != 2: raise_invalid_command_error(command)\n\t\t\t\t\texec_script(db, args[1], ignore_io_errors)\n\t\t\t\telif args[0] == \".schema\":\n\t\t\t\t\tif len(args) > 2: raise_invalid_command_error(command)\n\t\t\t\t\tpattern = args[1] if len(args) > 1 else None",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tpattern",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\t\tpattern = args[1] if len(args) > 1 else None\n\t\t\t\t\tquery_parameters['type'] = 'table'\n\t\t\t\t\tif pattern is not None:\n\t\t\t\t\t\tquery_parameters['pattern'] = pattern\n\t\t\t\t\tquery = \"SELECT sql || ';' FROM sqlite_master WHERE type = :type\" + (\" AND name LIKE :pattern\" if pattern is not None else \"\") + \";\"\n\t\t\t\telif args[0] == \".show\":\n\t\t\t\t\tif len(args) > 2: raise_invalid_command_error(command)\n\t\t\t\t\tstdio.errorln(\"    filename:\", db.name)\n\t\t\t\telif args[0] == \".tables\":\n\t\t\t\t\tif len(args) > 2: raise_invalid_command_error(command)",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tquery_parameters['type']",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\t\tquery_parameters['type'] = 'table'\n\t\t\t\t\tif pattern is not None:\n\t\t\t\t\t\tquery_parameters['pattern'] = pattern\n\t\t\t\t\tquery = \"SELECT sql || ';' FROM sqlite_master WHERE type = :type\" + (\" AND name LIKE :pattern\" if pattern is not None else \"\") + \";\"\n\t\t\t\telif args[0] == \".show\":\n\t\t\t\t\tif len(args) > 2: raise_invalid_command_error(command)\n\t\t\t\t\tstdio.errorln(\"    filename:\", db.name)\n\t\t\t\telif args[0] == \".tables\":\n\t\t\t\t\tif len(args) > 2: raise_invalid_command_error(command)\n\t\t\t\t\tpattern = args[1] if len(args) > 1 else None",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\tquery_parameters['pattern']",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\t\t\tquery_parameters['pattern'] = pattern\n\t\t\t\t\tquery = \"SELECT sql || ';' FROM sqlite_master WHERE type = :type\" + (\" AND name LIKE :pattern\" if pattern is not None else \"\") + \";\"\n\t\t\t\telif args[0] == \".show\":\n\t\t\t\t\tif len(args) > 2: raise_invalid_command_error(command)\n\t\t\t\t\tstdio.errorln(\"    filename:\", db.name)\n\t\t\t\telif args[0] == \".tables\":\n\t\t\t\t\tif len(args) > 2: raise_invalid_command_error(command)\n\t\t\t\t\tpattern = args[1] if len(args) > 1 else None\n\t\t\t\t\tquery_parameters['type'] = 'table'\n\t\t\t\t\tif pattern is not None:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tquery",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\t\tquery = \"SELECT sql || ';' FROM sqlite_master WHERE type = :type\" + (\" AND name LIKE :pattern\" if pattern is not None else \"\") + \";\"\n\t\t\t\telif args[0] == \".show\":\n\t\t\t\t\tif len(args) > 2: raise_invalid_command_error(command)\n\t\t\t\t\tstdio.errorln(\"    filename:\", db.name)\n\t\t\t\telif args[0] == \".tables\":\n\t\t\t\t\tif len(args) > 2: raise_invalid_command_error(command)\n\t\t\t\t\tpattern = args[1] if len(args) > 1 else None\n\t\t\t\t\tquery_parameters['type'] = 'table'\n\t\t\t\t\tif pattern is not None:\n\t\t\t\t\t\tquery_parameters['pattern'] = pattern",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tpattern",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\t\tpattern = args[1] if len(args) > 1 else None\n\t\t\t\t\tquery_parameters['type'] = 'table'\n\t\t\t\t\tif pattern is not None:\n\t\t\t\t\t\tquery_parameters['pattern'] = pattern\n\t\t\t\t\tquery = \"SELECT name FROM sqlite_master WHERE type = :type\" + (\" AND name LIKE :pattern\" if pattern is not None else \"\") + \";\"\n\t\t\t\telse:\n\t\t\t\t\traise_invalid_command_error(args[0])\n\t\t\telse:\n\t\t\t\tquery = command\n\t\t\tif query is not None:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tquery_parameters['type']",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\t\tquery_parameters['type'] = 'table'\n\t\t\t\t\tif pattern is not None:\n\t\t\t\t\t\tquery_parameters['pattern'] = pattern\n\t\t\t\t\tquery = \"SELECT name FROM sqlite_master WHERE type = :type\" + (\" AND name LIKE :pattern\" if pattern is not None else \"\") + \";\"\n\t\t\t\telse:\n\t\t\t\t\traise_invalid_command_error(args[0])\n\t\t\telse:\n\t\t\t\tquery = command\n\t\t\tif query is not None:\n\t\t\t\tresults = db.cursor.execute(query if isinstance(query, unicode) else codec.decode(query, 'surrogatereplace')[0], query_parameters)",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\tquery_parameters['pattern']",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\t\t\tquery_parameters['pattern'] = pattern\n\t\t\t\t\tquery = \"SELECT name FROM sqlite_master WHERE type = :type\" + (\" AND name LIKE :pattern\" if pattern is not None else \"\") + \";\"\n\t\t\t\telse:\n\t\t\t\t\traise_invalid_command_error(args[0])\n\t\t\telse:\n\t\t\t\tquery = command\n\t\t\tif query is not None:\n\t\t\t\tresults = db.cursor.execute(query if isinstance(query, unicode) else codec.decode(query, 'surrogatereplace')[0], query_parameters)\n\t\texcept (RuntimeError, OSError, FileNotFoundError, sqlite3.OperationalError) as ex:\n\t\t\tstdio.errorln(exception_encode(ex, codec))",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tquery",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\t\tquery = \"SELECT name FROM sqlite_master WHERE type = :type\" + (\" AND name LIKE :pattern\" if pattern is not None else \"\") + \";\"\n\t\t\t\telse:\n\t\t\t\t\traise_invalid_command_error(args[0])\n\t\t\telse:\n\t\t\t\tquery = command\n\t\t\tif query is not None:\n\t\t\t\tresults = db.cursor.execute(query if isinstance(query, unicode) else codec.decode(query, 'surrogatereplace')[0], query_parameters)\n\t\texcept (RuntimeError, OSError, FileNotFoundError, sqlite3.OperationalError) as ex:\n\t\t\tstdio.errorln(exception_encode(ex, codec))\n\t\tif results is not None:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tquery",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\tquery = command\n\t\t\tif query is not None:\n\t\t\t\tresults = db.cursor.execute(query if isinstance(query, unicode) else codec.decode(query, 'surrogatereplace')[0], query_parameters)\n\t\texcept (RuntimeError, OSError, FileNotFoundError, sqlite3.OperationalError) as ex:\n\t\t\tstdio.errorln(exception_encode(ex, codec))\n\t\tif results is not None:\n\t\t\tfor row in results:\n\t\t\t\tstdio.outputln(*tuple(map(lambda item: item if item is not None else \"\", row)), sep=\"|\", flush=False)\n\t\t\tstdio.output()\n\tif db:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tresults",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\tresults = db.cursor.execute(query if isinstance(query, unicode) else codec.decode(query, 'surrogatereplace')[0], query_parameters)\n\t\texcept (RuntimeError, OSError, FileNotFoundError, sqlite3.OperationalError) as ex:\n\t\t\tstdio.errorln(exception_encode(ex, codec))\n\t\tif results is not None:\n\t\t\tfor row in results:\n\t\t\t\tstdio.outputln(*tuple(map(lambda item: item if item is not None else \"\", row)), sep=\"|\", flush=False)\n\t\t\tstdio.output()\n\tif db:\n\t\tif parsed_args and parsed_args.init:\n\t\t\tif is_nonpipe_input: stdio.errorln(\"-- Loading resources from\", parsed_args.init)",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\tshow_prompt",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\tshow_prompt = init_show_prompt\n\t\t\tto_write = []\n\t\t\tif index < len(init_sql):\n\t\t\t\tline = init_sql[index]\n\t\t\t\tif not line.startswith(\".\") and not line.rstrip().endswith(\";\"):\n\t\t\t\t\tline += \";\"\n\t\t\telif index == len(init_sql) and len(init_sql) > 0:\n\t\t\t\tline = None\n\t\t\telse:\n\t\t\t\tif show_prompt:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\tto_write",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\tto_write = []\n\t\t\tif index < len(init_sql):\n\t\t\t\tline = init_sql[index]\n\t\t\t\tif not line.startswith(\".\") and not line.rstrip().endswith(\";\"):\n\t\t\t\t\tline += \";\"\n\t\t\telif index == len(init_sql) and len(init_sql) > 0:\n\t\t\t\tline = None\n\t\t\telse:\n\t\t\t\tif show_prompt:\n\t\t\t\t\tif not_in_the_middle_of_any_input:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tline",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\tline = init_sql[index]\n\t\t\t\tif not line.startswith(\".\") and not line.rstrip().endswith(\";\"):\n\t\t\t\t\tline += \";\"\n\t\t\telif index == len(init_sql) and len(init_sql) > 0:\n\t\t\t\tline = None\n\t\t\telse:\n\t\t\t\tif show_prompt:\n\t\t\t\t\tif not_in_the_middle_of_any_input:\n\t\t\t\t\t\tshow_prompt = False\n\t\t\t\t\t\tif index == 0:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tline",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\tline = None\n\t\t\telse:\n\t\t\t\tif show_prompt:\n\t\t\t\t\tif not_in_the_middle_of_any_input:\n\t\t\t\t\t\tshow_prompt = False\n\t\t\t\t\t\tif index == 0:\n\t\t\t\t\t\t\tto_write.append(\"SQLite version %s (adapter version %s)\\nEnter \\\".help\\\" for usage hints.\\n\" % (sqlite3.sqlite_version, sqlite3.version))\n\t\t\t\t\t\t\tif no_args:\n\t\t\t\t\t\t\t\tto_write.append(\"Connected to a transient in-memory database.\\nUse \\\".open FILENAME\\\" to reopen on a persistent database.\\n\")\n\t\t\t\t\tif index > 0 and not prev_line:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\tshow_prompt",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\t\t\tshow_prompt = False\n\t\t\t\t\t\tif index == 0:\n\t\t\t\t\t\t\tto_write.append(\"SQLite version %s (adapter version %s)\\nEnter \\\".help\\\" for usage hints.\\n\" % (sqlite3.sqlite_version, sqlite3.version))\n\t\t\t\t\t\t\tif no_args:\n\t\t\t\t\t\t\t\tto_write.append(\"Connected to a transient in-memory database.\\nUse \\\".open FILENAME\\\" to reopen on a persistent database.\\n\")\n\t\t\t\t\tif index > 0 and not prev_line:\n\t\t\t\t\t\tto_write.append(\"\\n\")\n\t\t\t\t\tto_write.append(\"%7s \" % (\"sqlite%s>\" % (\"\",) if not_in_the_middle_of_any_input else \"...>\",))\n\t\t\t\ttry:\n\t\t\t\t\tline = stdio.inputln(\"\".join(to_write))",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tline",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\t\tline = stdio.inputln(\"\".join(to_write))\n\t\t\t\texcept KeyboardInterrupt:\n\t\t\t\t\tline = \"\"\n\t\t\t\t\traise  # just kidding, don't handle it for now...\n\t\t\treturn line\n\t\tfor command in sql_commands(wrap_bytes_comparable_with_unicode_readline(read_stdin)):\n\t\t\tresult = exec_command(db, command, True)\n\t\t\tif result is not None:\n\t\t\t\treturn result\n\t\tif init_show_prompt and len(init_sql) == 0:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tline",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\t\t\tline = \"\"\n\t\t\t\t\traise  # just kidding, don't handle it for now...\n\t\t\treturn line\n\t\tfor command in sql_commands(wrap_bytes_comparable_with_unicode_readline(read_stdin)):\n\t\t\tresult = exec_command(db, command, True)\n\t\t\tif result is not None:\n\t\t\t\treturn result\n\t\tif init_show_prompt and len(init_sql) == 0:\n\t\t\tstdio.outputln()\ndef call_program(cmdline, input_text):",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\t\t\tresult",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\t\t\tresult = exec_command(db, command, True)\n\t\t\tif result is not None:\n\t\t\t\treturn result\n\t\tif init_show_prompt and len(init_sql) == 0:\n\t\t\tstdio.outputln()\ndef call_program(cmdline, input_text):\n\timport subprocess\n\treturn subprocess.Popen(cmdline, bufsize=0, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=False).communicate(input_text)\ndef test_query():\n\thexcodec = codecs.lookup('hex_codec')",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\thexcodec",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\thexcodec = codecs.lookup('hex_codec')\n\tascii = 'ascii'\n\tdata1 = b\"\\xD8\\xA2\"\n\tdata2 = b\"\\x01\\x02\\xFF\\x01\\xFF\\xFE\\xFD\"\n\tvalues = [data1, data2]\n\tquery_bytes = b'SELECT %s;' % (b\", \".join(map(lambda b: b\"X'%s'\" % (hexcodec.encode(b)[0].upper(),), values)),)\n\texpected_bytes = b\"%s\\n\" % (b\"|\".join(values),)\n\treturn query_bytes, expected_bytes\ndef cross_test(sqlite_cmdline, codec):\n\t(query_bytes, expected_bytes) = test_query()",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tascii",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tascii = 'ascii'\n\tdata1 = b\"\\xD8\\xA2\"\n\tdata2 = b\"\\x01\\x02\\xFF\\x01\\xFF\\xFE\\xFD\"\n\tvalues = [data1, data2]\n\tquery_bytes = b'SELECT %s;' % (b\", \".join(map(lambda b: b\"X'%s'\" % (hexcodec.encode(b)[0].upper(),), values)),)\n\texpected_bytes = b\"%s\\n\" % (b\"|\".join(values),)\n\treturn query_bytes, expected_bytes\ndef cross_test(sqlite_cmdline, codec):\n\t(query_bytes, expected_bytes) = test_query()\n\t(official_output, official_error) = call_program(sqlite_cmdline, query_bytes)",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tdata1",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tdata1 = b\"\\xD8\\xA2\"\n\tdata2 = b\"\\x01\\x02\\xFF\\x01\\xFF\\xFE\\xFD\"\n\tvalues = [data1, data2]\n\tquery_bytes = b'SELECT %s;' % (b\", \".join(map(lambda b: b\"X'%s'\" % (hexcodec.encode(b)[0].upper(),), values)),)\n\texpected_bytes = b\"%s\\n\" % (b\"|\".join(values),)\n\treturn query_bytes, expected_bytes\ndef cross_test(sqlite_cmdline, codec):\n\t(query_bytes, expected_bytes) = test_query()\n\t(official_output, official_error) = call_program(sqlite_cmdline, query_bytes)\n\t# We can't use os.linesep here since binaries may belong to different platforms (Win32/MinGW vs. MSYS/Cygwin vs. WSL...)",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tdata2",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tdata2 = b\"\\x01\\x02\\xFF\\x01\\xFF\\xFE\\xFD\"\n\tvalues = [data1, data2]\n\tquery_bytes = b'SELECT %s;' % (b\", \".join(map(lambda b: b\"X'%s'\" % (hexcodec.encode(b)[0].upper(),), values)),)\n\texpected_bytes = b\"%s\\n\" % (b\"|\".join(values),)\n\treturn query_bytes, expected_bytes\ndef cross_test(sqlite_cmdline, codec):\n\t(query_bytes, expected_bytes) = test_query()\n\t(official_output, official_error) = call_program(sqlite_cmdline, query_bytes)\n\t# We can't use os.linesep here since binaries may belong to different platforms (Win32/MinGW vs. MSYS/Cygwin vs. WSL...)\n\tofficial_output = official_output.replace(b\"\\r\\n\", b\"\\n\")",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tvalues",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tvalues = [data1, data2]\n\tquery_bytes = b'SELECT %s;' % (b\", \".join(map(lambda b: b\"X'%s'\" % (hexcodec.encode(b)[0].upper(),), values)),)\n\texpected_bytes = b\"%s\\n\" % (b\"|\".join(values),)\n\treturn query_bytes, expected_bytes\ndef cross_test(sqlite_cmdline, codec):\n\t(query_bytes, expected_bytes) = test_query()\n\t(official_output, official_error) = call_program(sqlite_cmdline, query_bytes)\n\t# We can't use os.linesep here since binaries may belong to different platforms (Win32/MinGW vs. MSYS/Cygwin vs. WSL...)\n\tofficial_output = official_output.replace(b\"\\r\\n\", b\"\\n\")\n\tofficial_error = official_error.replace(b\"\\r\\n\", b\"\\n\")",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tquery_bytes",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tquery_bytes = b'SELECT %s;' % (b\", \".join(map(lambda b: b\"X'%s'\" % (hexcodec.encode(b)[0].upper(),), values)),)\n\texpected_bytes = b\"%s\\n\" % (b\"|\".join(values),)\n\treturn query_bytes, expected_bytes\ndef cross_test(sqlite_cmdline, codec):\n\t(query_bytes, expected_bytes) = test_query()\n\t(official_output, official_error) = call_program(sqlite_cmdline, query_bytes)\n\t# We can't use os.linesep here since binaries may belong to different platforms (Win32/MinGW vs. MSYS/Cygwin vs. WSL...)\n\tofficial_output = official_output.replace(b\"\\r\\n\", b\"\\n\")\n\tofficial_error = official_error.replace(b\"\\r\\n\", b\"\\n\")\n\tif official_output != expected_bytes:",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\texpected_bytes",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\texpected_bytes = b\"%s\\n\" % (b\"|\".join(values),)\n\treturn query_bytes, expected_bytes\ndef cross_test(sqlite_cmdline, codec):\n\t(query_bytes, expected_bytes) = test_query()\n\t(official_output, official_error) = call_program(sqlite_cmdline, query_bytes)\n\t# We can't use os.linesep here since binaries may belong to different platforms (Win32/MinGW vs. MSYS/Cygwin vs. WSL...)\n\tofficial_output = official_output.replace(b\"\\r\\n\", b\"\\n\")\n\tofficial_error = official_error.replace(b\"\\r\\n\", b\"\\n\")\n\tif official_output != expected_bytes:\n\t\traise sqlite3.ProgrammingError(\"expected bytes are wrong: official %s != expected %s\" % (repr(official_output), repr(expected_bytes)))",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tofficial_output",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tofficial_output = official_output.replace(b\"\\r\\n\", b\"\\n\")\n\tofficial_error = official_error.replace(b\"\\r\\n\", b\"\\n\")\n\tif official_output != expected_bytes:\n\t\traise sqlite3.ProgrammingError(\"expected bytes are wrong: official %s != expected %s\" % (repr(official_output), repr(expected_bytes)))\n\tif official_error:\n\t\traise sqlite3.ProgrammingError(\"did not expect errors from official binary\")\ndef self_test(codec):\n\t(query_bytes, expected_bytes) = test_query()\n\tif not (lambda stdin, stdout, stderr: not main(sys.argv[0], stdin=stdin, stdout=stdout, stderr=stderr) and stdout.getvalue() == expected_bytes)(io.BytesIO(query_bytes), io.BytesIO(), io.BytesIO()):\n\t\traise sqlite3.ProgrammingError(\"byte I/O is broken\")",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\tofficial_error",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\tofficial_error = official_error.replace(b\"\\r\\n\", b\"\\n\")\n\tif official_output != expected_bytes:\n\t\traise sqlite3.ProgrammingError(\"expected bytes are wrong: official %s != expected %s\" % (repr(official_output), repr(expected_bytes)))\n\tif official_error:\n\t\traise sqlite3.ProgrammingError(\"did not expect errors from official binary\")\ndef self_test(codec):\n\t(query_bytes, expected_bytes) = test_query()\n\tif not (lambda stdin, stdout, stderr: not main(sys.argv[0], stdin=stdin, stdout=stdout, stderr=stderr) and stdout.getvalue() == expected_bytes)(io.BytesIO(query_bytes), io.BytesIO(), io.BytesIO()):\n\t\traise sqlite3.ProgrammingError(\"byte I/O is broken\")\n\tif not (lambda stdin, stdout, stderr: not main(sys.argv[0], stdin=stdin, stdout=stdout, stderr=stderr) and stdout.getvalue() == codec.decode(expected_bytes, 'surrogateescape'))(io.StringIO(query_bytes.decode(ascii)), io.StringIO(), io.StringIO()):",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "\texit_code",
        "kind": 5,
        "importPath": "lab.lab12.sqlite_shell",
        "description": "lab.lab12.sqlite_shell",
        "peekOfCode": "\texit_code = main(*sys.argv)\n\tif exit_code not in (None, 0): raise SystemExit(exit_code)",
        "detail": "lab.lab12.sqlite_shell",
        "documentation": {}
    },
    {
        "label": "require_fernet",
        "kind": 2,
        "importPath": "projects.cats.multiplayer.leaderboard_integrity",
        "description": "projects.cats.multiplayer.leaderboard_integrity",
        "peekOfCode": "def require_fernet(f):\n    @wraps(f)\n    def wrapped(*args, **kwargs):\n        global fernet\n        if not fernet:\n            from cryptography.fernet import Fernet\n            fernet = Fernet(os.environ.get(\"FERNET_KEY\", Fernet.generate_key()))\n        return f(*args, **kwargs)\n    return wrapped\ndef token_writer(f):",
        "detail": "projects.cats.multiplayer.leaderboard_integrity",
        "documentation": {}
    },
    {
        "label": "token_writer",
        "kind": 2,
        "importPath": "projects.cats.multiplayer.leaderboard_integrity",
        "description": "projects.cats.multiplayer.leaderboard_integrity",
        "peekOfCode": "def token_writer(f):\n    @wraps(f)\n    @require_fernet\n    def wrapped(*args, **kwargs):\n        data = f(*args, **kwargs)\n        decoded = json.dumps(data).encode(\"utf-8\")\n        return fernet.encrypt(decoded).decode(\"utf-8\")\n    return wrapped\ndef token_reader(fail):\n    def decorator(f):",
        "detail": "projects.cats.multiplayer.leaderboard_integrity",
        "documentation": {}
    },
    {
        "label": "token_reader",
        "kind": 2,
        "importPath": "projects.cats.multiplayer.leaderboard_integrity",
        "description": "projects.cats.multiplayer.leaderboard_integrity",
        "peekOfCode": "def token_reader(fail):\n    def decorator(f):\n        @wraps(f)\n        @require_fernet\n        def wrapped(*, token, **kwargs):\n            from cryptography.fernet import InvalidToken\n            if not token:\n                return fail\n            try:\n                return f(",
        "detail": "projects.cats.multiplayer.leaderboard_integrity",
        "documentation": {}
    },
    {
        "label": "create_wpm_authorization",
        "kind": 2,
        "importPath": "projects.cats.multiplayer.leaderboard_integrity",
        "description": "projects.cats.multiplayer.leaderboard_integrity",
        "peekOfCode": "def create_wpm_authorization(user, wpm):\n    return {\n        \"user\": user,\n        \"wpm\": wpm,\n    }\n@token_reader(fail=0)\ndef get_authorized_limit(user, token):\n    if token[\"user\"] != user:\n        return 0\n    return token[\"wpm\"]",
        "detail": "projects.cats.multiplayer.leaderboard_integrity",
        "documentation": {}
    },
    {
        "label": "get_authorized_limit",
        "kind": 2,
        "importPath": "projects.cats.multiplayer.leaderboard_integrity",
        "description": "projects.cats.multiplayer.leaderboard_integrity",
        "peekOfCode": "def get_authorized_limit(user, token):\n    if token[\"user\"] != user:\n        return 0\n    return token[\"wpm\"]\n@token_writer\ndef encode_challenge(user, words):\n    return {\n        \"user\": user,\n        \"words\": words,\n        \"startTime\": time.time(),",
        "detail": "projects.cats.multiplayer.leaderboard_integrity",
        "documentation": {}
    },
    {
        "label": "encode_challenge",
        "kind": 2,
        "importPath": "projects.cats.multiplayer.leaderboard_integrity",
        "description": "projects.cats.multiplayer.leaderboard_integrity",
        "peekOfCode": "def encode_challenge(user, words):\n    return {\n        \"user\": user,\n        \"words\": words,\n        \"startTime\": time.time(),\n    }\n@token_reader(fail=(False, False))\ndef decode_challenge(token):\n    return token[\"user\"], token[\"words\"], token[\"startTime\"]\ndef populate_captcha_queue():",
        "detail": "projects.cats.multiplayer.leaderboard_integrity",
        "documentation": {}
    },
    {
        "label": "decode_challenge",
        "kind": 2,
        "importPath": "projects.cats.multiplayer.leaderboard_integrity",
        "description": "projects.cats.multiplayer.leaderboard_integrity",
        "peekOfCode": "def decode_challenge(token):\n    return token[\"user\"], token[\"words\"], token[\"startTime\"]\ndef populate_captcha_queue():\n    while captcha_queue.qsize() < CAPTCHA_QUEUE_LEN:\n        captcha_queue.put(generate_captcha())\ndef generate_captcha():\n    from claptcha import Claptcha\n    word = random.choice([x for x in COMMON_WORDS_SET if len(x) < CAPTCHA_WORD_LEN])\n    c = Claptcha(word, \"multiplayer/FreeMono.ttf\", margin=(20, 10))\n    image_b64 = base64.b64encode(c.bytes[1].getvalue()).decode(\"utf-8\")",
        "detail": "projects.cats.multiplayer.leaderboard_integrity",
        "documentation": {}
    },
    {
        "label": "populate_captcha_queue",
        "kind": 2,
        "importPath": "projects.cats.multiplayer.leaderboard_integrity",
        "description": "projects.cats.multiplayer.leaderboard_integrity",
        "peekOfCode": "def populate_captcha_queue():\n    while captcha_queue.qsize() < CAPTCHA_QUEUE_LEN:\n        captcha_queue.put(generate_captcha())\ndef generate_captcha():\n    from claptcha import Claptcha\n    word = random.choice([x for x in COMMON_WORDS_SET if len(x) < CAPTCHA_WORD_LEN])\n    c = Claptcha(word, \"multiplayer/FreeMono.ttf\", margin=(20, 10))\n    image_b64 = base64.b64encode(c.bytes[1].getvalue()).decode(\"utf-8\")\n    return \"data:image/png;base64,\" + image_b64, word\ndef get_captcha_urls(num_words=CAPTCHA_LENGTH):",
        "detail": "projects.cats.multiplayer.leaderboard_integrity",
        "documentation": {}
    },
    {
        "label": "generate_captcha",
        "kind": 2,
        "importPath": "projects.cats.multiplayer.leaderboard_integrity",
        "description": "projects.cats.multiplayer.leaderboard_integrity",
        "peekOfCode": "def generate_captcha():\n    from claptcha import Claptcha\n    word = random.choice([x for x in COMMON_WORDS_SET if len(x) < CAPTCHA_WORD_LEN])\n    c = Claptcha(word, \"multiplayer/FreeMono.ttf\", margin=(20, 10))\n    image_b64 = base64.b64encode(c.bytes[1].getvalue()).decode(\"utf-8\")\n    return \"data:image/png;base64,\" + image_b64, word\ndef get_captcha_urls(num_words=CAPTCHA_LENGTH):\n    Thread(target=populate_captcha_queue).start()\n    images, words = [], []\n    for _ in range(num_words):",
        "detail": "projects.cats.multiplayer.leaderboard_integrity",
        "documentation": {}
    },
    {
        "label": "get_captcha_urls",
        "kind": 2,
        "importPath": "projects.cats.multiplayer.leaderboard_integrity",
        "description": "projects.cats.multiplayer.leaderboard_integrity",
        "peekOfCode": "def get_captcha_urls(num_words=CAPTCHA_LENGTH):\n    Thread(target=populate_captcha_queue).start()\n    images, words = [], []\n    for _ in range(num_words):\n        image, word = captcha_queue.get()\n        images.append(image)\n        words.append(word)\n    return images, words",
        "detail": "projects.cats.multiplayer.leaderboard_integrity",
        "documentation": {}
    },
    {
        "label": "fernet",
        "kind": 5,
        "importPath": "projects.cats.multiplayer.leaderboard_integrity",
        "description": "projects.cats.multiplayer.leaderboard_integrity",
        "peekOfCode": "fernet = None\nCOMMON_WORDS_SET = set(cats.lines_from_file(\"data/common_words.txt\"))\nCAPTCHA_QUEUE_LEN = 200\nCAPTCHA_LENGTH = 10\nCAPTCHA_WORD_LEN = 10\ncaptcha_queue = Queue()\ndef require_fernet(f):\n    @wraps(f)\n    def wrapped(*args, **kwargs):\n        global fernet",
        "detail": "projects.cats.multiplayer.leaderboard_integrity",
        "documentation": {}
    },
    {
        "label": "COMMON_WORDS_SET",
        "kind": 5,
        "importPath": "projects.cats.multiplayer.leaderboard_integrity",
        "description": "projects.cats.multiplayer.leaderboard_integrity",
        "peekOfCode": "COMMON_WORDS_SET = set(cats.lines_from_file(\"data/common_words.txt\"))\nCAPTCHA_QUEUE_LEN = 200\nCAPTCHA_LENGTH = 10\nCAPTCHA_WORD_LEN = 10\ncaptcha_queue = Queue()\ndef require_fernet(f):\n    @wraps(f)\n    def wrapped(*args, **kwargs):\n        global fernet\n        if not fernet:",
        "detail": "projects.cats.multiplayer.leaderboard_integrity",
        "documentation": {}
    },
    {
        "label": "CAPTCHA_QUEUE_LEN",
        "kind": 5,
        "importPath": "projects.cats.multiplayer.leaderboard_integrity",
        "description": "projects.cats.multiplayer.leaderboard_integrity",
        "peekOfCode": "CAPTCHA_QUEUE_LEN = 200\nCAPTCHA_LENGTH = 10\nCAPTCHA_WORD_LEN = 10\ncaptcha_queue = Queue()\ndef require_fernet(f):\n    @wraps(f)\n    def wrapped(*args, **kwargs):\n        global fernet\n        if not fernet:\n            from cryptography.fernet import Fernet",
        "detail": "projects.cats.multiplayer.leaderboard_integrity",
        "documentation": {}
    },
    {
        "label": "CAPTCHA_LENGTH",
        "kind": 5,
        "importPath": "projects.cats.multiplayer.leaderboard_integrity",
        "description": "projects.cats.multiplayer.leaderboard_integrity",
        "peekOfCode": "CAPTCHA_LENGTH = 10\nCAPTCHA_WORD_LEN = 10\ncaptcha_queue = Queue()\ndef require_fernet(f):\n    @wraps(f)\n    def wrapped(*args, **kwargs):\n        global fernet\n        if not fernet:\n            from cryptography.fernet import Fernet\n            fernet = Fernet(os.environ.get(\"FERNET_KEY\", Fernet.generate_key()))",
        "detail": "projects.cats.multiplayer.leaderboard_integrity",
        "documentation": {}
    },
    {
        "label": "CAPTCHA_WORD_LEN",
        "kind": 5,
        "importPath": "projects.cats.multiplayer.leaderboard_integrity",
        "description": "projects.cats.multiplayer.leaderboard_integrity",
        "peekOfCode": "CAPTCHA_WORD_LEN = 10\ncaptcha_queue = Queue()\ndef require_fernet(f):\n    @wraps(f)\n    def wrapped(*args, **kwargs):\n        global fernet\n        if not fernet:\n            from cryptography.fernet import Fernet\n            fernet = Fernet(os.environ.get(\"FERNET_KEY\", Fernet.generate_key()))\n        return f(*args, **kwargs)",
        "detail": "projects.cats.multiplayer.leaderboard_integrity",
        "documentation": {}
    },
    {
        "label": "captcha_queue",
        "kind": 5,
        "importPath": "projects.cats.multiplayer.leaderboard_integrity",
        "description": "projects.cats.multiplayer.leaderboard_integrity",
        "peekOfCode": "captcha_queue = Queue()\ndef require_fernet(f):\n    @wraps(f)\n    def wrapped(*args, **kwargs):\n        global fernet\n        if not fernet:\n            from cryptography.fernet import Fernet\n            fernet = Fernet(os.environ.get(\"FERNET_KEY\", Fernet.generate_key()))\n        return f(*args, **kwargs)\n    return wrapped",
        "detail": "projects.cats.multiplayer.leaderboard_integrity",
        "documentation": {}
    },
    {
        "label": "db_init",
        "kind": 2,
        "importPath": "projects.cats.multiplayer.multiplayer",
        "description": "projects.cats.multiplayer.multiplayer",
        "peekOfCode": "def db_init():\n    global connect_db\n    from common.db import connect_db\n    with connect_db() as db:\n        db(\n            \"\"\"CREATE TABLE IF NOT EXISTS leaderboard (\n        name varchar(128),\n        user_id varchar(128),\n        wpm double,\n        PRIMARY KEY (`user_id`)",
        "detail": "projects.cats.multiplayer.multiplayer",
        "documentation": {}
    },
    {
        "label": "create_multiplayer_server",
        "kind": 2,
        "importPath": "projects.cats.multiplayer.multiplayer",
        "description": "projects.cats.multiplayer.multiplayer",
        "peekOfCode": "def create_multiplayer_server():\n    State = namedtuple(\"State\", [\"queue\", \"game_lookup\", \"game_data\", \"progress\"])\n    State = State({}, {}, {}, defaultdict(list))\n    @route\n    @server_only\n    def provide_id():\n        return randrange(1000000000)\n    @route\n    @forward_to_server\n    def request_match(id):",
        "detail": "projects.cats.multiplayer.multiplayer",
        "documentation": {}
    },
    {
        "label": "MIN_PLAYERS",
        "kind": 5,
        "importPath": "projects.cats.multiplayer.multiplayer",
        "description": "projects.cats.multiplayer.multiplayer",
        "peekOfCode": "MIN_PLAYERS = 2\nMAX_PLAYERS = 4\nQUEUE_TIMEOUT = timedelta(seconds=1)\nMAX_WAIT = timedelta(seconds=5)\nMAX_NAME_LENGTH = 90\nMAX_UNVERIFIED_WPM = 90\nCAPTCHA_ACCURACY_THRESHOLD = 80\nCAPTCHA_SLOWDOWN_FACTOR = 0.8\ndef db_init():\n    global connect_db",
        "detail": "projects.cats.multiplayer.multiplayer",
        "documentation": {}
    },
    {
        "label": "MAX_PLAYERS",
        "kind": 5,
        "importPath": "projects.cats.multiplayer.multiplayer",
        "description": "projects.cats.multiplayer.multiplayer",
        "peekOfCode": "MAX_PLAYERS = 4\nQUEUE_TIMEOUT = timedelta(seconds=1)\nMAX_WAIT = timedelta(seconds=5)\nMAX_NAME_LENGTH = 90\nMAX_UNVERIFIED_WPM = 90\nCAPTCHA_ACCURACY_THRESHOLD = 80\nCAPTCHA_SLOWDOWN_FACTOR = 0.8\ndef db_init():\n    global connect_db\n    from common.db import connect_db",
        "detail": "projects.cats.multiplayer.multiplayer",
        "documentation": {}
    },
    {
        "label": "QUEUE_TIMEOUT",
        "kind": 5,
        "importPath": "projects.cats.multiplayer.multiplayer",
        "description": "projects.cats.multiplayer.multiplayer",
        "peekOfCode": "QUEUE_TIMEOUT = timedelta(seconds=1)\nMAX_WAIT = timedelta(seconds=5)\nMAX_NAME_LENGTH = 90\nMAX_UNVERIFIED_WPM = 90\nCAPTCHA_ACCURACY_THRESHOLD = 80\nCAPTCHA_SLOWDOWN_FACTOR = 0.8\ndef db_init():\n    global connect_db\n    from common.db import connect_db\n    with connect_db() as db:",
        "detail": "projects.cats.multiplayer.multiplayer",
        "documentation": {}
    },
    {
        "label": "MAX_WAIT",
        "kind": 5,
        "importPath": "projects.cats.multiplayer.multiplayer",
        "description": "projects.cats.multiplayer.multiplayer",
        "peekOfCode": "MAX_WAIT = timedelta(seconds=5)\nMAX_NAME_LENGTH = 90\nMAX_UNVERIFIED_WPM = 90\nCAPTCHA_ACCURACY_THRESHOLD = 80\nCAPTCHA_SLOWDOWN_FACTOR = 0.8\ndef db_init():\n    global connect_db\n    from common.db import connect_db\n    with connect_db() as db:\n        db(",
        "detail": "projects.cats.multiplayer.multiplayer",
        "documentation": {}
    },
    {
        "label": "MAX_NAME_LENGTH",
        "kind": 5,
        "importPath": "projects.cats.multiplayer.multiplayer",
        "description": "projects.cats.multiplayer.multiplayer",
        "peekOfCode": "MAX_NAME_LENGTH = 90\nMAX_UNVERIFIED_WPM = 90\nCAPTCHA_ACCURACY_THRESHOLD = 80\nCAPTCHA_SLOWDOWN_FACTOR = 0.8\ndef db_init():\n    global connect_db\n    from common.db import connect_db\n    with connect_db() as db:\n        db(\n            \"\"\"CREATE TABLE IF NOT EXISTS leaderboard (",
        "detail": "projects.cats.multiplayer.multiplayer",
        "documentation": {}
    },
    {
        "label": "MAX_UNVERIFIED_WPM",
        "kind": 5,
        "importPath": "projects.cats.multiplayer.multiplayer",
        "description": "projects.cats.multiplayer.multiplayer",
        "peekOfCode": "MAX_UNVERIFIED_WPM = 90\nCAPTCHA_ACCURACY_THRESHOLD = 80\nCAPTCHA_SLOWDOWN_FACTOR = 0.8\ndef db_init():\n    global connect_db\n    from common.db import connect_db\n    with connect_db() as db:\n        db(\n            \"\"\"CREATE TABLE IF NOT EXISTS leaderboard (\n        name varchar(128),",
        "detail": "projects.cats.multiplayer.multiplayer",
        "documentation": {}
    },
    {
        "label": "CAPTCHA_ACCURACY_THRESHOLD",
        "kind": 5,
        "importPath": "projects.cats.multiplayer.multiplayer",
        "description": "projects.cats.multiplayer.multiplayer",
        "peekOfCode": "CAPTCHA_ACCURACY_THRESHOLD = 80\nCAPTCHA_SLOWDOWN_FACTOR = 0.8\ndef db_init():\n    global connect_db\n    from common.db import connect_db\n    with connect_db() as db:\n        db(\n            \"\"\"CREATE TABLE IF NOT EXISTS leaderboard (\n        name varchar(128),\n        user_id varchar(128),",
        "detail": "projects.cats.multiplayer.multiplayer",
        "documentation": {}
    },
    {
        "label": "CAPTCHA_SLOWDOWN_FACTOR",
        "kind": 5,
        "importPath": "projects.cats.multiplayer.multiplayer",
        "description": "projects.cats.multiplayer.multiplayer",
        "peekOfCode": "CAPTCHA_SLOWDOWN_FACTOR = 0.8\ndef db_init():\n    global connect_db\n    from common.db import connect_db\n    with connect_db() as db:\n        db(\n            \"\"\"CREATE TABLE IF NOT EXISTS leaderboard (\n        name varchar(128),\n        user_id varchar(128),\n        wpm double,",
        "detail": "projects.cats.multiplayer.multiplayer",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "projects.cats.tests.01",
        "description": "projects.cats.tests.01",
        "peekOfCode": "test = {\n  'name': 'Problem 1',\n  'points': 1,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> ps = ['short', 'really long', 'tiny']\n          >>> s = lambda p: len(p) <= 5",
        "detail": "projects.cats.tests.01",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "projects.cats.tests.02",
        "description": "projects.cats.tests.02",
        "peekOfCode": "test = {\n  'name': 'Problem 2',\n  'points': 1,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> dogs = about(['dogs', 'hounds'])\n          >>> dogs('A paragraph about cats.')",
        "detail": "projects.cats.tests.02",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "projects.cats.tests.03",
        "description": "projects.cats.tests.03",
        "peekOfCode": "test = {\n  'name': 'Problem 3',\n  'points': 2,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> accuracy(\"12345\", \"12345\") # This should return 100.0 (not the integer 100!)\n          100.0",
        "detail": "projects.cats.tests.03",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "projects.cats.tests.04",
        "description": "projects.cats.tests.04",
        "peekOfCode": "test = {\n  'name': 'Problem 4',\n  'points': 1,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> wpm(\"12345\", 3) # Note: wpm returns a float (with a decimal point)\n          20.0",
        "detail": "projects.cats.tests.04",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "projects.cats.tests.05",
        "description": "projects.cats.tests.05",
        "peekOfCode": "test = {\n  'name': 'Problem 5',\n  'points': 2,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> abs_diff = lambda w1, w2, limit: abs(len(w2) - len(w1))\n          >>> autocorrect(\"cul\", [\"culture\", \"cult\", \"cultivate\"], abs_diff, 10)",
        "detail": "projects.cats.tests.05",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "projects.cats.tests.06",
        "description": "projects.cats.tests.06",
        "peekOfCode": "test = {\n  'name': 'Problem 6',\n  'points': 3,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> big_limit = 10\n          >>> feline_fixes(\"car\", \"cad\", big_limit)",
        "detail": "projects.cats.tests.06",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "projects.cats.tests.07",
        "description": "projects.cats.tests.07",
        "peekOfCode": "test = {\n  'name': 'Problem 7',\n  'points': 3,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> big_limit = 10\n          >>> minimum_mewtations(\"wind\", \"wind\", big_limit)",
        "detail": "projects.cats.tests.07",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "projects.cats.tests.08",
        "description": "projects.cats.tests.08",
        "peekOfCode": "test = {\n  'name': 'Problem 8',\n  'points': 2,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> typed = ['I', 'have', 'begun']\n          >>> source = ['I', 'have', 'begun', 'to', 'type']",
        "detail": "projects.cats.tests.08",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "projects.cats.tests.09",
        "description": "projects.cats.tests.09",
        "peekOfCode": "test = {\n  'name': 'Problem 9',\n  'points': 2,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> p = [[1, 4, 6, 7], [0, 4, 6, 9]]\n          >>> words = ['This', 'is', 'fun']",
        "detail": "projects.cats.tests.09",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "projects.cats.tests.10",
        "description": "projects.cats.tests.10",
        "peekOfCode": "test = {\n  'name': 'Problem 10',\n  'points': 2,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> p0 = [2, 2, 3]\n          >>> p1 = [6, 1, 2]",
        "detail": "projects.cats.tests.10",
        "documentation": {}
    },
    {
        "label": "AbstractionViolation",
        "kind": 6,
        "importPath": "projects.cats.tests.abstraction_check",
        "description": "projects.cats.tests.abstraction_check",
        "peekOfCode": "class AbstractionViolation(Exception):\n    pass\ndef datatype(obj):\n    return type(obj).__name__\n# Generic abstract data type\nclass Abstract:\n    def __add__(self, other):\n        raise AbstractionViolation(\"Can't add {} object to {}\".format(datatype(self), datatype(other)))\n    def __radd__(self, other):\n        raise AbstractionViolation(\"Can't add {} object to {}\".format(datatype(self), datatype(other)))",
        "detail": "projects.cats.tests.abstraction_check",
        "documentation": {}
    },
    {
        "label": "Abstract",
        "kind": 6,
        "importPath": "projects.cats.tests.abstraction_check",
        "description": "projects.cats.tests.abstraction_check",
        "peekOfCode": "class Abstract:\n    def __add__(self, other):\n        raise AbstractionViolation(\"Can't add {} object to {}\".format(datatype(self), datatype(other)))\n    def __radd__(self, other):\n        raise AbstractionViolation(\"Can't add {} object to {}\".format(datatype(self), datatype(other)))\n    def __eq__(self, other):\n        if isinstance(other, type(self)):\n            return other is self\n        raise AbstractionViolation(\"Can't use == on {} object and {}\".format(datatype(self), datatype(other)))\n    def __ne__(self, other):",
        "detail": "projects.cats.tests.abstraction_check",
        "documentation": {}
    },
    {
        "label": "Match",
        "kind": 6,
        "importPath": "projects.cats.tests.abstraction_check",
        "description": "projects.cats.tests.abstraction_check",
        "peekOfCode": "class Match(Abstract):\n    def __init__(self, words, timestamps_per_player):\n        self.a, self.b = words, timestamps_per_player\n    def __repr__(self):\n        return '<Match {} {}>'.format(self.a, self.b)\nmatch = Match\nget_word = lambda u, v: u.a[v]\nget_all_words = lambda u: u.a\nget_all_times = lambda u: u.b\ntime = lambda u, v, w: u.b[v][w]",
        "detail": "projects.cats.tests.abstraction_check",
        "documentation": {}
    },
    {
        "label": "datatype",
        "kind": 2,
        "importPath": "projects.cats.tests.abstraction_check",
        "description": "projects.cats.tests.abstraction_check",
        "peekOfCode": "def datatype(obj):\n    return type(obj).__name__\n# Generic abstract data type\nclass Abstract:\n    def __add__(self, other):\n        raise AbstractionViolation(\"Can't add {} object to {}\".format(datatype(self), datatype(other)))\n    def __radd__(self, other):\n        raise AbstractionViolation(\"Can't add {} object to {}\".format(datatype(self), datatype(other)))\n    def __eq__(self, other):\n        if isinstance(other, type(self)):",
        "detail": "projects.cats.tests.abstraction_check",
        "documentation": {}
    },
    {
        "label": "swap_implementations",
        "kind": 2,
        "importPath": "projects.cats.tests.abstraction_check",
        "description": "projects.cats.tests.abstraction_check",
        "peekOfCode": "def swap_implementations(impl):\n    # save other implementations\n    old['match'] = impl.match, impl.get_word, impl.get_all_words, impl.get_all_times, impl.time\n    # save our implementations\n    new_match = match, get_word, get_all_words, get_all_times, time\n    # replace impl's implementations with ours\n    impl.match, impl.get_word, impl.get_all_words, impl.get_all_times, impl.time = match, get_word, get_all_words, get_all_times, time\ndef restore_implementations(impl):\n    impl.match, impl.get_word, impl.get_all_words, impl.get_all_times, impl.time = old['match']",
        "detail": "projects.cats.tests.abstraction_check",
        "documentation": {}
    },
    {
        "label": "restore_implementations",
        "kind": 2,
        "importPath": "projects.cats.tests.abstraction_check",
        "description": "projects.cats.tests.abstraction_check",
        "peekOfCode": "def restore_implementations(impl):\n    impl.match, impl.get_word, impl.get_all_words, impl.get_all_times, impl.time = old['match']",
        "detail": "projects.cats.tests.abstraction_check",
        "documentation": {}
    },
    {
        "label": "match",
        "kind": 5,
        "importPath": "projects.cats.tests.abstraction_check",
        "description": "projects.cats.tests.abstraction_check",
        "peekOfCode": "match = Match\nget_word = lambda u, v: u.a[v]\nget_all_words = lambda u: u.a\nget_all_times = lambda u: u.b\ntime = lambda u, v, w: u.b[v][w]\nold = {}\ndef swap_implementations(impl):\n    # save other implementations\n    old['match'] = impl.match, impl.get_word, impl.get_all_words, impl.get_all_times, impl.time\n    # save our implementations",
        "detail": "projects.cats.tests.abstraction_check",
        "documentation": {}
    },
    {
        "label": "get_word",
        "kind": 5,
        "importPath": "projects.cats.tests.abstraction_check",
        "description": "projects.cats.tests.abstraction_check",
        "peekOfCode": "get_word = lambda u, v: u.a[v]\nget_all_words = lambda u: u.a\nget_all_times = lambda u: u.b\ntime = lambda u, v, w: u.b[v][w]\nold = {}\ndef swap_implementations(impl):\n    # save other implementations\n    old['match'] = impl.match, impl.get_word, impl.get_all_words, impl.get_all_times, impl.time\n    # save our implementations\n    new_match = match, get_word, get_all_words, get_all_times, time",
        "detail": "projects.cats.tests.abstraction_check",
        "documentation": {}
    },
    {
        "label": "get_all_words",
        "kind": 5,
        "importPath": "projects.cats.tests.abstraction_check",
        "description": "projects.cats.tests.abstraction_check",
        "peekOfCode": "get_all_words = lambda u: u.a\nget_all_times = lambda u: u.b\ntime = lambda u, v, w: u.b[v][w]\nold = {}\ndef swap_implementations(impl):\n    # save other implementations\n    old['match'] = impl.match, impl.get_word, impl.get_all_words, impl.get_all_times, impl.time\n    # save our implementations\n    new_match = match, get_word, get_all_words, get_all_times, time\n    # replace impl's implementations with ours",
        "detail": "projects.cats.tests.abstraction_check",
        "documentation": {}
    },
    {
        "label": "get_all_times",
        "kind": 5,
        "importPath": "projects.cats.tests.abstraction_check",
        "description": "projects.cats.tests.abstraction_check",
        "peekOfCode": "get_all_times = lambda u: u.b\ntime = lambda u, v, w: u.b[v][w]\nold = {}\ndef swap_implementations(impl):\n    # save other implementations\n    old['match'] = impl.match, impl.get_word, impl.get_all_words, impl.get_all_times, impl.time\n    # save our implementations\n    new_match = match, get_word, get_all_words, get_all_times, time\n    # replace impl's implementations with ours\n    impl.match, impl.get_word, impl.get_all_words, impl.get_all_times, impl.time = match, get_word, get_all_words, get_all_times, time",
        "detail": "projects.cats.tests.abstraction_check",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 5,
        "importPath": "projects.cats.tests.abstraction_check",
        "description": "projects.cats.tests.abstraction_check",
        "peekOfCode": "time = lambda u, v, w: u.b[v][w]\nold = {}\ndef swap_implementations(impl):\n    # save other implementations\n    old['match'] = impl.match, impl.get_word, impl.get_all_words, impl.get_all_times, impl.time\n    # save our implementations\n    new_match = match, get_word, get_all_words, get_all_times, time\n    # replace impl's implementations with ours\n    impl.match, impl.get_word, impl.get_all_words, impl.get_all_times, impl.time = match, get_word, get_all_words, get_all_times, time\ndef restore_implementations(impl):",
        "detail": "projects.cats.tests.abstraction_check",
        "documentation": {}
    },
    {
        "label": "old",
        "kind": 5,
        "importPath": "projects.cats.tests.abstraction_check",
        "description": "projects.cats.tests.abstraction_check",
        "peekOfCode": "old = {}\ndef swap_implementations(impl):\n    # save other implementations\n    old['match'] = impl.match, impl.get_word, impl.get_all_words, impl.get_all_times, impl.time\n    # save our implementations\n    new_match = match, get_word, get_all_words, get_all_times, time\n    # replace impl's implementations with ours\n    impl.match, impl.get_word, impl.get_all_words, impl.get_all_times, impl.time = match, get_word, get_all_words, get_all_times, time\ndef restore_implementations(impl):\n    impl.match, impl.get_word, impl.get_all_words, impl.get_all_times, impl.time = old['match']",
        "detail": "projects.cats.tests.abstraction_check",
        "documentation": {}
    },
    {
        "label": "ExclusionChecker",
        "kind": 6,
        "importPath": "projects.cats.tests.construct_check",
        "description": "projects.cats.tests.construct_check",
        "peekOfCode": "class ExclusionChecker(NodeVisitor):\n    \"\"\"An AST visitor that checks that certain constructs are excluded from\n    parts of a program.  ExclusionChecker(EXC) checks that AST node types\n    whose names are in the sequence or set EXC are not present.  Its check\n    method visits nodes in a given function of a source file checking that the\n    indicated node types are not used.\"\"\"\n    def __init__(self, disallow=()):\n        \"\"\"DISALLOW is the initial default list of disallowed\n        node-type names.\"\"\"\n        self._disallow = set(disallow)",
        "detail": "projects.cats.tests.construct_check",
        "documentation": {}
    },
    {
        "label": "check",
        "kind": 2,
        "importPath": "projects.cats.tests.construct_check",
        "description": "projects.cats.tests.construct_check",
        "peekOfCode": "def check(source_file, checked_funcs, disallow, source=None):\n    \"\"\"Checks that AST nodes whose type names are present in DISALLOW\n    (an object supporting 'in') are not present in the function(s) named\n    CHECKED_FUNCS in SOURCE.  By default, SOURCE is the contents of the\n    file SOURCE_FILE.  CHECKED_FUNCS is either a string (indicating a single\n    name) or an object of some other type that supports 'in'. CHECKED_FUNCS\n    may contain __main__ to indicate an entire  module. Prints reports of\n    each prohibited node and returns True iff none are found.\n    See ast.__dir__() for AST type names.  The special node name 'Recursion'\n    checks for overtly recursive calls (i.e., calls of the form NAME(...) where",
        "detail": "projects.cats.tests.construct_check",
        "documentation": {}
    },
    {
        "label": "_NAMES",
        "kind": 5,
        "importPath": "projects.cats.tests.construct_check",
        "description": "projects.cats.tests.construct_check",
        "peekOfCode": "_NAMES = {\n    'Add': '+',\n    'And': 'and',\n    'Assert': 'assert',\n    'Assign': '=',\n    'AnnAssign': '=',\n    'AugAssign': 'op=',\n    'BitAnd': '&',\n    'BitOr': '|',\n    'BitXor': '^',",
        "detail": "projects.cats.tests.construct_check",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "projects.cats.tests.EC",
        "description": "projects.cats.tests.EC",
        "peekOfCode": "test = {\n  'name': 'Extra Credit',\n  'points': 1,\n  'suites': [\n      {\n      'cases': [\n        {\n          'answer': 'A function that takes another function as an input and returns a new function that extends or modifies the behavior of the original function',\n          'choices': [\n            'A type of design pattern',",
        "detail": "projects.cats.tests.EC",
        "documentation": {}
    },
    {
        "label": "pick",
        "kind": 2,
        "importPath": "projects.cats.cats",
        "description": "projects.cats.cats",
        "peekOfCode": "def pick(paragraphs, select, k):\n    \"\"\"Return the Kth paragraph from PARAGRAPHS for which SELECT called on the\n    paragraph returns True. If there are fewer than K such paragraphs, return\n    the empty string.\n    Arguments:\n        paragraphs: a list of strings\n        select: a function that returns True for paragraphs that can be selected\n        k: an integer\n    >>> ps = ['hi', 'how are you', 'fine']\n    >>> s = lambda p: len(p) <= 4",
        "detail": "projects.cats.cats",
        "documentation": {}
    },
    {
        "label": "about",
        "kind": 2,
        "importPath": "projects.cats.cats",
        "description": "projects.cats.cats",
        "peekOfCode": "def about(subject):\n    \"\"\"Return a select function that returns whether\n    a paragraph contains one of the words in SUBJECT.\n    Arguments:\n        subject: a list of words related to a subject\n    >>> about_dogs = about(['dog', 'dogs', 'pup', 'puppy'])\n    >>> pick(['Cute Dog!', 'That is a cat.', 'Nice pup!'], about_dogs, 0)\n    'Cute Dog!'\n    >>> pick(['Cute Dog!', 'That is a cat.', 'Nice pup.'], about_dogs, 1)\n    'Nice pup.'",
        "detail": "projects.cats.cats",
        "documentation": {}
    },
    {
        "label": "accuracy",
        "kind": 2,
        "importPath": "projects.cats.cats",
        "description": "projects.cats.cats",
        "peekOfCode": "def accuracy(typed, source):\n    \"\"\"Return the accuracy (percentage of words typed correctly) of TYPED\n    when compared to the prefix of SOURCE that was typed.\n    Arguments:\n        typed: a string that may contain typos\n        source: a string without errors\n    >>> accuracy('Cute Dog!', 'Cute Dog.')\n    50.0\n    >>> accuracy('A Cute Dog!', 'Cute Dog.')\n    0.0",
        "detail": "projects.cats.cats",
        "documentation": {}
    },
    {
        "label": "wpm",
        "kind": 2,
        "importPath": "projects.cats.cats",
        "description": "projects.cats.cats",
        "peekOfCode": "def wpm(typed, elapsed):\n    \"\"\"Return the words-per-minute (WPM) of the TYPED string.\n    Arguments:\n        typed: an entered string\n        elapsed: an amount of time in seconds\n    >>> wpm('hello friend hello buddy hello', 15)\n    24.0\n    >>> wpm('0123456789',60)\n    2.0\n    \"\"\"",
        "detail": "projects.cats.cats",
        "documentation": {}
    },
    {
        "label": "autocorrect",
        "kind": 2,
        "importPath": "projects.cats.cats",
        "description": "projects.cats.cats",
        "peekOfCode": "def autocorrect(typed_word, word_list, diff_function, limit):\n    \"\"\"Returns the element of WORD_LIST that has the smallest difference\n    from TYPED_WORD. If multiple words are tied for the smallest difference,\n    return the one that appears closest to the front of WORD_LIST. If the\n    difference is greater than LIMIT, instead return TYPED_WORD.\n    Arguments:\n        typed_word: a string representing a word that may contain typos\n        word_list: a list of strings representing source words\n        diff_function: a function quantifying the difference between two words\n        limit: a number",
        "detail": "projects.cats.cats",
        "documentation": {}
    },
    {
        "label": "feline_fixes",
        "kind": 2,
        "importPath": "projects.cats.cats",
        "description": "projects.cats.cats",
        "peekOfCode": "def feline_fixes(typed, source, limit):\n    \"\"\"A diff function for autocorrect that determines how many letters\n    in TYPED need to be substituted to create SOURCE, then adds the difference in\n    their lengths and returns the result.\n    Arguments:\n        typed: a starting word\n        source: a string representing a desired goal word\n        limit: a number representing an upper bound on the number of chars that must change\n    >>> big_limit = 10\n    >>> feline_fixes(\"nice\", \"rice\", big_limit)    # Substitute: n -> r",
        "detail": "projects.cats.cats",
        "documentation": {}
    },
    {
        "label": "minimum_mewtations",
        "kind": 2,
        "importPath": "projects.cats.cats",
        "description": "projects.cats.cats",
        "peekOfCode": "def minimum_mewtations(typed, source, limit):\n    \"\"\"A diff function that computes the edit distance from TYPED to SOURCE.\n    This function takes in a string TYPED, a string SOURCE, and a number LIMIT.\n    Arguments:\n        typed: a starting word\n        source: a string representing a desired goal word\n        limit: a number representing an upper bound on the number of edits\n    >>> big_limit = 10\n    >>> minimum_mewtations(\"cats\", \"scat\", big_limit)       # cats -> scats -> scat\n    2",
        "detail": "projects.cats.cats",
        "documentation": {}
    },
    {
        "label": "final_diff",
        "kind": 2,
        "importPath": "projects.cats.cats",
        "description": "projects.cats.cats",
        "peekOfCode": "def final_diff(typed, source, limit):\n    \"\"\"A diff function that takes in a string TYPED, a string SOURCE, and a number LIMIT.\n    Returns 1 if the last characters of TYPED and SOURCE are different, otherwise returns 0.\n    Arguments:\n        typed: a string representing the input word\n        source: a string representing the target word\n        limit: a number representing an upper bound on the number of edits\n    Returns:\n        int: 1 if last characters of typed and source differ, 0 otherwise.\n    \"\"\"",
        "detail": "projects.cats.cats",
        "documentation": {}
    },
    {
        "label": "report_progress",
        "kind": 2,
        "importPath": "projects.cats.cats",
        "description": "projects.cats.cats",
        "peekOfCode": "def report_progress(typed, source, user_id, upload):\n    \"\"\"Upload a report of your id and progress so far to the multiplayer server.\n    Returns the progress so far.\n    Arguments:\n        typed: a list of the words typed so far\n        source: a list of the words in the typing source\n        user_id: a number representing the id of the current user\n        upload: a function used to upload progress to the multiplayer server\n    >>> print_progress = lambda d: print('ID:', d['id'], 'Progress:', d['progress'])\n    >>> # The above function displays progress in the format ID: __, Progress: __",
        "detail": "projects.cats.cats",
        "documentation": {}
    },
    {
        "label": "time_per_word",
        "kind": 2,
        "importPath": "projects.cats.cats",
        "description": "projects.cats.cats",
        "peekOfCode": "def time_per_word(words, timestamps_per_player):\n    \"\"\"Given timing data, return a match data abstraction, which contains a\n    list of words and the amount of time each player took to type each word.\n    Arguments:\n        words: a list of words, in the order they are typed.\n        timestamps_per_player: A list of lists of timestamps including the time\n                          the player started typing, followed by the time\n                          the player finished typing each word.\n    >>> p = [[75, 81, 84, 90, 92], [19, 29, 35, 36, 38]]\n    >>> match = time_per_word(['collar', 'plush', 'blush', 'repute'], p)",
        "detail": "projects.cats.cats",
        "documentation": {}
    },
    {
        "label": "fastest_words",
        "kind": 2,
        "importPath": "projects.cats.cats",
        "description": "projects.cats.cats",
        "peekOfCode": "def fastest_words(match):\n    \"\"\"Return a list of lists of which words each player typed fastest.\n    Arguments:\n        match: a match data abstraction as returned by time_per_word.\n    >>> p0 = [5, 1, 3]\n    >>> p1 = [4, 1, 6]\n    >>> fastest_words(match(['Just', 'have', 'fun'], [p0, p1]))\n    [['have', 'fun'], ['Just']]\n    >>> p0  # input lists should not be mutated\n    [5, 1, 3]",
        "detail": "projects.cats.cats",
        "documentation": {}
    },
    {
        "label": "match",
        "kind": 2,
        "importPath": "projects.cats.cats",
        "description": "projects.cats.cats",
        "peekOfCode": "def match(words, times):\n    \"\"\"A data abstraction containing all words typed and their times.\n    Arguments:\n        words: A list of strings, each string representing a word typed.\n        times: A list of lists for how long it took for each player to type\n            each word.\n            times[i][j] = time it took for player i to type words[j].\n    Example input:\n        words: ['Hello', 'world']\n        times: [[5, 1], [4, 2]]",
        "detail": "projects.cats.cats",
        "documentation": {}
    },
    {
        "label": "get_word",
        "kind": 2,
        "importPath": "projects.cats.cats",
        "description": "projects.cats.cats",
        "peekOfCode": "def get_word(match, word_index):\n    \"\"\"A utility function that gets the word with index word_index\"\"\"\n    assert 0 <= word_index < len(get_all_words(match)), \"word_index out of range of words\"\n    return get_all_words(match)[word_index]\ndef time(match, player_num, word_index):\n    \"\"\"A utility function for the time it took player_num to type the word at word_index\"\"\"\n    assert word_index < len(get_all_words(match)), \"word_index out of range of words\"\n    assert player_num < len(get_all_times(match)), \"player_num out of range of players\"\n    return get_all_times(match)[player_num][word_index]\ndef get_all_words(match):",
        "detail": "projects.cats.cats",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 2,
        "importPath": "projects.cats.cats",
        "description": "projects.cats.cats",
        "peekOfCode": "def time(match, player_num, word_index):\n    \"\"\"A utility function for the time it took player_num to type the word at word_index\"\"\"\n    assert word_index < len(get_all_words(match)), \"word_index out of range of words\"\n    assert player_num < len(get_all_times(match)), \"player_num out of range of players\"\n    return get_all_times(match)[player_num][word_index]\ndef get_all_words(match):\n    \"\"\"A selector function for all the words in the match\"\"\"\n    return match[\"words\"]\ndef get_all_times(match):\n    \"\"\"A selector function for all typing times for all players\"\"\"",
        "detail": "projects.cats.cats",
        "documentation": {}
    },
    {
        "label": "get_all_words",
        "kind": 2,
        "importPath": "projects.cats.cats",
        "description": "projects.cats.cats",
        "peekOfCode": "def get_all_words(match):\n    \"\"\"A selector function for all the words in the match\"\"\"\n    return match[\"words\"]\ndef get_all_times(match):\n    \"\"\"A selector function for all typing times for all players\"\"\"\n    return match[\"times\"]\ndef match_string(match):\n    \"\"\"A helper function that takes in a match data abstraction and returns a string representation of it\"\"\"\n    return f\"match({get_all_words(match)}, {get_all_times(match)})\"\nenable_multiplayer = False  # Change to True when you're ready to race.",
        "detail": "projects.cats.cats",
        "documentation": {}
    },
    {
        "label": "get_all_times",
        "kind": 2,
        "importPath": "projects.cats.cats",
        "description": "projects.cats.cats",
        "peekOfCode": "def get_all_times(match):\n    \"\"\"A selector function for all typing times for all players\"\"\"\n    return match[\"times\"]\ndef match_string(match):\n    \"\"\"A helper function that takes in a match data abstraction and returns a string representation of it\"\"\"\n    return f\"match({get_all_words(match)}, {get_all_times(match)})\"\nenable_multiplayer = False  # Change to True when you're ready to race.\n##########################\n# Command Line Interface #\n##########################",
        "detail": "projects.cats.cats",
        "documentation": {}
    },
    {
        "label": "match_string",
        "kind": 2,
        "importPath": "projects.cats.cats",
        "description": "projects.cats.cats",
        "peekOfCode": "def match_string(match):\n    \"\"\"A helper function that takes in a match data abstraction and returns a string representation of it\"\"\"\n    return f\"match({get_all_words(match)}, {get_all_times(match)})\"\nenable_multiplayer = False  # Change to True when you're ready to race.\n##########################\n# Command Line Interface #\n##########################\ndef run_typing_test(topics):\n    \"\"\"Measure typing speed and accuracy on the command line.\"\"\"\n    paragraphs = lines_from_file('data/sample_paragraphs.txt')",
        "detail": "projects.cats.cats",
        "documentation": {}
    },
    {
        "label": "run_typing_test",
        "kind": 2,
        "importPath": "projects.cats.cats",
        "description": "projects.cats.cats",
        "peekOfCode": "def run_typing_test(topics):\n    \"\"\"Measure typing speed and accuracy on the command line.\"\"\"\n    paragraphs = lines_from_file('data/sample_paragraphs.txt')\n    select = lambda p: True\n    if topics:\n        select = about(topics)\n    i = 0\n    while True:\n        source = pick(paragraphs, select, i)\n        if not source:",
        "detail": "projects.cats.cats",
        "documentation": {}
    },
    {
        "label": "run",
        "kind": 2,
        "importPath": "projects.cats.cats",
        "description": "projects.cats.cats",
        "peekOfCode": "def run(*args):\n    \"\"\"Read in the command-line argument and calls corresponding functions.\"\"\"\n    import argparse\n    parser = argparse.ArgumentParser(description=\"Typing Test\")\n    parser.add_argument('topic', help=\"Topic word\", nargs='*')\n    parser.add_argument('-t', help=\"Run typing test\", action='store_true')\n    args = parser.parse_args()\n    if args.t:\n        run_typing_test(args.topic)",
        "detail": "projects.cats.cats",
        "documentation": {}
    },
    {
        "label": "FINAL_DIFF_LIMIT",
        "kind": 5,
        "importPath": "projects.cats.cats",
        "description": "projects.cats.cats",
        "peekOfCode": "FINAL_DIFF_LIMIT = 6 # REPLACE THIS WITH YOUR LIMIT\n###########\n# Phase 3 #\n###########\ndef report_progress(typed, source, user_id, upload):\n    \"\"\"Upload a report of your id and progress so far to the multiplayer server.\n    Returns the progress so far.\n    Arguments:\n        typed: a list of the words typed so far\n        source: a list of the words in the typing source",
        "detail": "projects.cats.cats",
        "documentation": {}
    },
    {
        "label": "enable_multiplayer",
        "kind": 5,
        "importPath": "projects.cats.cats",
        "description": "projects.cats.cats",
        "peekOfCode": "enable_multiplayer = False  # Change to True when you're ready to race.\n##########################\n# Command Line Interface #\n##########################\ndef run_typing_test(topics):\n    \"\"\"Measure typing speed and accuracy on the command line.\"\"\"\n    paragraphs = lines_from_file('data/sample_paragraphs.txt')\n    select = lambda p: True\n    if topics:\n        select = about(topics)",
        "detail": "projects.cats.cats",
        "documentation": {}
    },
    {
        "label": "request_paragraph",
        "kind": 2,
        "importPath": "projects.cats.cats_gui",
        "description": "projects.cats.cats_gui",
        "peekOfCode": "def request_paragraph(topics=None):\n    \"\"\"Return a random paragraph.\"\"\"\n    paragraphs = cats.lines_from_file(PARAGRAPH_PATH)\n    random.shuffle(paragraphs)\n    select = cats.about(topics) if topics else lambda x: True\n    return cats.pick(paragraphs, select, 0)\n@route\ndef analyze(prompted_text, typed_text, start_time, end_time):\n    \"\"\"Return [wpm, accuracy].\"\"\"\n    return {",
        "detail": "projects.cats.cats_gui",
        "documentation": {}
    },
    {
        "label": "analyze",
        "kind": 2,
        "importPath": "projects.cats.cats_gui",
        "description": "projects.cats.cats_gui",
        "peekOfCode": "def analyze(prompted_text, typed_text, start_time, end_time):\n    \"\"\"Return [wpm, accuracy].\"\"\"\n    return {\n        \"wpm\": cats.wpm(typed_text, end_time - start_time),\n        \"accuracy\": cats.accuracy(typed_text, prompted_text),\n    }\ndef similar(w, v, n):\n    \"\"\"Whether W intersect V contains at least |W|-N and |V|-N elements.\"\"\"\n    intersect = len(w.intersection(v))\n    return intersect >= len(w) - n and intersect >= len(v) - n",
        "detail": "projects.cats.cats_gui",
        "documentation": {}
    },
    {
        "label": "similar",
        "kind": 2,
        "importPath": "projects.cats.cats_gui",
        "description": "projects.cats.cats_gui",
        "peekOfCode": "def similar(w, v, n):\n    \"\"\"Whether W intersect V contains at least |W|-N and |V|-N elements.\"\"\"\n    intersect = len(w.intersection(v))\n    return intersect >= len(w) - n and intersect >= len(v) - n\n@route\ndef autocorrect(word=\"\"):\n    \"\"\"Call autocorrect using the best score function available.\"\"\"\n    raw_word = word\n    word = cats.lower(cats.remove_punctuation(raw_word))\n    if word in WORDS_SET or word == \"\":",
        "detail": "projects.cats.cats_gui",
        "documentation": {}
    },
    {
        "label": "autocorrect",
        "kind": 2,
        "importPath": "projects.cats.cats_gui",
        "description": "projects.cats.cats_gui",
        "peekOfCode": "def autocorrect(word=\"\"):\n    \"\"\"Call autocorrect using the best score function available.\"\"\"\n    raw_word = word\n    word = cats.lower(cats.remove_punctuation(raw_word))\n    if word in WORDS_SET or word == \"\":\n        return raw_word\n    # Heuristically choose candidate words to score.\n    letters = set(word)\n    candidates = [w for w, s in LETTER_SETS if similar(s, letters, SIMILARITY_LIMIT)]\n    # Try various diff functions until one doesn't raise an exception.",
        "detail": "projects.cats.cats_gui",
        "documentation": {}
    },
    {
        "label": "reformat",
        "kind": 2,
        "importPath": "projects.cats.cats_gui",
        "description": "projects.cats.cats_gui",
        "peekOfCode": "def reformat(word, raw_word):\n    \"\"\"Reformat WORD to match the capitalization and punctuation of RAW_WORD.\"\"\"\n    # handle capitalization\n    if raw_word != \"\" and raw_word[0].isupper():\n        word = word.capitalize()\n    # find the boundaries of the raw word\n    first = 0\n    while first < len(raw_word) and raw_word[first] in string.punctuation:\n        first += 1\n    last = len(raw_word) - 1",
        "detail": "projects.cats.cats_gui",
        "documentation": {}
    },
    {
        "label": "request_id",
        "kind": 2,
        "importPath": "projects.cats.cats_gui",
        "description": "projects.cats.cats_gui",
        "peekOfCode": "def request_id():\n    if not cats.enable_multiplayer:\n        return\n    return Server.provide_id()\n@route\ndef report_progress(id, typed, prompt):\n    \"\"\"Report progress to the multiplayer server and also return it.\"\"\"\n    typed = typed.split()  # A list of word strings\n    prompt = prompt.split()  # A list of word strings\n    return cats.report_progress(typed, prompt, id, sendto(Server.set_progress))",
        "detail": "projects.cats.cats_gui",
        "documentation": {}
    },
    {
        "label": "report_progress",
        "kind": 2,
        "importPath": "projects.cats.cats_gui",
        "description": "projects.cats.cats_gui",
        "peekOfCode": "def report_progress(id, typed, prompt):\n    \"\"\"Report progress to the multiplayer server and also return it.\"\"\"\n    typed = typed.split()  # A list of word strings\n    prompt = prompt.split()  # A list of word strings\n    return cats.report_progress(typed, prompt, id, sendto(Server.set_progress))\n@route\ndef fastest_words(prompt, targets):\n    \"\"\"Return a list of word_speed values describing the match.\"\"\"\n    words = prompt.split()\n    progress = Server.request_all_progress(targets=targets)",
        "detail": "projects.cats.cats_gui",
        "documentation": {}
    },
    {
        "label": "fastest_words",
        "kind": 2,
        "importPath": "projects.cats.cats_gui",
        "description": "projects.cats.cats_gui",
        "peekOfCode": "def fastest_words(prompt, targets):\n    \"\"\"Return a list of word_speed values describing the match.\"\"\"\n    words = prompt.split()\n    progress = Server.request_all_progress(targets=targets)\n    start_times = [p[0][1] for p in progress]\n    times_per_player = [[p[1] - s for p in ps] for s, ps in zip(start_times, progress)]\n    match = cats.time_per_word(words, times_per_player)\n    return cats.fastest_words(match)\nmultiplayer.create_multiplayer_server()\n###############",
        "detail": "projects.cats.cats_gui",
        "documentation": {}
    },
    {
        "label": "favicon",
        "kind": 2,
        "importPath": "projects.cats.cats_gui",
        "description": "projects.cats.cats_gui",
        "peekOfCode": "def favicon():\n    favicon_folder = \"favicons\"\n    favicons = os.listdir(favicon_folder)\n    path = os.path.join(favicon_folder, random.choice(favicons))\n    with open(path, \"rb\") as f:\n        data = f.read()\n    image_b64 = base64.b64encode(data).decode(\"utf-8\")\n    return \"data:image/png;base64,\" + image_b64\nif __name__ == \"__main__\" or os.environ.get(\"ENV\") == \"prod\":\n    app = start(PORT, DEFAULT_SERVER, GUI_FOLDER, multiplayer.db_init)",
        "detail": "projects.cats.cats_gui",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": "projects.cats.cats_gui",
        "description": "projects.cats.cats_gui",
        "peekOfCode": "PORT = 31415\nDEFAULT_SERVER = \"https://cats.cs61a.org\"\nGUI_FOLDER = \"gui_files/\"\nPARAGRAPH_PATH = \"./data/sample_paragraphs.txt\"\nWORDS_LIST = cats.lines_from_file(\"data/words.txt\")\nWORDS_SET = set(WORDS_LIST)\nLETTER_SETS = [(w, set(w)) for w in WORDS_LIST]\nSIMILARITY_LIMIT = 2\n@route\ndef request_paragraph(topics=None):",
        "detail": "projects.cats.cats_gui",
        "documentation": {}
    },
    {
        "label": "DEFAULT_SERVER",
        "kind": 5,
        "importPath": "projects.cats.cats_gui",
        "description": "projects.cats.cats_gui",
        "peekOfCode": "DEFAULT_SERVER = \"https://cats.cs61a.org\"\nGUI_FOLDER = \"gui_files/\"\nPARAGRAPH_PATH = \"./data/sample_paragraphs.txt\"\nWORDS_LIST = cats.lines_from_file(\"data/words.txt\")\nWORDS_SET = set(WORDS_LIST)\nLETTER_SETS = [(w, set(w)) for w in WORDS_LIST]\nSIMILARITY_LIMIT = 2\n@route\ndef request_paragraph(topics=None):\n    \"\"\"Return a random paragraph.\"\"\"",
        "detail": "projects.cats.cats_gui",
        "documentation": {}
    },
    {
        "label": "GUI_FOLDER",
        "kind": 5,
        "importPath": "projects.cats.cats_gui",
        "description": "projects.cats.cats_gui",
        "peekOfCode": "GUI_FOLDER = \"gui_files/\"\nPARAGRAPH_PATH = \"./data/sample_paragraphs.txt\"\nWORDS_LIST = cats.lines_from_file(\"data/words.txt\")\nWORDS_SET = set(WORDS_LIST)\nLETTER_SETS = [(w, set(w)) for w in WORDS_LIST]\nSIMILARITY_LIMIT = 2\n@route\ndef request_paragraph(topics=None):\n    \"\"\"Return a random paragraph.\"\"\"\n    paragraphs = cats.lines_from_file(PARAGRAPH_PATH)",
        "detail": "projects.cats.cats_gui",
        "documentation": {}
    },
    {
        "label": "PARAGRAPH_PATH",
        "kind": 5,
        "importPath": "projects.cats.cats_gui",
        "description": "projects.cats.cats_gui",
        "peekOfCode": "PARAGRAPH_PATH = \"./data/sample_paragraphs.txt\"\nWORDS_LIST = cats.lines_from_file(\"data/words.txt\")\nWORDS_SET = set(WORDS_LIST)\nLETTER_SETS = [(w, set(w)) for w in WORDS_LIST]\nSIMILARITY_LIMIT = 2\n@route\ndef request_paragraph(topics=None):\n    \"\"\"Return a random paragraph.\"\"\"\n    paragraphs = cats.lines_from_file(PARAGRAPH_PATH)\n    random.shuffle(paragraphs)",
        "detail": "projects.cats.cats_gui",
        "documentation": {}
    },
    {
        "label": "WORDS_LIST",
        "kind": 5,
        "importPath": "projects.cats.cats_gui",
        "description": "projects.cats.cats_gui",
        "peekOfCode": "WORDS_LIST = cats.lines_from_file(\"data/words.txt\")\nWORDS_SET = set(WORDS_LIST)\nLETTER_SETS = [(w, set(w)) for w in WORDS_LIST]\nSIMILARITY_LIMIT = 2\n@route\ndef request_paragraph(topics=None):\n    \"\"\"Return a random paragraph.\"\"\"\n    paragraphs = cats.lines_from_file(PARAGRAPH_PATH)\n    random.shuffle(paragraphs)\n    select = cats.about(topics) if topics else lambda x: True",
        "detail": "projects.cats.cats_gui",
        "documentation": {}
    },
    {
        "label": "WORDS_SET",
        "kind": 5,
        "importPath": "projects.cats.cats_gui",
        "description": "projects.cats.cats_gui",
        "peekOfCode": "WORDS_SET = set(WORDS_LIST)\nLETTER_SETS = [(w, set(w)) for w in WORDS_LIST]\nSIMILARITY_LIMIT = 2\n@route\ndef request_paragraph(topics=None):\n    \"\"\"Return a random paragraph.\"\"\"\n    paragraphs = cats.lines_from_file(PARAGRAPH_PATH)\n    random.shuffle(paragraphs)\n    select = cats.about(topics) if topics else lambda x: True\n    return cats.pick(paragraphs, select, 0)",
        "detail": "projects.cats.cats_gui",
        "documentation": {}
    },
    {
        "label": "LETTER_SETS",
        "kind": 5,
        "importPath": "projects.cats.cats_gui",
        "description": "projects.cats.cats_gui",
        "peekOfCode": "LETTER_SETS = [(w, set(w)) for w in WORDS_LIST]\nSIMILARITY_LIMIT = 2\n@route\ndef request_paragraph(topics=None):\n    \"\"\"Return a random paragraph.\"\"\"\n    paragraphs = cats.lines_from_file(PARAGRAPH_PATH)\n    random.shuffle(paragraphs)\n    select = cats.about(topics) if topics else lambda x: True\n    return cats.pick(paragraphs, select, 0)\n@route",
        "detail": "projects.cats.cats_gui",
        "documentation": {}
    },
    {
        "label": "SIMILARITY_LIMIT",
        "kind": 5,
        "importPath": "projects.cats.cats_gui",
        "description": "projects.cats.cats_gui",
        "peekOfCode": "SIMILARITY_LIMIT = 2\n@route\ndef request_paragraph(topics=None):\n    \"\"\"Return a random paragraph.\"\"\"\n    paragraphs = cats.lines_from_file(PARAGRAPH_PATH)\n    random.shuffle(paragraphs)\n    select = cats.about(topics) if topics else lambda x: True\n    return cats.pick(paragraphs, select, 0)\n@route\ndef analyze(prompted_text, typed_text, start_time, end_time):",
        "detail": "projects.cats.cats_gui",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "projects.cats.ucb",
        "description": "projects.cats.ucb",
        "peekOfCode": "def main(fn):\n    \"\"\"Call fn with command line arguments.  Used as a decorator.\n    The main decorator marks the function that starts a program. For example,\n    @main\n    def my_run_function():\n        # function body\n    Use this instead of the typical __name__ == \"__main__\" predicate.\n    \"\"\"\n    if inspect.stack()[1][0].f_locals['__name__'] == '__main__':\n        args = sys.argv[1:] # Discard the script name from command line",
        "detail": "projects.cats.ucb",
        "documentation": {}
    },
    {
        "label": "trace",
        "kind": 2,
        "importPath": "projects.cats.ucb",
        "description": "projects.cats.ucb",
        "peekOfCode": "def trace(fn):\n    \"\"\"A decorator that prints a function's name, its arguments, and its return\n    values each time the function is called. For example,\n    @trace\n    def compute_something(x, y):\n        # function body\n    \"\"\"\n    @functools.wraps(fn)\n    def wrapped(*args, **kwds):\n        global _PREFIX",
        "detail": "projects.cats.ucb",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 2,
        "importPath": "projects.cats.ucb",
        "description": "projects.cats.ucb",
        "peekOfCode": "def log(message):\n    \"\"\"Print an indented message (used with trace).\"\"\"\n    print(_PREFIX + re.sub('\\n', '\\n' + _PREFIX, str(message)))\ndef log_current_line():\n    \"\"\"Print information about the current line of code.\"\"\"\n    frame = inspect.stack()[1]\n    log('Current line: File \"{f[1]}\", line {f[2]}, in {f[3]}'.format(f=frame))\ndef interact(msg=None):\n    \"\"\"Start an interactive interpreter session in the current environment.\n    On Unix:",
        "detail": "projects.cats.ucb",
        "documentation": {}
    },
    {
        "label": "log_current_line",
        "kind": 2,
        "importPath": "projects.cats.ucb",
        "description": "projects.cats.ucb",
        "peekOfCode": "def log_current_line():\n    \"\"\"Print information about the current line of code.\"\"\"\n    frame = inspect.stack()[1]\n    log('Current line: File \"{f[1]}\", line {f[2]}, in {f[3]}'.format(f=frame))\ndef interact(msg=None):\n    \"\"\"Start an interactive interpreter session in the current environment.\n    On Unix:\n      <Control>-D exits the interactive session and returns to normal execution.\n    In Windows:\n      <Control>-Z <Enter> exits the interactive session and returns to normal",
        "detail": "projects.cats.ucb",
        "documentation": {}
    },
    {
        "label": "interact",
        "kind": 2,
        "importPath": "projects.cats.ucb",
        "description": "projects.cats.ucb",
        "peekOfCode": "def interact(msg=None):\n    \"\"\"Start an interactive interpreter session in the current environment.\n    On Unix:\n      <Control>-D exits the interactive session and returns to normal execution.\n    In Windows:\n      <Control>-Z <Enter> exits the interactive session and returns to normal\n      execution.\n    \"\"\"\n    # evaluate commands in current namespace\n    frame = inspect.currentframe().f_back",
        "detail": "projects.cats.ucb",
        "documentation": {}
    },
    {
        "label": "_PREFIX",
        "kind": 5,
        "importPath": "projects.cats.ucb",
        "description": "projects.cats.ucb",
        "peekOfCode": "_PREFIX = ''\ndef trace(fn):\n    \"\"\"A decorator that prints a function's name, its arguments, and its return\n    values each time the function is called. For example,\n    @trace\n    def compute_something(x, y):\n        # function body\n    \"\"\"\n    @functools.wraps(fn)\n    def wrapped(*args, **kwds):",
        "detail": "projects.cats.ucb",
        "documentation": {}
    },
    {
        "label": "lines_from_file",
        "kind": 2,
        "importPath": "projects.cats.utils",
        "description": "projects.cats.utils",
        "peekOfCode": "def lines_from_file(path):\n    \"\"\"Return a list of strings, one for each line in a file.\"\"\"\n    with open(path, 'r') as f:\n        return [line.strip() for line in f.readlines()]\ndef remove_punctuation(s):\n    \"\"\"Return a string with the same contents as s, but with punctuation removed.\n    >>> remove_punctuation(\"It's a lovely day, don't you think?\")\n    'Its a lovely day dont you think'\n    >>> remove_punctuation(\"Its a lovely day dont you think\")\n    'Its a lovely day dont you think'",
        "detail": "projects.cats.utils",
        "documentation": {}
    },
    {
        "label": "remove_punctuation",
        "kind": 2,
        "importPath": "projects.cats.utils",
        "description": "projects.cats.utils",
        "peekOfCode": "def remove_punctuation(s):\n    \"\"\"Return a string with the same contents as s, but with punctuation removed.\n    >>> remove_punctuation(\"It's a lovely day, don't you think?\")\n    'Its a lovely day dont you think'\n    >>> remove_punctuation(\"Its a lovely day dont you think\")\n    'Its a lovely day dont you think'\n    \"\"\"\n    punctuation_remover = str.maketrans('', '', string.punctuation)\n    return s.strip().translate(punctuation_remover)\ndef lower(s):",
        "detail": "projects.cats.utils",
        "documentation": {}
    },
    {
        "label": "lower",
        "kind": 2,
        "importPath": "projects.cats.utils",
        "description": "projects.cats.utils",
        "peekOfCode": "def lower(s):\n    \"\"\"Return a lowercased version of s.\n    >>> lower(\"HELLO\")\n    'hello'\n    >>> lower(\"World\")\n    'world'\n    >>> lower(\"hello WORLD\")\n    'hello world'\n    \"\"\"\n    return s.lower()",
        "detail": "projects.cats.utils",
        "documentation": {}
    },
    {
        "label": "split",
        "kind": 2,
        "importPath": "projects.cats.utils",
        "description": "projects.cats.utils",
        "peekOfCode": "def split(s):\n    \"\"\"Return a list of words contained in s, which are sequences of characters\n    separated by whitespace (spaces, tabs, etc.).\n    >>> split(\"It's a lovely day, don't you think?\")\n    [\"It's\", 'a', 'lovely', 'day,', \"don't\", 'you', 'think?']\n    \"\"\"\n    return s.split()\n#############################\n# Keyboard layout functions #\n#############################",
        "detail": "projects.cats.utils",
        "documentation": {}
    },
    {
        "label": "distance",
        "kind": 2,
        "importPath": "projects.cats.utils",
        "description": "projects.cats.utils",
        "peekOfCode": "def distance(p1, p2):\n    \"\"\"Return the Euclidean distance between two points\n    The Euclidean distance between two points, (x1, y1) and (x2, y2)\n    is the square root of (x1 - x2) ** 2 + (y1 - y2) ** 2\n    >>> distance((0, 1), (1, 1))\n    1.0\n    >>> distance((1, 1), (1, 1))\n    0.0\n    >>> round(distance((4, 0), (0, 4)), 3)\n    5.657",
        "detail": "projects.cats.utils",
        "documentation": {}
    },
    {
        "label": "get_key_distances",
        "kind": 2,
        "importPath": "projects.cats.utils",
        "description": "projects.cats.utils",
        "peekOfCode": "def get_key_distances():\n    \"\"\"Return a new dictionary mapping key pairs to distances.\n    Each key of the dictionary is a tuple of two\n    letters as strings, and each value is the euclidean distance\n    between the two letters on a standard QWERTY keyboard, normalized\n    The scaling is constant, so a pair of keys that are twice\n    as far have a distance value that is twice as great\n    >>> distances = get_key_distances()\n    >>> distances[\"a\", \"a\"]\n    0.0",
        "detail": "projects.cats.utils",
        "documentation": {}
    },
    {
        "label": "count",
        "kind": 2,
        "importPath": "projects.cats.utils",
        "description": "projects.cats.utils",
        "peekOfCode": "def count(f):\n    \"\"\"Keeps track of the number of times a function f is called using the\n    variable call_count\n    >>> def factorial(n):\n    ...     if n <= 1:\n    ...         return 1\n    ...     return n * factorial(n - 1)\n    >>> factorial = count(factorial)\n    >>> factorial(5)\n    120",
        "detail": "projects.cats.utils",
        "documentation": {}
    },
    {
        "label": "deep_convert_to_tuple",
        "kind": 2,
        "importPath": "projects.cats.utils",
        "description": "projects.cats.utils",
        "peekOfCode": "def deep_convert_to_tuple(sequence):\n    \"\"\"Deeply converts tuples to lists.\n    >>> deep_convert_to_tuple(5)\n    5\n    >>> deep_convert_to_tuple([2, 'hi'])\n    (2, 'hi')\n    >>> deep_convert_to_tuple([['These', 'are', 'all'], ['tuples.']])\n    (('These', 'are', 'all'), ('tuples.',))\n    \"\"\"\n    if isinstance(sequence, list) or isinstance(sequence, tuple):",
        "detail": "projects.cats.utils",
        "documentation": {}
    },
    {
        "label": "KEY_LAYOUT",
        "kind": 5,
        "importPath": "projects.cats.utils",
        "description": "projects.cats.utils",
        "peekOfCode": "KEY_LAYOUT = [[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"0\",\"-\",\"=\"],\n              [\"q\", \"w\", \"e\", \"r\", \"t\", \"y\", \"u\", \"i\", \"o\", \"p\",\"[\",\"]\"],\n              [\"a\", \"s\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\",\";\",\"'\"],\n              [\"z\", \"x\", \"c\", \"v\", \"b\", \"n\", \"m\",\",\",\".\",\"/\"],\n              [\" \"]]\ndef distance(p1, p2):\n    \"\"\"Return the Euclidean distance between two points\n    The Euclidean distance between two points, (x1, y1) and (x2, y2)\n    is the square root of (x1 - x2) ** 2 + (y1 - y2) ** 2\n    >>> distance((0, 1), (1, 1))",
        "detail": "projects.cats.utils",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "projects.hog.tests.00",
        "description": "projects.hog.tests.00",
        "peekOfCode": "test = {\n  'name': 'Question 0',\n  'points': 0,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> test_dice = make_test_dice(4, 1, 2)\n          >>> test_dice()",
        "detail": "projects.hog.tests.00",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "projects.hog.tests.01",
        "description": "projects.hog.tests.01",
        "peekOfCode": "test = {\n  'name': 'Question 1',\n  'points': 2,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> roll_dice(2, make_test_dice(4, 6, 1))\n          10",
        "detail": "projects.hog.tests.01",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "projects.hog.tests.02",
        "description": "projects.hog.tests.02",
        "peekOfCode": "test = {\n  'name': 'Question 2',\n  'points': 2,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> boar_brawl(21, 46)\n          9",
        "detail": "projects.hog.tests.02",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "projects.hog.tests.03",
        "description": "projects.hog.tests.03",
        "peekOfCode": "test = {\n  'name': 'Question 3',\n  'points': 2,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> take_turn(2, 7, 27, make_test_dice(4, 5, 1))\n          9",
        "detail": "projects.hog.tests.03",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "projects.hog.tests.04",
        "description": "projects.hog.tests.04",
        "peekOfCode": "test = {\n  'name': 'Question 4',\n  'points': 2,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> num_factors(1)\n          1",
        "detail": "projects.hog.tests.04",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "projects.hog.tests.05",
        "description": "projects.hog.tests.05",
        "peekOfCode": "test = {\n  'name': 'Question 5',\n  'points': 4,\n  'suites': [\n    {\n      'cases': [\n        {\n          'answer': 'While score0 and score1 are both less than goal',\n          'choices': [\n            'While score0 and score1 are both less than goal',",
        "detail": "projects.hog.tests.05",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "projects.hog.tests.06",
        "description": "projects.hog.tests.06",
        "peekOfCode": "test = {\n  'name': 'Question 6',\n  'points': 2,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> always_roll(3)(10, 20)\n          3",
        "detail": "projects.hog.tests.06",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "projects.hog.tests.07",
        "description": "projects.hog.tests.07",
        "peekOfCode": "test = {\n  'name': 'Question 7',\n  'points': 2,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> is_always_roll(always_roll_5)\n          True",
        "detail": "projects.hog.tests.07",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "projects.hog.tests.08",
        "description": "projects.hog.tests.08",
        "peekOfCode": "test = {\n  'name': 'Question 8',\n  'points': 2,\n  'suites': [\n    {\n      'cases': [\n        {\n          'answer': 'It takes in a function as an argument',\n          'choices': [\n            'It contains a nested function',",
        "detail": "projects.hog.tests.08",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "projects.hog.tests.09",
        "description": "projects.hog.tests.09",
        "peekOfCode": "test = {\n  'name': 'Question 9',\n  'points': 2,\n  'suites': [\n    {\n      'cases': [\n        {\n          'answer': 'The lowest num_rolls',\n          'choices': [\n            'The lowest num_rolls',",
        "detail": "projects.hog.tests.09",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "projects.hog.tests.10",
        "description": "projects.hog.tests.10",
        "peekOfCode": "test = {\n  'name': 'Question 10',\n  'points': 2,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> boar_strategy(40, 51, threshold=7, num_rolls=2)\n          0",
        "detail": "projects.hog.tests.10",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "projects.hog.tests.11",
        "description": "projects.hog.tests.11",
        "peekOfCode": "test = {\n  'name': 'Question 11',\n  'points': 2,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> sus_strategy(31, 21, threshold=10, num_rolls=2)\n          2",
        "detail": "projects.hog.tests.11",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "projects.hog.tests.12",
        "description": "projects.hog.tests.12",
        "peekOfCode": "test = {\n  'name': 'Question 12',\n  'points': 0,\n  'suites': [\n    {\n      'cases': [\n        {\n          'code': r\"\"\"\n          >>> check_strategy(hog.final_strategy)\n          \"\"\",",
        "detail": "projects.hog.tests.12",
        "documentation": {}
    },
    {
        "label": "check_strategy_roll",
        "kind": 2,
        "importPath": "projects.hog.tests.check_strategy",
        "description": "projects.hog.tests.check_strategy",
        "peekOfCode": "def check_strategy_roll(score, opponent_score, num_rolls):\n    \"\"\"Raises an error with a helpful message if NUM_ROLLS is an invalid\n    strategy output. All strategy outputs must be integers from 0 to 10.\n    >>> check_strategy_roll(10, 20, num_rolls=100)\n    Traceback (most recent call last):\n     ...\n    AssertionError: strategy(10, 20) returned 100 (invalid number of rolls)\n    >>> check_strategy_roll(20, 10, num_rolls=0.1)\n    Traceback (most recent call last):\n     ...",
        "detail": "projects.hog.tests.check_strategy",
        "documentation": {}
    },
    {
        "label": "check_strategy",
        "kind": 2,
        "importPath": "projects.hog.tests.check_strategy",
        "description": "projects.hog.tests.check_strategy",
        "peekOfCode": "def check_strategy(strategy, goal=GOAL_SCORE):\n    \"\"\"Checks the strategy with all valid inputs and verifies that the strategy\n    returns a valid output. Use `check_strategy_roll` to raise an error with a\n    helpful message if the strategy returns an invalid output.\n    >>> def fail_15_20(score, opponent_score):\n    ...     if score != 15 or opponent_score != 20:\n    ...         return 5\n    ...\n    >>> check_strategy(fail_15_20)\n    Traceback (most recent call last):",
        "detail": "projects.hog.tests.check_strategy",
        "documentation": {}
    },
    {
        "label": "ExclusionChecker",
        "kind": 6,
        "importPath": "projects.hog.tests.construct_check",
        "description": "projects.hog.tests.construct_check",
        "peekOfCode": "class ExclusionChecker(NodeVisitor):\n    \"\"\"An AST visitor that checks that certain constructs are excluded from\n    parts of a program.  ExclusionChecker(EXC) checks that AST node types\n    whose names are in the sequence or set EXC are not present.  Its check\n    method visits nodes in a given function of a source file checking that the\n    indicated node types are not used.\"\"\"\n    def __init__(self, disallow=()):\n        \"\"\"DISALLOW is the initial default list of disallowed\n        node-type names.\"\"\"\n        self._disallow = set(disallow)",
        "detail": "projects.hog.tests.construct_check",
        "documentation": {}
    },
    {
        "label": "check",
        "kind": 2,
        "importPath": "projects.hog.tests.construct_check",
        "description": "projects.hog.tests.construct_check",
        "peekOfCode": "def check(source_file, checked_funcs, disallow, source=None):\n    \"\"\"Checks that AST nodes whose type names are present in DISALLOW\n    (an object supporting 'in') are not present in the function(s) named\n    CHECKED_FUNCS in SOURCE.  By default, SOURCE is the contents of the\n    file SOURCE_FILE.  CHECKED_FUNCS is either a string (indicating a single\n    name) or an object of some other type that supports 'in'. CHECKED_FUNCS\n    may contain __main__ to indicate an entire  module. Prints reports of\n    each prohibited node and returns True iff none are found.\n    See ast.__dir__() for AST type names.  The special node name 'Recursion'\n    checks for overtly recursive calls (i.e., calls of the form NAME(...) where",
        "detail": "projects.hog.tests.construct_check",
        "documentation": {}
    },
    {
        "label": "_NAMES",
        "kind": 5,
        "importPath": "projects.hog.tests.construct_check",
        "description": "projects.hog.tests.construct_check",
        "peekOfCode": "_NAMES = {\n    'Add': '+',\n    'And': 'and',\n    'Assert': 'assert',\n    'Assign': '=',\n    'AnnAssign': '=',\n    'AugAssign': 'op=',\n    'BitAnd': '&',\n    'BitOr': '|',\n    'BitXor': '^',",
        "detail": "projects.hog.tests.construct_check",
        "documentation": {}
    },
    {
        "label": "trace_play",
        "kind": 2,
        "importPath": "projects.hog.tests.play_utils",
        "description": "projects.hog.tests.play_utils",
        "peekOfCode": "def trace_play(play, strategy0, strategy1, update, score0, score1, dice, goal, say):\n    \"\"\"Wraps the user's play function and\n        (1) ensures that strategy0 and strategy1 are called exactly once per turn\n        (2) records the entire game, returning the result as a list of dictionaries,\n            each with keys \"s0_start\", \"s1_start\", \"who\", \"num_dice\", \"dice_values\"\n    Returns (s0, s1, trace) where s0, s1 are the return values from play and trace\n        is the trace as specified above.\n    This might seem a bit overcomplicated but it will also used to create the game\n        traces for the fuzz test (when run against the staff solution).\n    \"\"\"",
        "detail": "projects.hog.tests.play_utils",
        "documentation": {}
    },
    {
        "label": "safe",
        "kind": 2,
        "importPath": "projects.hog.tests.play_utils",
        "description": "projects.hog.tests.play_utils",
        "peekOfCode": "def safe(commentary):\n    def new_commentary(score0, score1, leader=None):\n        try:\n            leader, message = commentary(score0, score1, leader)\n        except TypeError as e:\n            print(\"Error in commentary function\")\n        return leader, message\n    return new_commentary\ndef describe_game(hog, test_number, score0, score1, goal, update):\n    strat_seed0, strat_seed1, dice_seed = run_with_seed(test_number, lambda: [random.randrange(2**32) for _ in range(3)])",
        "detail": "projects.hog.tests.play_utils",
        "documentation": {}
    },
    {
        "label": "describe_game",
        "kind": 2,
        "importPath": "projects.hog.tests.play_utils",
        "description": "projects.hog.tests.play_utils",
        "peekOfCode": "def describe_game(hog, test_number, score0, score1, goal, update):\n    strat_seed0, strat_seed1, dice_seed = run_with_seed(test_number, lambda: [random.randrange(2**32) for _ in range(3)])\n    strategy0 = random_strat(strat_seed0)\n    strategy1 = random_strat(strat_seed1)\n    dice = get_dice(dice_seed)\n    s0last, s1last, game_trace = trace_play(\n        hog.play,\n        strategy0,\n        strategy1,\n        update=update,",
        "detail": "projects.hog.tests.play_utils",
        "documentation": {}
    },
    {
        "label": "random_strat",
        "kind": 2,
        "importPath": "projects.hog.tests.play_utils",
        "description": "projects.hog.tests.play_utils",
        "peekOfCode": "def random_strat(seed):\n    \"\"\"\n    Makes a random strategy from based on the given seed\n    \"\"\"\n    def random_strat(score, opponent_score):\n        # Save the state of the random generator, so strategy calls don't\n        # impact dice rolls.\n        # using this because python's hash function is NOT CONSISTENT ACROSS OSs!!!!!!!!!!!!11!!22!!2!\n        conditional_seed = score * 314159265358979 + opponent_score * 27182818284590452353602874713527 + seed * 161803398874989484820\n        return run_with_seed(conditional_seed % (2 ** 32), lambda: random.randrange(0, 11))",
        "detail": "projects.hog.tests.play_utils",
        "documentation": {}
    },
    {
        "label": "run_with_seed",
        "kind": 2,
        "importPath": "projects.hog.tests.play_utils",
        "description": "projects.hog.tests.play_utils",
        "peekOfCode": "def run_with_seed(seed, fn):\n    state = random.getstate()\n    random.seed(seed)\n    result = fn()\n    random.setstate(state)\n    return result\ndef get_dice(seed):\n    def dice():\n        nonlocal seed\n        seed, value = run_with_seed(seed, lambda: (random.randrange(0, 2**32), random.randrange(1, 7)))",
        "detail": "projects.hog.tests.play_utils",
        "documentation": {}
    },
    {
        "label": "get_dice",
        "kind": 2,
        "importPath": "projects.hog.tests.play_utils",
        "description": "projects.hog.tests.play_utils",
        "peekOfCode": "def get_dice(seed):\n    def dice():\n        nonlocal seed\n        seed, value = run_with_seed(seed, lambda: (random.randrange(0, 2**32), random.randrange(1, 7)))\n        return value\n    return dice",
        "detail": "projects.hog.tests.play_utils",
        "documentation": {}
    },
    {
        "label": "SUMMARY",
        "kind": 5,
        "importPath": "projects.hog.tests.play_utils",
        "description": "projects.hog.tests.play_utils",
        "peekOfCode": "SUMMARY = \"Start scores = ({s0}, {s1}).\\nPlayer {w} rolls {nr} dice and gets outcomes {rv}.\\nEnd scores = ({e0}, {e1})\"\ndef trace_play(play, strategy0, strategy1, update, score0, score1, dice, goal, say):\n    \"\"\"Wraps the user's play function and\n        (1) ensures that strategy0 and strategy1 are called exactly once per turn\n        (2) records the entire game, returning the result as a list of dictionaries,\n            each with keys \"s0_start\", \"s1_start\", \"who\", \"num_dice\", \"dice_values\"\n    Returns (s0, s1, trace) where s0, s1 are the return values from play and trace\n        is the trace as specified above.\n    This might seem a bit overcomplicated but it will also used to create the game\n        traces for the fuzz test (when run against the staff solution).",
        "detail": "projects.hog.tests.play_utils",
        "documentation": {}
    },
    {
        "label": "dice",
        "kind": 5,
        "importPath": "projects.hog.default_graphics",
        "description": "projects.hog.default_graphics",
        "peekOfCode": "dice = [\n    \"\",\n    \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <svg data-name=\"Layer 1\" viewBox=\"0 0 76.08 76.08\" xmlns=\"http://www.w3.org/2000/svg\">\n        <defs>\n        <style>.cls-1{fill:#fff;stroke-miterlimit:10;}.cls-1,.cls-3{stroke:#000;}.cls-2{font-size:22.7px;font-family:\"Helvetica Neue\",Arial;}.cls-3{stroke-miterlimit:2;stroke-width:1.5px;fill-rule:evenodd;}</style>\n        </defs>\n        <rect class=\"cls-1\" x=\".5\" y=\".5\" width=\"75.08\" height=\"75.08\" rx=\"9.25\"/>\n        <path class=\"cls-3\" d=\"M44.29,38A6.25,6.25,0,1,1,38,31.79,6.25,6.25,0,0,1,44.29,38Z\"/>\n        </svg>",
        "detail": "projects.hog.default_graphics",
        "documentation": {}
    },
    {
        "label": "make_fair_dice",
        "kind": 2,
        "importPath": "projects.hog.dice",
        "description": "projects.hog.dice",
        "peekOfCode": "def make_fair_dice(sides):\n    \"\"\"Return a die that returns 1 to SIDES with equal chance.\"\"\"\n    assert type(sides) == int and sides >= 1, 'Illegal value for sides'\n    def dice():\n        return randint(1,sides)\n    return dice\nfour_sided = make_fair_dice(4)\nsix_sided = make_fair_dice(6)\ndef make_test_dice(*outcomes):\n    \"\"\"Return a die that cycles deterministically through OUTCOMES.",
        "detail": "projects.hog.dice",
        "documentation": {}
    },
    {
        "label": "make_test_dice",
        "kind": 2,
        "importPath": "projects.hog.dice",
        "description": "projects.hog.dice",
        "peekOfCode": "def make_test_dice(*outcomes):\n    \"\"\"Return a die that cycles deterministically through OUTCOMES.\n    >>> dice = make_test_dice(1, 2, 3)\n    >>> dice()\n    1\n    >>> dice()\n    2\n    >>> dice()\n    3\n    >>> dice()",
        "detail": "projects.hog.dice",
        "documentation": {}
    },
    {
        "label": "four_sided",
        "kind": 5,
        "importPath": "projects.hog.dice",
        "description": "projects.hog.dice",
        "peekOfCode": "four_sided = make_fair_dice(4)\nsix_sided = make_fair_dice(6)\ndef make_test_dice(*outcomes):\n    \"\"\"Return a die that cycles deterministically through OUTCOMES.\n    >>> dice = make_test_dice(1, 2, 3)\n    >>> dice()\n    1\n    >>> dice()\n    2\n    >>> dice()",
        "detail": "projects.hog.dice",
        "documentation": {}
    },
    {
        "label": "six_sided",
        "kind": 5,
        "importPath": "projects.hog.dice",
        "description": "projects.hog.dice",
        "peekOfCode": "six_sided = make_fair_dice(6)\ndef make_test_dice(*outcomes):\n    \"\"\"Return a die that cycles deterministically through OUTCOMES.\n    >>> dice = make_test_dice(1, 2, 3)\n    >>> dice()\n    1\n    >>> dice()\n    2\n    >>> dice()\n    3",
        "detail": "projects.hog.dice",
        "documentation": {}
    },
    {
        "label": "roll_dice",
        "kind": 2,
        "importPath": "projects.hog.hog",
        "description": "projects.hog.hog",
        "peekOfCode": "def roll_dice(num_rolls, dice=six_sided): \n    \"\"\"Simulate rolling the DICE exactly NUM_ROLLS > 0 times. Return the sum of\n    the outcomes unless any of the outcomes is 1. In that case, return 1.\n    num_rolls:  The number of dice rolls that will be made.\n    dice:       A function that simulates a single dice roll outcome.\n    The argument dice=six_sided means that when roll_dice is called, the dice argument is optional. \n    If no value for dice is provided, then six_sided is used by default.\n    \"\"\"\n    # These assert statements ensure that num_rolls is a positive integer.\n    assert type(num_rolls) == int, 'num_rolls must be an integer.'",
        "detail": "projects.hog.hog",
        "documentation": {}
    },
    {
        "label": "boar_brawl",
        "kind": 2,
        "importPath": "projects.hog.hog",
        "description": "projects.hog.hog",
        "peekOfCode": "def boar_brawl(player_score, opponent_score):\n    \"\"\"Return the points scored by rolling 0 dice according to Boar Brawl.\n    player_score:     The total score of the current player.\n    opponent_score:   The total score of the other player.\n    \"\"\"\n    # BEGIN PROBLEM 2\n    \"*** YOUR CODE HERE ***\"\n    ones_digits = player_score % 10\n    tens_digits = (opponent_score // 10) % 10\n    if ones_digits == tens_digits:",
        "detail": "projects.hog.hog",
        "documentation": {}
    },
    {
        "label": "take_turn",
        "kind": 2,
        "importPath": "projects.hog.hog",
        "description": "projects.hog.hog",
        "peekOfCode": "def take_turn(num_rolls, player_score, opponent_score, dice=six_sided):\n    \"\"\"Return the points scored on a turn rolling NUM_ROLLS dice when the\n    player has PLAYER_SCORE points and the opponent has OPPONENT_SCORE points.\n    num_rolls:       The number of dice rolls that will be made.\n    player_score:    The total score of the current player.\n    opponent_score:  The total score of the other player.\n    dice:            A function that simulates a single dice roll outcome.\n    \"\"\"\n    # Leave these assert statements here; they help check for errors.\n    assert type(num_rolls) == int, 'num_rolls must be an integer.'",
        "detail": "projects.hog.hog",
        "documentation": {}
    },
    {
        "label": "simple_update",
        "kind": 2,
        "importPath": "projects.hog.hog",
        "description": "projects.hog.hog",
        "peekOfCode": "def simple_update(num_rolls, player_score, opponent_score, dice=six_sided):\n    \"\"\"Return the total score of a player who starts their turn with\n    PLAYER_SCORE and then rolls NUM_ROLLS DICE, ignoring Sus Fuss.\n    \"\"\"\n    score = player_score + take_turn(num_rolls, player_score, opponent_score, dice)\n    return score\ndef is_prime(n):\n    \"\"\"Return whether N is prime.\"\"\"\n    if n == 1:\n        return False",
        "detail": "projects.hog.hog",
        "documentation": {}
    },
    {
        "label": "is_prime",
        "kind": 2,
        "importPath": "projects.hog.hog",
        "description": "projects.hog.hog",
        "peekOfCode": "def is_prime(n):\n    \"\"\"Return whether N is prime.\"\"\"\n    if n == 1:\n        return False\n    k = 2\n    while k < n:\n        if n % k == 0:\n            return False\n        k += 1\n    return True",
        "detail": "projects.hog.hog",
        "documentation": {}
    },
    {
        "label": "num_factors",
        "kind": 2,
        "importPath": "projects.hog.hog",
        "description": "projects.hog.hog",
        "peekOfCode": "def num_factors(n):\n    \"\"\"Return the number of factors of N, including 1 and N itself.\"\"\"\n    # BEGIN PROBLEM 4\n    \"*** YOUR CODE HERE ***\"\n    from math import sqrt\n    if n == 1:\n        num = 1\n    else:\n        num = 2\n        for i in range(2,n):",
        "detail": "projects.hog.hog",
        "documentation": {}
    },
    {
        "label": "sus_points",
        "kind": 2,
        "importPath": "projects.hog.hog",
        "description": "projects.hog.hog",
        "peekOfCode": "def sus_points(score):\n    \"\"\"Return the new score of a player taking into account the Sus Fuss rule.\"\"\"\n    # BEGIN PROBLEM 4\n    \"*** YOUR CODE HERE ***\"\n    if num_factors(score) == 3 or num_factors(score) == 4:\n        while not is_prime(score):\n            score += 1\n    return score\n    # END PROBLEM 4\ndef sus_update(num_rolls, player_score, opponent_score, dice=six_sided):",
        "detail": "projects.hog.hog",
        "documentation": {}
    },
    {
        "label": "sus_update",
        "kind": 2,
        "importPath": "projects.hog.hog",
        "description": "projects.hog.hog",
        "peekOfCode": "def sus_update(num_rolls, player_score, opponent_score, dice=six_sided):\n    \"\"\"Return the total score of a player who starts their turn with\n    PLAYER_SCORE and then rolls NUM_ROLLS DICE, *including* Sus Fuss.\n    \"\"\"\n    # BEGIN PROBLEM 4\n    \"*** YOUR CODE HERE ***\"\n    new_score = simple_update(num_rolls, player_score, opponent_score, dice)\n    return sus_points(new_score)\n    # END PROBLEM 4\ndef always_roll_5(score, opponent_score):",
        "detail": "projects.hog.hog",
        "documentation": {}
    },
    {
        "label": "always_roll_5",
        "kind": 2,
        "importPath": "projects.hog.hog",
        "description": "projects.hog.hog",
        "peekOfCode": "def always_roll_5(score, opponent_score):\n    \"\"\"A strategy of always rolling 5 dice, regardless of the player's score or\n    the opponent's score.\n    \"\"\"\n    return 5\ndef play(strategy0, strategy1, update,\n         score0=0, score1=0, dice=six_sided, goal=GOAL):\n    \"\"\"Simulate a game and return the final scores of both players, with\n    Player 0's score first and Player 1's score second.\n    E.g., play(always_roll_5, always_roll_5, sus_update) simulates a game in",
        "detail": "projects.hog.hog",
        "documentation": {}
    },
    {
        "label": "play",
        "kind": 2,
        "importPath": "projects.hog.hog",
        "description": "projects.hog.hog",
        "peekOfCode": "def play(strategy0, strategy1, update,\n         score0=0, score1=0, dice=six_sided, goal=GOAL):\n    \"\"\"Simulate a game and return the final scores of both players, with\n    Player 0's score first and Player 1's score second.\n    E.g., play(always_roll_5, always_roll_5, sus_update) simulates a game in\n    which both players always choose to roll 5 dice on every turn and the Sus\n    Fuss rule is in effect.\n    A strategy function, such as always_roll_5, takes the current player's\n    score and their opponent's score and returns the number of dice the current\n    player chooses to roll.",
        "detail": "projects.hog.hog",
        "documentation": {}
    },
    {
        "label": "always_roll",
        "kind": 2,
        "importPath": "projects.hog.hog",
        "description": "projects.hog.hog",
        "peekOfCode": "def always_roll(n):\n    \"\"\"Return a player strategy that always rolls N dice.\n    A player strategy is a function that takes two total scores as arguments\n    (the current player's score, and the opponent's score), and returns a\n    number of dice that the current player will roll this turn.\n    >>> strategy = always_roll(3)\n    >>> strategy(0, 0)\n    3\n    >>> strategy(99, 99)\n    3",
        "detail": "projects.hog.hog",
        "documentation": {}
    },
    {
        "label": "catch_up",
        "kind": 2,
        "importPath": "projects.hog.hog",
        "description": "projects.hog.hog",
        "peekOfCode": "def catch_up(score, opponent_score):\n    \"\"\"A player strategy that always rolls 5 dice unless the opponent\n    has a higher score, in which case 6 dice are rolled.\n    >>> catch_up(9, 4)\n    5\n    >>> strategy(17, 18)\n    6\n    \"\"\"\n    if score < opponent_score:\n        return 6  # Roll one more to catch up",
        "detail": "projects.hog.hog",
        "documentation": {}
    },
    {
        "label": "is_always_roll",
        "kind": 2,
        "importPath": "projects.hog.hog",
        "description": "projects.hog.hog",
        "peekOfCode": "def is_always_roll(strategy, goal=GOAL):\n    \"\"\"Return whether STRATEGY always chooses the same number of dice to roll\n    given a game that goes to GOAL points.\n    >>> is_always_roll(always_roll_5)\n    True\n    >>> is_always_roll(always_roll(3))\n    True\n    >>> is_always_roll(catch_up)\n    False\n    \"\"\"",
        "detail": "projects.hog.hog",
        "documentation": {}
    },
    {
        "label": "make_averaged",
        "kind": 2,
        "importPath": "projects.hog.hog",
        "description": "projects.hog.hog",
        "peekOfCode": "def make_averaged(original_function, samples_count=1000):\n    \"\"\"Return a function that returns the average value of ORIGINAL_FUNCTION\n    called SAMPLES_COUNT times.\n    To implement this function, you will have to use *args syntax.\n    >>> dice = make_test_dice(4, 2, 5, 1)\n    >>> averaged_dice = make_averaged(roll_dice, 40)\n    >>> averaged_dice(1, dice)  # The avg of 10 4's, 10 2's, 10 5's, and 10 1's\n    3.0\n    \"\"\"\n    # BEGIN PROBLEM 8",
        "detail": "projects.hog.hog",
        "documentation": {}
    },
    {
        "label": "max_scoring_num_rolls",
        "kind": 2,
        "importPath": "projects.hog.hog",
        "description": "projects.hog.hog",
        "peekOfCode": "def max_scoring_num_rolls(dice=six_sided, samples_count=1000):\n    \"\"\"Return the number of dice (1 to 10) that gives the highest average turn score\n    by calling roll_dice with the provided DICE a total of SAMPLES_COUNT times.\n    Assume that the dice always return positive outcomes.\n    >>> dice = make_test_dice(1, 6)\n    >>> max_scoring_num_rolls(dice)\n    1\n    \"\"\"\n    # BEGIN PROBLEM 9\n    \"*** YOUR CODE HERE ***\"",
        "detail": "projects.hog.hog",
        "documentation": {}
    },
    {
        "label": "winner",
        "kind": 2,
        "importPath": "projects.hog.hog",
        "description": "projects.hog.hog",
        "peekOfCode": "def winner(strategy0, strategy1):\n    \"\"\"Return 0 if strategy0 wins against strategy1, and 1 otherwise.\"\"\"\n    score0, score1 = play(strategy0, strategy1, sus_update)\n    if score0 > score1:\n        return 0\n    else:\n        return 1\ndef average_win_rate(strategy, baseline=always_roll(6)):\n    \"\"\"Return the average win rate of STRATEGY against BASELINE. Averages the\n    winrate when starting the game as player 0 and as player 1.",
        "detail": "projects.hog.hog",
        "documentation": {}
    },
    {
        "label": "average_win_rate",
        "kind": 2,
        "importPath": "projects.hog.hog",
        "description": "projects.hog.hog",
        "peekOfCode": "def average_win_rate(strategy, baseline=always_roll(6)):\n    \"\"\"Return the average win rate of STRATEGY against BASELINE. Averages the\n    winrate when starting the game as player 0 and as player 1.\n    \"\"\"\n    win_rate_as_player_0 = 1 - make_averaged(winner)(strategy, baseline)\n    win_rate_as_player_1 = make_averaged(winner)(baseline, strategy)\n    return (win_rate_as_player_0 + win_rate_as_player_1) / 2\ndef run_experiments():\n    \"\"\"Run a series of strategy experiments and report results.\"\"\"\n    six_sided_max = max_scoring_num_rolls(six_sided)",
        "detail": "projects.hog.hog",
        "documentation": {}
    },
    {
        "label": "run_experiments",
        "kind": 2,
        "importPath": "projects.hog.hog",
        "description": "projects.hog.hog",
        "peekOfCode": "def run_experiments():\n    \"\"\"Run a series of strategy experiments and report results.\"\"\"\n    six_sided_max = max_scoring_num_rolls(six_sided)\n    print('Max scoring num rolls for six-sided dice:', six_sided_max)\n    print('always_roll(6) win rate:', average_win_rate(always_roll(6))) # near 0.5\n    print('catch_up win rate:', average_win_rate(catch_up))\n    print('always_roll(3) win rate:', average_win_rate(always_roll(3)))\n    print('always_roll(8) win rate:', average_win_rate(always_roll(8)))\n    print('boar_strategy win rate:', average_win_rate(boar_strategy))\n    print('sus_strategy win rate:', average_win_rate(sus_strategy))",
        "detail": "projects.hog.hog",
        "documentation": {}
    },
    {
        "label": "boar_strategy",
        "kind": 2,
        "importPath": "projects.hog.hog",
        "description": "projects.hog.hog",
        "peekOfCode": "def boar_strategy(score, opponent_score, threshold=11, num_rolls=6):\n    \"\"\"This strategy returns 0 dice if Boar Brawl gives at least THRESHOLD\n    points, and returns NUM_ROLLS otherwise. Ignore score and Sus Fuss.\n    \"\"\"\n    # BEGIN PROBLEM 10\n    point = boar_brawl(score,opponent_score)\n    if point >= threshold:\n        return 0\n    else:\n        return num_rolls  # Remove this line once implemented.",
        "detail": "projects.hog.hog",
        "documentation": {}
    },
    {
        "label": "sus_strategy",
        "kind": 2,
        "importPath": "projects.hog.hog",
        "description": "projects.hog.hog",
        "peekOfCode": "def sus_strategy(score, opponent_score, threshold=11, num_rolls=6):\n    \"\"\"This strategy returns 0 dice when your score would increase by at least threshold.\"\"\"\n    # BEGIN PROBLEM 11\n    point = boar_brawl(score,opponent_score)\n    new_score = sus_points(score + point)\n    if new_score - score >= threshold:\n        return 0\n    else:\n        return num_rolls  # Remove this line once implemented.\n    # END PROBLEM 11",
        "detail": "projects.hog.hog",
        "documentation": {}
    },
    {
        "label": "final_strategy",
        "kind": 2,
        "importPath": "projects.hog.hog",
        "description": "projects.hog.hog",
        "peekOfCode": "def final_strategy(score, opponent_score):\n    \"\"\"Write a brief description of your final strategy.\n    hushmoon hog final_strategy\n    2024 7 20\n    *** YOUR DESCRIPTION HERE ***   \n    \"\"\"\n    # BEGIN PROBLEM 12\n    if sus_strategy(score,opponent_score) == 0:\n        return 0\n    elif 100 - score <= 3:",
        "detail": "projects.hog.hog",
        "documentation": {}
    },
    {
        "label": "run",
        "kind": 2,
        "importPath": "projects.hog.hog",
        "description": "projects.hog.hog",
        "peekOfCode": "def run(*args):\n    \"\"\"Read in the command-line argument and calls corresponding functions.\"\"\"\n    import argparse\n    parser = argparse.ArgumentParser(description=\"Play Hog\")\n    parser.add_argument('--run_experiments', '-r', action='store_true',\n                        help='Runs strategy experiments')\n    args = parser.parse_args()\n    if args.run_experiments:\n        run_experiments()",
        "detail": "projects.hog.hog",
        "documentation": {}
    },
    {
        "label": "GOAL",
        "kind": 5,
        "importPath": "projects.hog.hog",
        "description": "projects.hog.hog",
        "peekOfCode": "GOAL = 100  # The goal of Hog is to score 100 points.\n######################\n# Phase 1: Simulator #\n######################\ndef roll_dice(num_rolls, dice=six_sided): \n    \"\"\"Simulate rolling the DICE exactly NUM_ROLLS > 0 times. Return the sum of\n    the outcomes unless any of the outcomes is 1. In that case, return 1.\n    num_rolls:  The number of dice rolls that will be made.\n    dice:       A function that simulates a single dice roll outcome.\n    The argument dice=six_sided means that when roll_dice is called, the dice argument is optional. ",
        "detail": "projects.hog.hog",
        "documentation": {}
    },
    {
        "label": "HogLoggingException",
        "kind": 6,
        "importPath": "projects.hog.hog_gui",
        "description": "projects.hog.hog_gui",
        "peekOfCode": "class HogLoggingException(Exception):\n    pass\n@route\ndef take_turn(prev_rolls, move_history, goal, game_rules):\n    \"\"\"Simulate the whole game up to the current turn.\"\"\"\n    fair_dice = dice.make_fair_dice(6)\n    dice_results = []\n    sus_fuss = game_rules[\"Sus Fuss\"]\n    def logged_dice():\n        if len(dice_results) < len(prev_rolls):",
        "detail": "projects.hog.hog_gui",
        "documentation": {}
    },
    {
        "label": "take_turn",
        "kind": 2,
        "importPath": "projects.hog.hog_gui",
        "description": "projects.hog.hog_gui",
        "peekOfCode": "def take_turn(prev_rolls, move_history, goal, game_rules):\n    \"\"\"Simulate the whole game up to the current turn.\"\"\"\n    fair_dice = dice.make_fair_dice(6)\n    dice_results = []\n    sus_fuss = game_rules[\"Sus Fuss\"]\n    def logged_dice():\n        if len(dice_results) < len(prev_rolls):\n            out = prev_rolls[len(dice_results)]\n        else:\n            out = fair_dice()",
        "detail": "projects.hog.hog_gui",
        "documentation": {}
    },
    {
        "label": "strategy",
        "kind": 2,
        "importPath": "projects.hog.hog_gui",
        "description": "projects.hog.hog_gui",
        "peekOfCode": "def strategy(name, scores):\n    STRATEGIES = {\n        \"boar_strategy\": hog.boar_strategy,\n        \"sus_strategy\": hog.sus_strategy,\n        \"final_strategy\": hog.final_strategy,\n    }\n    return STRATEGIES[name](*scores[::-1])\n@route(\"dice_graphic.svg\")\ndef draw_dice_graphic(num):\n    num = int(num[0])",
        "detail": "projects.hog.hog_gui",
        "documentation": {}
    },
    {
        "label": "draw_dice_graphic",
        "kind": 2,
        "importPath": "projects.hog.hog_gui",
        "description": "projects.hog.hog_gui",
        "peekOfCode": "def draw_dice_graphic(num):\n    num = int(num[0])\n    # Either draw student-provided dice or our default dice\n    if hasattr(hog, \"draw_dice\"):\n        graphic = hog.draw_dice(num)\n        return str(graphic)\n    return default_graphics.dice[num]\ndef trace_play(play, strategy0, strategy1, update, score0, score1, dice, goal):\n    \"\"\"Wraps the user's play function and\n        (1) ensures that strategy0 and strategy1 are called exactly once per turn",
        "detail": "projects.hog.hog_gui",
        "documentation": {}
    },
    {
        "label": "trace_play",
        "kind": 2,
        "importPath": "projects.hog.hog_gui",
        "description": "projects.hog.hog_gui",
        "peekOfCode": "def trace_play(play, strategy0, strategy1, update, score0, score1, dice, goal):\n    \"\"\"Wraps the user's play function and\n        (1) ensures that strategy0 and strategy1 are called exactly once per turn\n        (2) records the entire game, returning the result as a list of dictionaries,\n            each with keys \"s0_start\", \"s1_start\", \"who\", \"num_dice\", \"dice_values\"\n    Returns (s0, s1, trace) where s0, s1 are the return values from play and trace\n        is the trace as specified above.\n    This might seem a bit overcomplicated but it will also used to create the game\n        traces for the fuzz test (when run against the staff solution).\n    \"\"\"",
        "detail": "projects.hog.hog_gui",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": "projects.hog.hog_gui",
        "description": "projects.hog.hog_gui",
        "peekOfCode": "PORT = 31415\nDEFAULT_SERVER = \"https://hog.cs61a.org\"\nGUI_FOLDER = \"gui_files/\"\nPATHS = {}\nclass HogLoggingException(Exception):\n    pass\n@route\ndef take_turn(prev_rolls, move_history, goal, game_rules):\n    \"\"\"Simulate the whole game up to the current turn.\"\"\"\n    fair_dice = dice.make_fair_dice(6)",
        "detail": "projects.hog.hog_gui",
        "documentation": {}
    },
    {
        "label": "DEFAULT_SERVER",
        "kind": 5,
        "importPath": "projects.hog.hog_gui",
        "description": "projects.hog.hog_gui",
        "peekOfCode": "DEFAULT_SERVER = \"https://hog.cs61a.org\"\nGUI_FOLDER = \"gui_files/\"\nPATHS = {}\nclass HogLoggingException(Exception):\n    pass\n@route\ndef take_turn(prev_rolls, move_history, goal, game_rules):\n    \"\"\"Simulate the whole game up to the current turn.\"\"\"\n    fair_dice = dice.make_fair_dice(6)\n    dice_results = []",
        "detail": "projects.hog.hog_gui",
        "documentation": {}
    },
    {
        "label": "GUI_FOLDER",
        "kind": 5,
        "importPath": "projects.hog.hog_gui",
        "description": "projects.hog.hog_gui",
        "peekOfCode": "GUI_FOLDER = \"gui_files/\"\nPATHS = {}\nclass HogLoggingException(Exception):\n    pass\n@route\ndef take_turn(prev_rolls, move_history, goal, game_rules):\n    \"\"\"Simulate the whole game up to the current turn.\"\"\"\n    fair_dice = dice.make_fair_dice(6)\n    dice_results = []\n    sus_fuss = game_rules[\"Sus Fuss\"]",
        "detail": "projects.hog.hog_gui",
        "documentation": {}
    },
    {
        "label": "PATHS",
        "kind": 5,
        "importPath": "projects.hog.hog_gui",
        "description": "projects.hog.hog_gui",
        "peekOfCode": "PATHS = {}\nclass HogLoggingException(Exception):\n    pass\n@route\ndef take_turn(prev_rolls, move_history, goal, game_rules):\n    \"\"\"Simulate the whole game up to the current turn.\"\"\"\n    fair_dice = dice.make_fair_dice(6)\n    dice_results = []\n    sus_fuss = game_rules[\"Sus Fuss\"]\n    def logged_dice():",
        "detail": "projects.hog.hog_gui",
        "documentation": {}
    },
    {
        "label": "play_and_print",
        "kind": 2,
        "importPath": "projects.hog.hog_ui",
        "description": "projects.hog.hog_ui",
        "peekOfCode": "def play_and_print(strategy0, strategy1):\n    \"\"\"Simulate a game and print out what happened during the simulation.\"\"\"\n    final0, final1 = play(printing_strategy(0, strategy0),\n                          printing_strategy(1, strategy1),\n                          sus_update_and_print, 0, 0,\n                          printing_dice(six_sided))\n    print('The final score is Player 0:', final0, 'vs Player 1:', final1)\ndef printing_strategy(who, strategy):\n    \"\"\"Return a strategy that also prints the player's score and choice.\n    (This could print \"rolls 1 dice...\" which is ungrammatical, but that's ok.)",
        "detail": "projects.hog.hog_ui",
        "documentation": {}
    },
    {
        "label": "printing_strategy",
        "kind": 2,
        "importPath": "projects.hog.hog_ui",
        "description": "projects.hog.hog_ui",
        "peekOfCode": "def printing_strategy(who, strategy):\n    \"\"\"Return a strategy that also prints the player's score and choice.\n    (This could print \"rolls 1 dice...\" which is ungrammatical, but that's ok.)\n    >>> strategy0 = printing_strategy(0, always_roll_5)\n    >>> strategy0(10, 20)\n    The score is 10 to 20 and Player 0 rolls 5 dice...\n    5\n    >>> strategy1 = printing_strategy(1, always_roll_5)\n    >>> strategy1(8, 16)\n    The score is 16 to 8 and Player 1 rolls 5 dice...",
        "detail": "projects.hog.hog_ui",
        "documentation": {}
    },
    {
        "label": "printing_dice",
        "kind": 2,
        "importPath": "projects.hog.hog_ui",
        "description": "projects.hog.hog_ui",
        "peekOfCode": "def printing_dice(dice):\n    \"\"\"Return a dice function that also prints the outcome and a space.\"\"\"\n    def dice_and_print():\n        \"A dice function that also prints.\"\n        outcome = dice()\n        print(outcome, end=' ')\n        return outcome\n    return dice_and_print\ndef sus_update_and_print(num_rolls, player_score, opponent_score, dice):\n    \"\"\"Return the updated score, print out the score update, and print when",
        "detail": "projects.hog.hog_ui",
        "documentation": {}
    },
    {
        "label": "sus_update_and_print",
        "kind": 2,
        "importPath": "projects.hog.hog_ui",
        "description": "projects.hog.hog_ui",
        "peekOfCode": "def sus_update_and_print(num_rolls, player_score, opponent_score, dice):\n    \"\"\"Return the updated score, print out the score update, and print when\n    Sus Fuss is triggered.\n    >>> d = printing_dice(make_test_dice(4, 5, 3))\n    >>> sus_update_and_print(3, 9, 99, d)\n      [ 4 5 3 ] => 12; 9 + 12 = 21 triggering **Sus Fuss**, increasing to 23\n    23\n    \"\"\"\n    print('  [', end=\" \")\n    turn_score = take_turn(num_rolls, player_score, opponent_score, dice)  # Prints dice outcomes",
        "detail": "projects.hog.hog_ui",
        "documentation": {}
    },
    {
        "label": "get_int",
        "kind": 2,
        "importPath": "projects.hog.hog_ui",
        "description": "projects.hog.hog_ui",
        "peekOfCode": "def get_int(prompt, lower, upper):\n    \"\"\"Return an integer i such that i >= lower and i <= upper.\"\"\"\n    choice = input(prompt)\n    while not choice.isnumeric() or int(choice) < lower or int(choice) > upper:\n        print('Please enter an integer from', lower, 'to', upper)\n        choice = input(prompt)\n    return int(choice)\ndef interactive_strategy(who):\n    \"\"\"Return a strategy for which the user provides the number of rolls.\"\"\"\n    def strategy(score, opponent_score):",
        "detail": "projects.hog.hog_ui",
        "documentation": {}
    },
    {
        "label": "interactive_strategy",
        "kind": 2,
        "importPath": "projects.hog.hog_ui",
        "description": "projects.hog.hog_ui",
        "peekOfCode": "def interactive_strategy(who):\n    \"\"\"Return a strategy for which the user provides the number of rolls.\"\"\"\n    def strategy(score, opponent_score):\n        print('Player', who, ', you have', score, 'and your opponent has', opponent_score)\n        choice = get_int('How many dice will you roll? ', 0, 10)\n        return choice\n    return strategy\n####################\n# Playing the game #\n####################",
        "detail": "projects.hog.hog_ui",
        "documentation": {}
    },
    {
        "label": "play_with",
        "kind": 2,
        "importPath": "projects.hog.hog_ui",
        "description": "projects.hog.hog_ui",
        "peekOfCode": "def play_with(num_players):\n    \"\"\"Play a game with NUM_PLAYERS interactive (human) players.\"\"\"\n    if num_players == 0:\n        play_and_print(always_roll_5, always_roll_5)\n    elif num_players == 1:\n        play_and_print(interactive_strategy(0), always_roll_5)\n    elif num_players == 2:\n        play_and_print(interactive_strategy(0), interactive_strategy(1))\n    else:\n        print('num_players must be 0, 1, or 2.')",
        "detail": "projects.hog.hog_ui",
        "documentation": {}
    },
    {
        "label": "run",
        "kind": 2,
        "importPath": "projects.hog.hog_ui",
        "description": "projects.hog.hog_ui",
        "peekOfCode": "def run(*args):\n    \"\"\"Select number of players and play a game.\"\"\"\n    import argparse\n    parser = argparse.ArgumentParser(description=\"Play Hog\")\n    parser.add_argument('--num_players', '-n', type=int, default=0,\n                        help='How many interactive players (0, 1, or 2)')\n    args = parser.parse_args()\n    play_with(args.num_players)",
        "detail": "projects.hog.hog_ui",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "projects.hog.ucb",
        "description": "projects.hog.ucb",
        "peekOfCode": "def main(fn):\n    \"\"\"Call fn with command line arguments.  Used as a decorator.\n    The main decorator marks the function that starts a program. For example,\n    @main\n    def my_run_function():\n        # function body\n    Use this instead of the typical __name__ == \"__main__\" predicate.\n    \"\"\"\n    if inspect.stack()[1][0].f_locals['__name__'] == '__main__':\n        args = sys.argv[1:] # Discard the script name from command line",
        "detail": "projects.hog.ucb",
        "documentation": {}
    },
    {
        "label": "trace",
        "kind": 2,
        "importPath": "projects.hog.ucb",
        "description": "projects.hog.ucb",
        "peekOfCode": "def trace(fn):\n    \"\"\"A decorator that prints a function's name, its arguments, and its return\n    values each time the function is called. For example,\n    @trace\n    def compute_something(x, y):\n        # function body\n    \"\"\"\n    @functools.wraps(fn)\n    def wrapped(*args, **kwds):\n        global _PREFIX",
        "detail": "projects.hog.ucb",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 2,
        "importPath": "projects.hog.ucb",
        "description": "projects.hog.ucb",
        "peekOfCode": "def log(message):\n    \"\"\"Print an indented message (used with trace).\"\"\"\n    print(_PREFIX + re.sub('\\n', '\\n' + _PREFIX, str(message)))\ndef log_current_line():\n    \"\"\"Print information about the current line of code.\"\"\"\n    frame = inspect.stack()[1]\n    log('Current line: File \"{f[1]}\", line {f[2]}, in {f[3]}'.format(f=frame))\ndef interact(msg=None):\n    \"\"\"Start an interactive interpreter session in the current environment.\n    On Unix:",
        "detail": "projects.hog.ucb",
        "documentation": {}
    },
    {
        "label": "log_current_line",
        "kind": 2,
        "importPath": "projects.hog.ucb",
        "description": "projects.hog.ucb",
        "peekOfCode": "def log_current_line():\n    \"\"\"Print information about the current line of code.\"\"\"\n    frame = inspect.stack()[1]\n    log('Current line: File \"{f[1]}\", line {f[2]}, in {f[3]}'.format(f=frame))\ndef interact(msg=None):\n    \"\"\"Start an interactive interpreter session in the current environment.\n    On Unix:\n      <Control>-D exits the interactive session and returns to normal execution.\n    In Windows:\n      <Control>-Z <Enter> exits the interactive session and returns to normal",
        "detail": "projects.hog.ucb",
        "documentation": {}
    },
    {
        "label": "interact",
        "kind": 2,
        "importPath": "projects.hog.ucb",
        "description": "projects.hog.ucb",
        "peekOfCode": "def interact(msg=None):\n    \"\"\"Start an interactive interpreter session in the current environment.\n    On Unix:\n      <Control>-D exits the interactive session and returns to normal execution.\n    In Windows:\n      <Control>-Z <Enter> exits the interactive session and returns to normal\n      execution.\n    \"\"\"\n    # evaluate commands in current namespace\n    frame = inspect.currentframe().f_back",
        "detail": "projects.hog.ucb",
        "documentation": {}
    },
    {
        "label": "_PREFIX",
        "kind": 5,
        "importPath": "projects.hog.ucb",
        "description": "projects.hog.ucb",
        "peekOfCode": "_PREFIX = ''\ndef trace(fn):\n    \"\"\"A decorator that prints a function's name, its arguments, and its return\n    values each time the function is called. For example,\n    @trace\n    def compute_something(x, y):\n        # function body\n    \"\"\"\n    @functools.wraps(fn)\n    def wrapped(*args, **kwds):",
        "detail": "projects.hog.ucb",
        "documentation": {}
    },
    {
        "label": "Pet",
        "kind": 6,
        "importPath": "workfile.classinheritance",
        "description": "workfile.classinheritance",
        "peekOfCode": "class Pet:\n    def __init__(self, name, owner):\n        self.is_alive = True  \n        self.name = name\n        self.owner = owner\n    def eat(self, thing):\n        print(self.name + \" ate a \" + str(thing) + \"!\")\n    def talk(self):\n        print(self.name)\nclass Dog(Pet):",
        "detail": "workfile.classinheritance",
        "documentation": {}
    },
    {
        "label": "Dog",
        "kind": 6,
        "importPath": "workfile.classinheritance",
        "description": "workfile.classinheritance",
        "peekOfCode": "class Dog(Pet):\n    def talk(self):\n        super().talk()\n        print('This Dog says woof!')",
        "detail": "workfile.classinheritance",
        "documentation": {}
    },
    {
        "label": "mzb",
        "kind": 5,
        "importPath": "workfile.pet",
        "description": "workfile.pet",
        "peekOfCode": "mzb = Dog('mzb','ycy')\nmzb.talk()",
        "detail": "workfile.pet",
        "documentation": {}
    }
]